<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
    <link rel="canonical" href="https://soundbox.altwaves.co.jp/">
    <meta name="description" content="Soundbox Engine v7.0 (Rev 1.1): Honest Measurement â€” No Sabine Extrapolation">
    <title>Soundbox Material Calculator v7 | ãƒ—ãƒ­ãƒ•ã‚§ãƒƒã‚·ãƒ§ãƒŠãƒ«èª¿éŸ³è¨­è¨ˆãƒ„ãƒ¼ãƒ«</title>
    
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        :root { 
            --primary: #39d353; 
            --bg: #0d1117; 
            --card: #161b22; 
            --text: #e6edf3; 
            --dim: #8b949e; 
            --border: #30363d; 
            --accent: #388bfd; 
            --danger: #ff7b72; 
            --warning: #d29922; 
            --success: #39d353; 
            --caution: #f0883e;
        }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif; background-color: var(--bg); color: var(--text); padding: 15px; margin: 0; font-size: 13px; line-height: 1.4; }
        .container { max-width: 1000px; min-width: 800px; margin: auto; background: var(--card); padding: 25px; border-radius: 12px; border: 1px solid var(--border); box-shadow: 0 10px 40px rgba(0,0,0,0.5); position: relative; }
        .header { border-bottom: 1px solid var(--border); margin-bottom: 20px; padding-bottom: 12px; position: relative; }
        .header-top { display: flex; justify-content: space-between; align-items: flex-start; }
        h2 { color: var(--primary); margin: 0; font-size: 1.4rem; letter-spacing: 0.5px; }
        .subtitle { font-size: 0.85rem; color: var(--text); margin-top: 5px; font-weight: 500; }
        .logic-note { position: absolute; bottom: 8px; right: 0; font-size: 0.65rem; color: var(--dim); font-style: italic; }
        .btn-group { display: flex; gap: 10px; }
        .btn-base { border: none; padding: 7px 16px; border-radius: 4px; font-size: 0.75rem; cursor: pointer; font-weight: bold; transition: opacity 0.2s; text-decoration: none; }
        .btn-print { background: var(--border); color: var(--text); border: 1px solid var(--border); }
        .btn-estimate { background: var(--accent); color: white; }
        .btn-base:hover { opacity: 0.8; }
        .section-title { font-size: 0.8rem; font-weight: bold; color: var(--accent); margin: 20px 0 10px 0; border-left: 3px solid var(--accent); padding-left: 8px; }
        input, select, .custom-select-trigger { background: var(--bg); border: 1px solid var(--border); color: var(--text); padding: 0 10px; border-radius: 4px; width: 100%; box-sizing: border-box; font-size: 0.75rem; height: 36px; line-height: 34px; display: flex; align-items: center; }
        .grid-3 { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-bottom: 10px; }
        .grid-row { display: grid; grid-template-columns: 2fr 3.5fr 0.8fr 0.8fr 1fr; gap: 8px; margin-bottom: 8px; align-items: end; }
        label { font-size: 0.65rem; color: var(--dim); margin-bottom: 4px; display: block; }
        .custom-select-container { position: relative; width: 100%; }
        .custom-select-trigger { cursor: pointer; overflow: hidden; white-space: nowrap; text-overflow: ellipsis; border: 1px solid var(--border); }
        .sub-panel { display: none; position: absolute; top: 100%; left: 0; width: 540px; background: #1c2128; border: 1px solid var(--accent); border-radius: 8px; z-index: 100; box-shadow: 0 10px 30px rgba(0,0,0,0.8); padding: 15px; margin-top: 5px; }
        .sub-panel.active { display: block; }
        .panel-cols { display: grid; grid-template-columns: 1.4fr 0.8fr 1.2fr; gap: 12px; }
        .col-title { font-size: 0.6rem; color: var(--accent); margin-bottom: 8px; font-weight: bold; border-bottom: 1px solid var(--border); padding-bottom: 4px; }
        .col-item { padding: 6px 10px; border-radius: 4px; cursor: pointer; margin-bottom: 3px; font-size: 0.7rem; color: var(--text); }
        .col-item:hover { background: var(--border); }
        .col-item.selected { background: var(--accent); color: white; font-weight: bold; }
        .res-panel { display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; margin: 20px 0; }
        @media (max-width: 640px) {
            .res-panel { gap: 6px; }
            .res-card { padding: 8px 6px; }
            .res-val { font-size: 1.1rem; }
        }
        .res-card { background: var(--bg); padding: 15px; border-radius: 10px; border: 2px solid var(--border); text-align: center; }
        .res-val { font-size: 1.6rem; font-weight: bold; font-family: "Roboto Mono", monospace; }
        .chart-wrapper { position: relative; height: 320px; margin-top: 10px; border: 1px solid var(--border); border-radius: 8px; padding: 10px; background: rgba(0,0,0,0.2); }
        .footer-note { margin-top: 20px; padding: 18px; background: rgba(56, 139, 253, 0.05); border-radius: 8px; border: 1px solid var(--border); }
        .advice-tag { display: inline-block; padding: 2px 8px; border-radius: 4px; font-weight: bold; margin-bottom: 8px; font-size: 0.7rem; color: #000; }
        #print-only-notice { display: none; margin-top: 30px; padding: 20px; border: 1px solid #ddd; border-radius: 8px; font-size: 0.75rem; line-height: 1.6; color: #333; }
        .mode-switcher { display: flex; background: var(--bg); padding: 4px; border-radius: 8px; border: 1px solid var(--border); margin-bottom: 20px; }
        .mode-btn { flex: 1; padding: 10px; border: none; background: transparent; color: var(--dim); cursor: pointer; border-radius: 6px; font-weight: bold; transition: 0.2s; font-size: 0.75rem; }
        .mode-btn.active { background: var(--accent); color: white; }
        .mode-btn.active.measure { background: var(--warning); color: #000; }
        .calc-badge { display: inline-block; padding: 2px 6px; border-radius: 3px; font-size: 0.6rem; font-weight: bold; margin-left: 5px; background: var(--accent); color: white; }
        .measurement-panel { background: rgba(56, 139, 253, 0.05); border: 1px solid var(--accent); border-radius: 8px; padding: 15px; margin-bottom: 20px; }
        .measure-controls { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; align-items: start; }
        .status-msg { font-size: 0.75rem; margin-top: 10px; font-weight: 500; min-height: 1.2em; padding: 8px; border-radius: 4px; text-align: center; }
        .status-msg.ready { color: var(--dim); }
        .status-msg.calibrating { background: rgba(210, 153, 34, 0.1); color: var(--warning); }
        .status-msg.analyzing { background: rgba(56, 139, 253, 0.1); color: var(--accent); }
        .status-msg.success { background: rgba(57, 211, 83, 0.1); color: var(--success); }
        .status-msg.warning { background: rgba(210, 153, 34, 0.2); color: var(--warning); }
        .status-msg.error { background: rgba(255, 123, 114, 0.1); color: var(--danger); }
        .measure-progress { margin-top: 10px; padding: 10px 12px; background: rgba(0,0,0,0.2); border-radius: 6px; border: 1px solid var(--border); }
        .measure-progress-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px; }
        .measure-progress-label { font-size: 0.72rem; color: var(--text); font-weight: 500; }
        .measure-progress-count { font-size: 0.65rem; color: var(--dim); font-family: "Roboto Mono", monospace; }
        .measure-progress-bar-track { width: 100%; height: 8px; background: var(--border); border-radius: 4px; overflow: hidden; }
        .measure-progress-bar-fill { height: 100%; width: 0%; background: var(--accent); border-radius: 4px; transition: width 0.4s ease; }
        .measure-progress-time { font-size: 0.65rem; color: var(--dim); margin-top: 5px; text-align: right; }
        .recording-flash { display: none; background: rgba(255, 123, 114, 0.1); border: 2px solid var(--danger); border-radius: 8px; padding: 15px; margin-top: 10px; text-align: center; }
        .recording-flash.active { display: block; animation: flash-border 1s infinite; }
        .flash-icon { font-size: 2rem; animation: blink 1s infinite; }
        .flash-text { font-size: 0.9rem; font-weight: bold; color: var(--danger); margin-top: 8px; }
        @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }
        @keyframes flash-border { 0%, 100% { border-color: var(--danger); } 50% { border-color: rgba(255, 123, 114, 0.3); } }
        .snr-indicator { margin-top: 10px; padding: 10px; background: rgba(0,0,0,0.2); border-radius: 6px; }
        .snr-bar { position: relative; width: 100%; height: 20px; background: var(--border); border-radius: 10px; overflow: hidden; margin-top: 5px; }
        .snr-value { height: 100%; background: linear-gradient(90deg, var(--danger), var(--warning), var(--success)); transition: width 0.3s; display: flex; align-items: center; justify-content: flex-end; padding-right: 8px; font-size: 0.7rem; font-weight: bold; color: white; }
        .warning-box { background: rgba(255, 123, 114, 0.1); border: 1px solid var(--danger); border-radius: 6px; padding: 12px; margin-top: 10px; font-size: 0.75rem; }
        .warning-box.warning-yellow { background: rgba(210, 153, 34, 0.15); border: 1px solid var(--warning); }
        .warning-box button { margin-top: 8px; padding: 6px 12px; background: var(--danger); color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.7rem; font-weight: bold; }
        .warning-box.warning-yellow button { background: var(--warning); }
        .warning-box button:hover { opacity: 0.8; }
        #warning-reason { margin-top: 5px; font-size: 0.7rem; color: var(--dim); }

        @media print {
            @page { size: A4; margin: 15mm; }
            body { background: white !important; color: black !important; padding: 0; }
            .container { box-shadow: none !important; border: none !important; width: 100% !important; max-width: none !important; min-width: 0 !important; background: white !important; padding: 0 !important; }
            .no-print, .logic-note, .mode-switcher, .measurement-panel { display: none !important; }
            .header { border-bottom: 2pt solid black !important; }
            h2, .section-title, .res-val, .subtitle { color: black !important; }
            input, select, .custom-select-trigger { border: none !important; background: transparent !important; color: black !important; padding: 0 !important; height: auto !important; appearance: none; }
            .grid-row { border-bottom: 0.5pt solid #eee; padding-bottom: 5px; }
            .res-card { border: 1pt solid black !important; background: white !important; }
            .chart-wrapper { border: 1pt solid #ccc !important; background: white !important; height: 300px !important; }
            .footer-note { border: 1pt solid #ccc !important; background: #f9f9f9 !important; color: black !important; }
            #print-only-notice { display: block !important; border: none !important; }
        }
    </style>
</head>
<body>
<div class="container">
    <div class="header">
        <div class="header-top">
            <h2>Soundbox Material Calculator</h2>
            <div class="btn-group no-print">
                <button class="btn-base btn-print" onclick="prepareForPrint()">çµæœã‚’å°åˆ· / PDFä¿å­˜</button>
                <button class="btn-base btn-estimate" onclick="sendToGoogleForm()">ã“ã®å†…å®¹ã§è¦‹ç©ã‚‚ã‚Šä¾é ¼</button>
            </div>
        </div>
        <div class="subtitle">Soundbox Engine v7.0 (Rev 1.1): Honest Measurement â€” No Sabine Extrapolation</div>
        <div class="logic-note">Hybrid Calculation Engine Active</div>
    </div>

    <div class="mode-switcher no-print">
        <button class="mode-btn active" id="btnSim" onclick="setMode('sim')">è¨­è¨ˆã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ (Sabine)</button>
        <button class="mode-btn" id="btnMeasure" onclick="setMode('measure')">å®Ÿæ¸¬å€¤ãƒ™ãƒ¼ã‚¹æ”¹å–„ (Eyring)</button>
    </div>

    <div id="measurementPanel" class="measurement-panel no-print" style="display:none;">
        <div style="font-size:0.8rem; font-weight:bold; color:var(--accent); margin-bottom:12px;">
            ğŸ¤ PRO æ¸¬å®šãƒ¢ãƒ¼ãƒ‰ (Eyring Method / Log-Sweep Analysis)
        </div>
        <div class="measure-controls">
            <div>
                <label>å…¥åŠ›ãƒ‡ãƒã‚¤ã‚¹ (ãƒã‚¤ã‚¯)</label>
                <select id="micSelect"><option value="">ãƒ‡ãƒã‚¤ã‚¹ã‚’é¸æŠ...</option></select>
            </div>
            <div>
                <label>å‡ºåŠ›ãƒ‡ãƒã‚¤ã‚¹ (ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼)</label>
                <select id="spkSelect"><option value="">ãƒ‡ãƒã‚¤ã‚¹ã‚’é¸æŠ...</option></select>
            </div>
            <div>
                <label>æ¸¬å®šç²¾åº¦ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«</label>
                <select id="snrProfile" onchange="updateSNRProfileInfo()">
                    <option value="low">ä½ï¼ˆå†…è”µãƒ‡ãƒã‚¤ã‚¹å‘ã‘ï¼‰</option>
                    <option value="medium" selected>ä¸­ï¼ˆæ¨å¥¨ãƒ»Bluetoothï¼‰</option>
                    <option value="high">é«˜ï¼ˆISOæº–æ‹ ï¼‰</option>
                </select>
                <small id="snrProfileInfo" style="display:block; margin-top:4px; color:var(--dim); font-size:0.7rem; height:3.9em; line-height:1.3; overflow:hidden;">
                    ä¸€èˆ¬çš„ãªéŸ³éŸ¿æ¸¬å®šã«é©ã—ã¦ã„ã¾ã™
                </small>
            </div>
            <button class="btn-base btn-estimate" id="startMeasBtn" onclick="runMeasurementSequence()">
                æ¸¬å®šé–‹å§‹
            </button>
        </div>
        <div id="measureStatus" class="status-msg ready">Ready - ãƒ‡ãƒã‚¤ã‚¹ã‚’é¸æŠã—ã¦æ¸¬å®šé–‹å§‹ã—ã¦ãã ã•ã„</div>
        <div id="measureProgress" class="measure-progress" style="display:none;">
            <div class="measure-progress-header">
                <span id="progressLabel" class="measure-progress-label">æº–å‚™ä¸­...</span>
                <span id="progressCount" class="measure-progress-count">0 / 18</span>
            </div>
            <div class="measure-progress-bar-track">
                <div id="progressBar" class="measure-progress-bar-fill"></div>
            </div>
            <div id="progressTime" class="measure-progress-time">æ®‹ã‚Šç´„ 93 ç§’</div>
        </div>
        <div id="snrIndicator" class="snr-indicator" style="display:none;">
            <label style="font-size:0.7rem; color:var(--dim);">ä¿¡å·å¯¾é›‘éŸ³æ¯” (S/N Ratio)</label>
            <div class="snr-bar">
                <div id="snrValue" class="snr-value" style="width:0%;"></div>
            </div>
        </div>
        <div id="recordingAlert" class="recording-flash">
            <div class="flash-icon">ğŸ”´</div>
            <div class="flash-text">ğŸ“¢ æ¸¬å®šä¸­ã§ã™ - é™ã‹ã«ã—ã¦ãã ã•ã„</div>
        </div>
        <div id="remeasureWarning" class="warning-box" style="display:none;">
            <strong>âš ï¸ ãƒ‡ãƒ¼ã‚¿å“è³ªãŒä¸è¶³ã—ã¦ã„ã¾ã™</strong>
            <div id="warningReason"></div>
            <button onclick="runMeasurementSequence()">å†æ¸¬å®šã‚’å®Ÿè¡Œ</button>
        </div>
        <div id="manualInputPanel" style="display:none; margin-top:15px; padding:12px; background:rgba(0,0,0,0.2); border-radius:6px;">
            <label style="font-size:0.7rem; color:var(--warning); font-weight:bold;">æ‰‹å‹•å…¥åŠ›ãƒ¢ãƒ¼ãƒ‰ï¼ˆæ¸¬å®šå€¤ã‚’ç›´æ¥å…¥åŠ›ï¼‰</label>
            <div style="display: grid; grid-template-columns: repeat(6, 1fr); gap: 5px; margin-top: 8px;">
                <div><label>125Hz</label><input type="number" id="m125" value="0.80" step="0.01" style="height:28px; font-size:0.7rem; text-align:center;" oninput="calculate()"></div>
                <div><label>250Hz</label><input type="number" id="m250" value="0.70" step="0.01" style="height:28px; font-size:0.7rem; text-align:center;" oninput="calculate()"></div>
                <div><label>500Hz</label><input type="number" id="m500" value="0.60" step="0.01" style="height:28px; font-size:0.7rem; text-align:center;" oninput="calculate()"></div>
                <div><label>1kHz</label><input type="number" id="m1k" value="0.60" step="0.01" style="height:28px; font-size:0.7rem; text-align:center;" oninput="calculate()"></div>
                <div><label>2kHz</label><input type="number" id="m2k" value="0.50" step="0.01" style="height:28px; font-size:0.7rem; text-align:center;" oninput="calculate()"></div>
                <div><label>4kHz</label><input type="number" id="m4k" value="0.50" step="0.01" style="height:28px; font-size:0.7rem; text-align:center;" oninput="calculate()"></div>
            </div>
            <div style="font-size:0.65rem; color:var(--dim); margin-top:8px;">â€» è‡ªå‹•æ¸¬å®šãŒåˆ©ç”¨ã§ããªã„å ´åˆã€å¤–éƒ¨æ¸¬å®šå™¨ã§å–å¾—ã—ãŸæ®‹éŸ¿æ™‚é–“ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„</div>
        </div>
    </div>

    <div class="section-title">1. åŸºæœ¬ç’°å¢ƒè¨­å®š</div>
    <div class="grid-3">
        <div><label>åˆ©ç”¨ç›®çš„ (ç›®æ¨™å€¤)</label><select id="appTarget"></select></div>
        <div>
            <label>éƒ¨å±‹ã‚µã‚¤ã‚º W / D / H [m]</label>
            <div style="display:flex; gap:4px;">
                <input type="number" id="w" value="4.0" step="0.1">
                <input type="number" id="d" value="6.0" step="0.1">
                <input type="number" id="h" value="2.6" step="0.1">
            </div>
        </div>
        <div><label>å£é¢ä»•ä¸Šã’ (ãƒ™ãƒ¼ã‚¹)</label><select id="baseWall"></select></div>
    </div>
    <div class="grid-3">
        <div><label>å¤©äº•ä»•ä¸Šã’</label><select id="baseCeiling"></select></div>
        <div><label>åºŠä»•ä¸Šã’</label><select id="baseFloor"></select></div>
        <div style="display:flex; align-items:flex-end; padding-bottom:5px;">
            <input type="checkbox" id="showSpecial" style="width:16px; margin-right:8px;">
            <label for="showSpecial" style="margin:0; cursor:pointer; color:var(--accent);">é–‹å£éƒ¨(çª“ç­‰)ã‚’è€ƒæ…®ã™ã‚‹</label>
        </div>
    </div>
    <div id="specialPanel" style="display:none; background: rgba(56, 139, 253, 0.05); padding: 12px; border-radius: 6px; margin-bottom: 10px; border: 1px dashed var(--accent);">
        <div class="grid-3" style="grid-template-columns: 2fr 1fr 1fr;">
            <div><label>è¿½åŠ ç´ æ</label><select id="exMat"></select></div>
            <div><label>é¢ç© [ã¡]</label><input type="number" id="exArea" value="2.0" step="0.1"></div>
        </div>
    </div>

    <div class="section-title">2. è£½å“ã‚»ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³</div>
    <div id="sbInputs"></div>

    <div class="res-panel">
        <div class="res-card">
            <label style="font-size:0.6rem">å¹³å‡æ®‹éŸ¿æ™‚é–“ (500Hz-1kHz)</label>
            <div id="postRT_Avg" class="res-val">-</div>
            <div id="measuredBandInfo" style="font-size:0.58rem; color:var(--dim); margin-top:2px; min-height:0.9em;"></div>
            <div id="targetLabel" style="font-size:0.6rem; color:var(--dim)">ç›®æ¨™: -</div>
            <div id="calcMethod" style="font-size:0.55rem; color:var(--dim); margin-top:3px;">
                <span class="calc-badge" id="methodBadge">SABINE</span>
            </div>
        </div>
        <div class="res-card" id="cardHealth">
            <label style="font-size:0.6rem">å®Ÿç”¨æ€§è©•ä¾¡</label>
            <div id="achievementRate" class="res-val">-</div>
            <div id="healthStatus" style="font-size:0.65rem; font-weight:bold;">-</div>
        </div>
        <!-- 3æšç›®ã‚«ãƒ¼ãƒ‰: å°å…¥é¢ç© + æ‹¡æ•£ã‚«ãƒãƒ¬ãƒƒã‚¸ç‡ + æœ‰åŠ¹ä¸‹é™å‘¨æ³¢æ•° -->
        <div class="res-card">
            <label style="font-size:0.6rem">å°å…¥é¢ç© / æ‹¡æ•£ã‚«ãƒãƒ¬ãƒƒã‚¸</label>
            <div id="totalPanelArea" class="res-val" style="font-size:1.05rem; line-height:1.2;">-</div>
            <div id="diffusionBalance" style="font-size:0.75rem; font-weight:bold; margin-top:4px;">-</div>
            <div id="fgDisplay" style="font-size:0.6rem; color:var(--dim); margin-top:5px; border-top:1px solid var(--border); padding-top:4px;">-</div>
        </div>
    </div>

    <div class="chart-wrapper"><canvas id="rtChart"></canvas></div>

    <div class="footer-note">
        <div id="adviceHeader" class="advice-tag"></div>
        <div id="detailedNote" style="font-size:0.75rem;"></div>
    </div>

    <div id="print-only-notice">
        <strong>ã€ã”æ¡ˆå†…ã€‘</strong><br>
        æœ¬ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³çµæœã¯ã€å…¥åŠ›ã•ã‚ŒãŸæ¡ä»¶ä¸‹ã«ãŠã‘ã‚‹ã‚»ãƒ¼ãƒ“ãƒ³å¼ã«åŸºã¥ã„ãŸè¨ˆç®—ç›®å®‰ã§ã‚ã‚Šã€å®Ÿéš›ã®æ–½å·¥ç¾å ´ã®ç’°å¢ƒï¼ˆå®¶å…·ã®é…ç½®ã€ä¸‹åœ°ã®æ§‹é€ ã€æ¸©æ¹¿åº¦ç­‰ï¼‰ã«ã‚ˆã‚Šå¤‰å‹•ã™ã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚<br>
        ã‚ˆã‚Šé«˜åº¦ãªè©³ç´°è§£æã‚„ã€ãƒ‘ãƒãƒ«ã®å…·ä½“çš„ãªé…ç½®è¨ˆç”»ï¼ˆåå°„éŸ³åˆ†å¸ƒã®æœ€é©åŒ–ãªã©ï¼‰ã‚’ã”å¸Œæœ›ã®å ´åˆã¯ã€<strong>AFMG EASE</strong> ã«ã‚ˆã‚‹ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã€ã¾ãŸã¯å¼Šç¤¾å°‚é–€ã‚¹ã‚¿ãƒƒãƒ•ã¾ã§ãŠå•ã„åˆã‚ã›ãã ã•ã„ã€‚
    </div>
</div>

<script>
// ========================================
// SOUNDBOX_DB (Rev 1.0)
// ã‚µã‚¤ã‚ºå˜ä½: mmçµ±ä¸€
// diffusion ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ä¿æŒï¼ˆå°†æ¥ã®æ•£ä¹±ä¿‚æ•°é…åˆ—ã¸ã®ç§»è¡Œç”¨ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼ï¼‰
// ========================================
const SOUNDBOX_DB = {
    apps: [
        { id: "office",    name: "ã‚ªãƒ•ã‚£ã‚¹ / ä¸€èˆ¬ä¼šè­°å®¤ (0.6s)",          t: 0.6  },
        { id: "web_mtg",   name: "Webä¼šè­°å®¤ / ã‚ªãƒ³ãƒ©ã‚¤ãƒ³MTG (0.4s)",       t: 0.4  },
        { id: "studio",    name: "ãƒ¬ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚¹ã‚¿ã‚¸ã‚ª (0.4s)",           t: 0.4  },
        { id: "audio",     name: "ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªãƒ«ãƒ¼ãƒ  / ãƒ›ãƒ¼ãƒ ã‚·ã‚¢ã‚¿ãƒ¼ (0.45s)",t: 0.45 },
        { id: "living",    name: "ãƒªãƒ“ãƒ³ã‚° / ä¸€èˆ¬ä½å®… (0.5s)",              t: 0.5  },
        { id: "broadcast", name: "é…ä¿¡ã‚¹ã‚¿ã‚¸ã‚ª / ãƒãƒƒãƒ‰ã‚­ãƒ£ã‚¹ãƒˆ (0.35s)",   t: 0.35 },
        { id: "classroom", name: "æ•™å®¤ / ã‚»ãƒŸãƒŠãƒ¼ãƒ«ãƒ¼ãƒ  (0.7s)",            t: 0.7  },
        { id: "hall",      name: "å¤šç›®çš„ãƒ›ãƒ¼ãƒ« / ä½“è‚²é¤¨ (1.2s)",            t: 1.2  }
    ],
    materials: {
        "plasterboard":  { name: "çŸ³è†ãƒœãƒ¼ãƒ‰ + å£ç´™",            data: [0.29, 0.10, 0.05, 0.04, 0.07, 0.09] },
        "concrete":      { name: "ã‚³ãƒ³ã‚¯ãƒªãƒ¼ãƒˆæ‰“æ”¾ã—",            data: [0.01, 0.01, 0.01, 0.02, 0.02, 0.03] },
        "glass":         { name: "ã‚¬ãƒ©ã‚¹çª“ / é¡",                data: [0.35, 0.25, 0.18, 0.12, 0.07, 0.04] },
        "carpet":        { name: "ã‚¿ã‚¤ãƒ«ã‚«ãƒ¼ãƒšãƒƒãƒˆ",              data: [0.02, 0.05, 0.10, 0.20, 0.30, 0.40] },
        "wood":          { name: "ãƒ•ãƒ­ãƒ¼ãƒªãƒ³ã‚° / æœ¨æ¿",           data: [0.15, 0.11, 0.10, 0.07, 0.06, 0.07] },
        "curtain":       { name: "ã‚«ãƒ¼ãƒ†ãƒ³ (é‡ç›®/ãƒ—ãƒªãƒ¼ãƒ„æœ‰)",    data: [0.07, 0.31, 0.49, 0.75, 0.70, 0.60] },
        "gw_insulation": { name: "ã‚°ãƒ©ã‚¹ã‚¦ãƒ¼ãƒ«æ–­ç†±æ (50mm/32k)", data: [0.25, 0.65, 0.95, 0.98, 0.95, 0.90] }
    },
    products: {
        "STANDARD": {
            name: "1. ã‚¹ã‚¿ãƒ³ãƒ€ãƒ¼ãƒ‰ãƒ‘ãƒãƒ« (EQ Series)",
            models: {
                "STD": { n: "EQ Standard", d: { "30": [0.20,0.50,0.95,1.05,1.05,1.00], "60": [0.30,0.80,1.10,1.10,1.00,1.00], "120": [0.50,0.95,1.10,1.05,1.00,0.95] }, s: { "600Ã—600mm": 0.36, "600Ã—1200mm": 0.72 } },
                "R":   { n: "EQ R (Rococo)",  d: { "30": [0.25,0.55,0.98,1.08,1.07,1.02], "60": [0.35,0.85,1.12,1.12,1.02,1.02], "120": [0.55,0.98,1.12,1.08,1.02,0.98] }, s: { "600Ã—600mm": 0.36, "600Ã—1200mm": 0.72 } },
                "B":   { n: "EQ B (Baroque)", d: { "30": [0.22,0.52,0.96,1.06,1.06,1.01], "60": [0.32,0.82,1.11,1.11,1.01,1.01], "120": [0.52,0.96,1.11,1.06,1.01,0.96] }, s: { "600Ã—600mm": 0.36, "600Ã—1200mm": 0.72 } },
                "F":   { n: "EQ Fabric",      d: { "30": [0.18,0.48,0.93,1.03,1.03,0.98], "60": [0.28,0.78,1.08,1.08,0.98,0.98] },                                          s: { "600Ã—600mm": 0.36, "600Ã—1200mm": 0.72 } }
            }
        },
        "OFFICE_FABRIC": {
            name: "2. ã‚ªãƒ•ã‚£ã‚¹ç”¨ãƒ•ã‚¡ãƒ–ãƒªãƒƒã‚¯ (Walleasear)",
            models: {
                "EQ30T":  { n: "EQ 30T (å¤§é¢ç©æ–½å·¥)", d: { "30":  [0.19,0.49,0.94,1.04,1.04,0.99] }, s: { "1200Ã—600mm": 0.72, "2400Ã—600mm": 1.44 } },
                "EQ60T":  { n: "EQ 60T (å¤§é¢ç©æ–½å·¥)", d: { "60":  [0.29,0.79,1.09,1.09,0.99,0.99] }, s: { "1200Ã—600mm": 0.72, "2400Ã—600mm": 1.44 } },
                "EQ100T": { n: "EQ 100T (å¤§é¢ç©æ–½å·¥)",d: { "100": [0.45,0.92,1.10,1.07,1.00,0.96] }, s: { "1200Ã—600mm": 0.72, "2400Ã—600mm": 1.44 } }
            }
        },
        "ENGINEERING": {
            name: "3. ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ãƒªãƒ³ã‚°è£½å“",
            models: {
                "MT_BAFFLE": { n: "MT Baffle (å¤©äº•åŠä¸‹ã’)",      d: { "40": [0.42,0.78,0.95,0.98,0.98,0.96] }, s: { "600Ã—400mm": 0.24, "1200Ã—400mm": 0.48 } },
                "CM":        { n: "CM Series (ã‚¯ãƒ©ã‚¦ãƒ‰/å¤©äº•ç”¨)", d: { "30": [0.21,0.53,0.88,0.96,0.98,0.94], "60": [0.38,0.84,1.05,1.08,1.02,0.98] }, s: { "600Ã—600mm": 0.36 } },
                "IMAGINE":   { n: "Imagine Panel (æ„åŒ ãƒ‘ãƒãƒ«)", d: { "30": [0.17,0.46,0.91,1.02,1.03,0.97] }, s: { "600Ã—600mm": 0.36 } }
            }
        },
        "BROADBAND": {
            name: "4. ãƒ–ãƒ­ãƒ¼ãƒ‰ãƒãƒ³ãƒ‰å¸éŸ³æ",
            models: {
                "F300H": { n: "F300H (é«˜åŸŸç‰¹åŒ–)", d: { "30": [0.10,0.35,0.70,0.95,1.08,1.05] }, s: { "300Ã—300mm": 0.09 } },
                "F300M": { n: "F300M (ä¸­åŸŸç‰¹åŒ–)", d: { "30": [0.15,0.55,0.98,1.05,0.95,0.85] }, s: { "300Ã—300mm": 0.09 } },
                "F300W": { n: "F300W (ä½åŸŸç‰¹åŒ–)", d: { "30": [0.35,0.75,0.95,0.90,0.80,0.70] }, s: { "300Ã—300mm": 0.09 } }
            }
        },
        "BASSTRAP": {
            name: "5. ãƒ™ãƒ¼ã‚¹ãƒˆãƒ©ãƒƒãƒ— (ä½åŸŸåˆ¶å¾¡)",
            models: {
                // C300W: v2å®Ÿæ¸¬å€¤ã«æ›´æ–°ï¼ˆÎ± 125-4kHzï¼‰
                "C300W":      { n: "C300W (ã‚³ãƒ¼ãƒŠãƒ¼ç”¨)",   d: { "300": [0.80,0.95,0.99,0.99,0.98,0.97] }, s: { "ã‚³ãƒ¼ãƒŠãƒ¼è¨­ç½®": null }, sc: [0.05,0.07,0.09,0.10,0.12,0.10], s_est: true },
                // CYLINDER350: v2ã«å¯¾å¿œè£½å“ãªã— â†’ ãƒ•ã‚§ãƒ¼ã‚º3ã§å‰Šé™¤
                "CYLINDER350":{ n: "Cylinder 350 (å††ç­’å‹)", d: { "350": [0.70,0.98,1.08,1.02,0.94,0.88] }, s: { "Ã˜350mm": 0.12 } }
            }
        },
        "DIFFUSION": {
            name: "6. æ‹¡æ•£ãƒ‘ãƒãƒ« (éŸ¿ãã®èª¿æ•´)",
            models: {
                // Cloud-2C: v2_updatedå®Ÿæ¸¬å€¤ã«æ›´æ–°ï¼ˆÎ±ãƒ»dcæ›´æ–°ã€sc=æ¨å®šï¼‰
                "CLOUD2C":  { n: "Cloud-2C (å¤©äº•åŠä¸‹å‹)", d: { "90": [0.33,0.42,0.38,0.35,0.23,0.22] }, s: { "600Ã—600mm": 0.36 }, diffusion: 0.28, sc: [0.15,0.20,0.25,0.28,0.30,0.28], dc: [0.18,0.22,0.28,0.32,0.32,0.30], s_est: true },
                // CLOUD2Dãƒ»PEAK_SQ: v2ã«å¯¾å¿œè£½å“ãªã— â†’ ãƒ•ã‚§ãƒ¼ã‚º3ã§å‰Šé™¤
                "CLOUD2D":  { n: "Cloud 2D (å‡¹å‡¸æ‹¡æ•£)",   d: { "70":  [0.08,0.15,0.22,0.18,0.15,0.12] }, s: { "600Ã—600mm": 0.36 }, diffusion: 0.85 },
                "PEAK_SQ":  { n: "Peak SQ (ã‚¹ã‚«ã‚¤ãƒ©ã‚¤ãƒ³)", d: { "80":  [0.10,0.18,0.25,0.20,0.18,0.15] }, s: { "600Ã—600mm": 0.36 }, diffusion: 0.9  },
                // N29: v2_updatedå®Ÿæ¸¬å€¤ã«æ›´æ–°ï¼ˆÎ±ãƒ»scãƒ»dcå…¨ã¦â—ï¼‰
                "QRD_N29":  { n: "N29 (éå‘¨æœŸQRDå‹)",    d: { "120": [0.08,0.08,0.10,0.12,0.15,0.18] }, s: { "æ¨™æº–": 0.36 },    diffusion: 0.35, sc: [0.00,0.00,0.28,0.52,0.25,1.00], dc: [0.68,0.68,0.98,1.00,0.55,0.65], s_est: false }
            }
        },
        "HYBRID": {
            name: "7. ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰ (å¸éŸ³+æ‹¡æ•£)",
            models: {
                // AQ1000S: v2å®Ÿæ¸¬å€¤ã«æ›´æ–°ï¼ˆÎ±ãƒ»ã‚µã‚¤ã‚ºãƒ»åšã¿ã‚­ãƒ¼ä¿®æ­£ï¼‰
                "AQ1000S": { n: "AQ1000S (æœ¨è£½ã‚¹ãƒ©ãƒƒãƒˆ)", d: { "150": [0.32,0.62,0.80,0.74,0.67,0.62] }, s: { "1600Ã—600mm": 0.96 }, diffusion: 0.53, sc: [0.34,0.44,0.52,0.54,0.54,0.52], s_est: true },
                // WAVE600: v2å®Ÿæ¸¬å€¤ã«æ›´æ–°ï¼ˆÎ±ãƒ»ã‚µã‚¤ã‚ºãƒ»åšã¿ã‚­ãƒ¼ä¿®æ­£ãƒ»dcè¿½åŠ ï¼‰
                "WAVE600": { n: "WAVE600 (ã‚¦ã‚§ãƒ¼ãƒ–å‹)",  d: { "80":  [0.28,0.62,0.88,0.90,0.88,0.85] }, s: { "600Ã—600mm": 0.36, "600Ã—1200mm": 0.72 }, diffusion: 0.35, sc: [0.18,0.25,0.32,0.35,0.38,0.36], dc: [0.22,0.30,0.38,0.40,0.38,0.36], s_est: true },
                // BREEZE: v2ã«å¯¾å¿œè£½å“ãªã— â†’ ãƒ•ã‚§ãƒ¼ã‚º3ã§å‰Šé™¤
                "BREEZE":  { n: "Breeze (æ„åŒ æ€§ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰)", d: { "40": [0.20,0.55,0.88,0.92,0.85,0.78] }, s: { "600Ã—600mm": 0.36 }, diffusion: 0.35 }
            }
        }
    }
};

// æ‹¡æ•£ã‚«ãƒ†ã‚´ãƒªã‚­ãƒ¼ï¼ˆæ‹¡æ•£ã‚«ãƒãƒ¬ãƒƒã‚¸ç‡ã®è¨ˆç®—ã«ä½¿ç”¨ï¼‰
const DIFFUSION_CATS = ['DIFFUSION', 'HYBRID'];

const FREQS = [125, 250, 500, 1000, 2000, 4000];
let chart;
let selectedSpecs = [{}, {}, {}];
let lastData = {};
let currentMode = 'sim';
let measurementData = null;
let roomSizeBuffer = { w: 4.0, d: 6.0, h: 2.6 };
let measurementActive = false;
const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);

const SNR_PROFILES = {
    low: {
        label: 'ä½ï¼ˆå†…è”µãƒ‡ãƒã‚¤ã‚¹å‘ã‘ï¼‰',
        threshold: 8,
        description: 'ã‚¹ãƒãƒ›/PCå†…è”µã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼ãƒ»ãƒã‚¤ã‚¯',
        warning: 'ç²¾åº¦ã¯ä½ä¸‹ã—ã¾ã™ãŒã€ç°¡æ˜“æ¸¬å®šãŒå¯èƒ½ã§ã™',
        skipBands: [0, 1, 2],
        totalBands: 15,
        minValidOctaves: 4
    },
    medium: {
        label: 'ä¸­ï¼ˆBluetooth/å°å‹ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼ï¼‰',
        threshold: 15,
        description: 'Bluetoothã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼ã€å°å‹å¤–éƒ¨ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼',
        warning: 'ä¸€èˆ¬çš„ãªéŸ³éŸ¿æ¸¬å®šã«é©ã—ã¦ã„ã¾ã™',
        skipBands: [],
        totalBands: 18,
        minValidOctaves: 4
    },
    high: {
        label: 'é«˜ï¼ˆISOæº–æ‹ ãƒ»ãƒ—ãƒ­æ¸¬å®šï¼‰',
        threshold: 25,
        description: 'å°‚ç”¨æ¸¬å®šæ©Ÿå™¨ã€å¤§å‹ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼ã‚·ã‚¹ãƒ†ãƒ ',
        warning: 'ISO 3382æº–æ‹ ã®é«˜ç²¾åº¦æ¸¬å®š',
        skipBands: [],
        totalBands: 18,
        minValidOctaves: 5
    }
};

let currentSNRProfile = 'medium';

function init() {
    const appSelect = document.getElementById('appTarget');
    SOUNDBOX_DB.apps.forEach((app, idx) => {
        const option = document.createElement('option');
        option.value = idx;
        option.textContent = app.name;
        appSelect.appendChild(option);
    });

    ['baseWall', 'baseCeiling', 'baseFloor', 'exMat'].forEach(selectId => {
        const select = document.getElementById(selectId);
        for (let key in SOUNDBOX_DB.materials) {
            const option = document.createElement('option');
            option.value = key;
            option.textContent = SOUNDBOX_DB.materials[key].name;
            select.appendChild(option);
        }
    });

    const sbInputsContainer = document.getElementById('sbInputs');
    sbInputsContainer.innerHTML = '';
    for (let i = 0; i < 3; i++) {
        const row = document.createElement('div');
        row.className = 'grid-row';
        row.innerHTML = `
            <div><label>ã‚«ãƒ†ã‚´ãƒªãƒ¼</label><select id="cat_${i}" onchange="onCategoryChange(${i})"></select></div>
            <div class="custom-select-container">
                <div class="custom-select-trigger" id="trigger_${i}" onclick="togglePanel(${i})">è£½å“ã‚¹ãƒšãƒƒã‚¯ã‚’é¸æŠ...</div>
                <div class="sub-panel" id="panel_${i}">
                    <div class="panel-cols">
                        <div id="col_model_${i}"></div>
                        <div id="col_thick_${i}"></div>
                        <div id="col_size_${i}"></div>
                    </div>
                </div>
            </div>
            <input type="number" id="qty_${i}" value="0" min="0" step="1" oninput="calculate()">
            <div id="unitArea_${i}" style="font-size:0.65rem; color:var(--dim); text-align:center;">-</div>
            <div id="totalArea_${i}" style="font-size:0.7rem; color:var(--primary); text-align:right; font-weight:bold;">-</div>
        `;
        sbInputsContainer.appendChild(row);

        const catSelect = document.getElementById(`cat_${i}`);
        const defaultOption = document.createElement('option');
        defaultOption.value = '';
        defaultOption.textContent = 'é¸æŠã—ã¦ãã ã•ã„...';
        catSelect.appendChild(defaultOption);
        for (let catKey in SOUNDBOX_DB.products) {
            const option = document.createElement('option');
            option.value = catKey;
            option.textContent = SOUNDBOX_DB.products[catKey].name;
            catSelect.appendChild(option);
        }
    }

    document.getElementById('appTarget').addEventListener('change', calculate);
    document.getElementById('w').addEventListener('input', calculate);
    document.getElementById('d').addEventListener('input', calculate);
    document.getElementById('h').addEventListener('input', calculate);
    document.getElementById('baseWall').addEventListener('change', calculate);
    document.getElementById('baseCeiling').addEventListener('change', calculate);
    document.getElementById('baseFloor').addEventListener('change', calculate);
    document.getElementById('exArea').addEventListener('input', calculate);
    document.getElementById('exMat').addEventListener('change', calculate);
    document.getElementById('showSpecial').addEventListener('change', function() {
        document.getElementById('specialPanel').style.display = this.checked ? 'block' : 'none';
        calculate();
    });
    calculate();
}

function saveRoomSizeToBuffer() {
    roomSizeBuffer.w = parseFloat(document.getElementById('w').value);
    roomSizeBuffer.d = parseFloat(document.getElementById('d').value);
    roomSizeBuffer.h = parseFloat(document.getElementById('h').value);
}
function restoreRoomSizeFromBuffer() {
    document.getElementById('w').value = roomSizeBuffer.w;
    document.getElementById('d').value = roomSizeBuffer.d;
    document.getElementById('h').value = roomSizeBuffer.h;
}
function disableRoomSizeInputs() {
    document.getElementById('w').disabled = true;
    document.getElementById('d').disabled = true;
    document.getElementById('h').disabled = true;
}
function enableRoomSizeInputs() {
    document.getElementById('w').disabled = false;
    document.getElementById('d').disabled = false;
    document.getElementById('h').disabled = false;
}

function updateSNRProfileInfo() {
    const select  = document.getElementById('snrProfile');
    const info    = document.getElementById('snrProfileInfo');
    const key     = select.value;
    const profile = SNR_PROFILES[key];
    if (profile) {
        const skipNote = profile.skipBands.length > 0
            ? '100ã€œ160Hz ã¯æ¸¬å®šå¯¾è±¡å¤–ï¼ˆå†…è”µSPç‰©ç†é™ç•Œï¼‰'
            : 'å…¨18ãƒãƒ³ãƒ‰ï¼ˆ100Hzã€œ5kHzï¼‰ã‚’æ¸¬å®š';
        info.innerHTML = profile.description + '<br>' + 'SNRé–¾å€¤: ' + profile.threshold + 'dB &nbsp; ' + skipNote + '<br>' + profile.warning;
        currentSNRProfile = key;
    }
}

function setMode(mode) {
    currentMode = mode;
    const btnSim     = document.getElementById('btnSim');
    const btnMeasure = document.getElementById('btnMeasure');
    if (mode === 'sim') {
        btnSim.classList.add('active');
        btnSim.classList.remove('measure');
        btnMeasure.classList.remove('active', 'measure');
        document.getElementById('measurementPanel').style.display = 'none';
        enableRoomSizeInputs();
        if (measurementActive) restoreRoomSizeFromBuffer();
        measurementActive = false;
    } else {
        btnSim.classList.remove('active');
        btnMeasure.classList.add('active', 'measure');
        document.getElementById('measurementPanel').style.display = 'block';
        enumerateDevices();
        if (measurementData && measurementData.length > 0) {
            disableRoomSizeInputs();
            measurementActive = true;
        } else {
            enableRoomSizeInputs();
            measurementActive = false;
        }
    }
    const methodBadge = document.getElementById('methodBadge');
    if (mode === 'sim') {
        methodBadge.textContent = 'SABINE';
        methodBadge.style.background = 'var(--accent)';
    } else if (window._measurementMethod) {
        methodBadge.textContent = window._measurementMethod;
        const mc = { 'T60': 'var(--success)', 'T30': 'var(--warning)', 'T20': 'var(--caution)' };
        methodBadge.style.background = mc[window._measurementMethod] || 'var(--warning)';
    } else {
        methodBadge.textContent = 'EYRING';
        methodBadge.style.background = 'var(--warning)';
    }
    calculate();
}

async function enumerateDevices() {
    const statusEl = document.getElementById('measureStatus');
    const micSelect = document.getElementById('micSelect');
    const spkSelect = document.getElementById('spkSelect');
    try {
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia)
            throw new Error('ã“ã®ãƒ–ãƒ©ã‚¦ã‚¶ã¯éŸ³å£°å…¥åŠ›ã«å¯¾å¿œã—ã¦ã„ã¾ã›ã‚“ã€‚Chrome/Edge/Firefoxã‚’ã”åˆ©ç”¨ãã ã•ã„ã€‚');
        if (location.protocol !== 'https:' && location.hostname !== 'localhost')
            throw new Error('ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ä¸Šã®ç†ç”±ã«ã‚ˆã‚Šã€HTTPSãƒšãƒ¼ã‚¸ã§ã®ã¿å‹•ä½œã—ã¾ã™ã€‚');
        statusEl.textContent = 'ãƒã‚¤ã‚¯ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹æ¨©é™ã‚’ãƒªã‚¯ã‚¨ã‚¹ãƒˆä¸­...';
        statusEl.className = 'status-msg calibrating';
        let stream;
        try {
            stream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false } });
        } catch (permError) {
            if (permError.name === 'NotAllowedError') throw new Error('ãƒã‚¤ã‚¯ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ãŒæ‹’å¦ã•ã‚Œã¾ã—ãŸã€‚ãƒ–ãƒ©ã‚¦ã‚¶ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ãƒãƒ¼æ¨ªã®ã‚¢ã‚¤ã‚³ãƒ³ã‹ã‚‰ãƒã‚¤ã‚¯ã‚’è¨±å¯ã—ã¦ãã ã•ã„ã€‚');
            else if (permError.name === 'NotFoundError') throw new Error('ãƒã‚¤ã‚¯ãƒ‡ãƒã‚¤ã‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚ãƒã‚¤ã‚¯ãŒæ¥ç¶šã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèªã—ã¦ãã ã•ã„ã€‚');
            else throw new Error('ãƒã‚¤ã‚¯ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + permError.message);
        }
        statusEl.textContent = 'ãƒ‡ãƒã‚¤ã‚¹ã‚’æ¤œç´¢ä¸­...';
        await new Promise(resolve => setTimeout(resolve, 300));
        const devices = await navigator.mediaDevices.enumerateDevices();
        if (stream) stream.getTracks().forEach(track => track.stop());
        const canSetSink = 'setSinkId' in HTMLAudioElement.prototype;
        micSelect.innerHTML = '<option value="">ãƒ‡ãƒã‚¤ã‚¹ã‚’é¸æŠ...</option>';
        spkSelect.innerHTML = '<option value="">(æ—¢å®šã®å‡ºåŠ›)</option>';
        let micCount = 0, spkCount = 0;
        devices.forEach(device => {
            const option = document.createElement('option');
            option.value = device.deviceId;
            option.textContent = device.label || `${device.kind === 'audioinput' ? 'ãƒã‚¤ã‚¯' : 'ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼'} (${device.deviceId.substr(0, 8)}...)`;
            if (device.kind === 'audioinput') { micSelect.appendChild(option); micCount++; }
            else if (device.kind === 'audiooutput') {
                if (!canSetSink) { option.disabled = true; option.textContent += ' (éå¯¾å¿œ)'; }
                spkSelect.appendChild(option); spkCount++;
            }
        });
        if (micCount > 0) {
            let message = `âœ… ãƒ‡ãƒã‚¤ã‚¹æ¤œå‡ºå®Œäº†: ãƒã‚¤ã‚¯ ${micCount}å°ã€ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼ ${spkCount}å°`;
            if (!canSetSink) message += '\nâš ï¸ ã“ã®ãƒ–ãƒ©ã‚¦ã‚¶ã¯ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼é¸æŠã«éå¯¾å¿œã§ã™ã€‚ã‚·ã‚¹ãƒ†ãƒ è¨­å®šã®æ—¢å®šãƒ‡ãƒã‚¤ã‚¹ãŒä½¿ç”¨ã•ã‚Œã¾ã™ã€‚';
            statusEl.textContent = message;
            statusEl.className = 'status-msg ready';
            if (micSelect.options.length > 1) micSelect.selectedIndex = 1;
            if (spkSelect.options.length > 1 && canSetSink) spkSelect.selectedIndex = 1;
        } else {
            statusEl.textContent = 'âš ï¸ ãƒã‚¤ã‚¯ãƒ‡ãƒã‚¤ã‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚ãƒã‚¤ã‚¯ãŒæ¥ç¶šã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèªã—ã¦ãã ã•ã„ã€‚';
            statusEl.className = 'status-msg error';
        }
    } catch (error) {
        statusEl.textContent = 'âŒ ' + (error.message || 'ãƒ‡ãƒã‚¤ã‚¹ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ');
        statusEl.className = 'status-msg error';
        micSelect.innerHTML = '<option value="">ãƒ‡ãƒã‚¤ã‚¹ã‚’é¸æŠ...</option>';
        spkSelect.innerHTML = '<option value="">ãƒ‡ãƒã‚¤ã‚¹ã‚’é¸æŠ...</option>';
    }
}

function onCategoryChange(index) {
    selectedSpecs[index] = {};
    document.getElementById(`trigger_${index}`).textContent = 'è£½å“ã‚¹ãƒšãƒƒã‚¯ã‚’é¸æŠ...';
    document.getElementById(`panel_${index}`).classList.remove('active');
    document.getElementById(`unitArea_${index}`).textContent = '-';
    document.getElementById(`totalArea_${index}`).textContent = '-';
    renderPanel(index);
    calculate();
}

function togglePanel(index) {
    const panel = document.getElementById(`panel_${index}`);
    const isActive = panel.classList.contains('active');
    document.querySelectorAll('.sub-panel').forEach(p => p.classList.remove('active'));
    if (!isActive) { panel.classList.add('active'); renderPanel(index); }
}

function renderPanel(index) {
    const categoryKey = document.getElementById(`cat_${index}`).value;
    if (!categoryKey) {
        document.getElementById(`col_model_${index}`).innerHTML = '<div class="col-title">MODEL</div>';
        document.getElementById(`col_thick_${index}`).innerHTML = '<div class="col-title">THICKNESS</div>';
        document.getElementById(`col_size_${index}`).innerHTML  = '<div class="col-title">SIZE</div>';
        return;
    }
    const category = SOUNDBOX_DB.products[categoryKey];
    const spec = selectedSpecs[index];

    const modelCol = document.getElementById(`col_model_${index}`);
    modelCol.innerHTML = '<div class="col-title">MODEL</div>';
    for (let modelKey in category.models) {
        const modelDiv = document.createElement('div');
        modelDiv.className = 'col-item' + (spec.model === modelKey ? ' selected' : '');
        modelDiv.textContent = category.models[modelKey].n;
        modelDiv.onclick = () => selectModel(index, categoryKey, modelKey);
        modelCol.appendChild(modelDiv);
    }

    const thickCol = document.getElementById(`col_thick_${index}`);
    thickCol.innerHTML = '<div class="col-title">THICKNESS</div>';
    if (spec.model) {
        const model = category.models[spec.model];
        for (let thickKey in model.d) {
            const thickDiv = document.createElement('div');
            thickDiv.className = 'col-item' + (spec.thick === thickKey ? ' selected' : '');
            thickDiv.textContent = thickKey + 'mm';
            thickDiv.onclick = () => selectThickness(index, categoryKey, spec.model, thickKey);
            thickCol.appendChild(thickDiv);
        }
    }

    const sizeCol = document.getElementById(`col_size_${index}`);
    sizeCol.innerHTML = '<div class="col-title">SIZE</div>';
    if (spec.model && spec.thick) {
        const model = category.models[spec.model];
        for (let sizeKey in model.s) {
            const sizeDiv = document.createElement('div');
            sizeDiv.className = 'col-item' + (spec.size === sizeKey ? ' selected' : '');
            sizeDiv.textContent = sizeKey;
            sizeDiv.onclick = () => selectSize(index, categoryKey, spec.model, spec.thick, sizeKey);
            sizeCol.appendChild(sizeDiv);
        }
    }
}

function selectModel(index, categoryKey, modelKey) {
    selectedSpecs[index] = { category: categoryKey, model: modelKey };
    renderPanel(index);
}
function selectThickness(index, categoryKey, modelKey, thickKey) {
    selectedSpecs[index].thick = thickKey;
    renderPanel(index);
}
function selectSize(index, categoryKey, modelKey, thickKey, sizeKey) {
    selectedSpecs[index].size = sizeKey;
    const model = SOUNDBOX_DB.products[categoryKey].models[modelKey];
    document.getElementById(`trigger_${index}`).textContent = `${model.n} / ${thickKey}mm / ${sizeKey}`;
    document.getElementById(`unitArea_${index}`).textContent = model.s[sizeKey].toFixed(2) + 'ã¡';
    document.getElementById(`panel_${index}`).classList.remove('active');
    calculate();
}

function prepareForPrint() { window.print(); }

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// calculate() â€” Rev 1.0
// è¿½åŠ : Schroeder fgè¨ˆç®— / æ‹¡æ•£ã‚«ãƒãƒ¬ãƒƒã‚¸ç‡ï¼ˆDIFFUSION+HYBRIDã‚«ãƒ†ã‚´ãƒªåˆ†é›¢ï¼‰
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function calculate() {
    const w = parseFloat(document.getElementById('w').value) || 0.1;
    const d = parseFloat(document.getElementById('d').value) || 0.1;
    const h = parseFloat(document.getElementById('h').value) || 0.1;
    const V       = w * d * h;
    const S_total = 2 * (w * d + d * h + h * w);
    const S_wall  = 2 * (d * h + h * w);
    const S_ceiling = w * d;
    const S_floor   = w * d;
    if (V <= 0 || S_total <= 0) return;

    const L_mean = (4 * V) / S_total;
    const diffusionIndicator = (L_mean * 0.12).toFixed(2); // ä¿æŒï¼ˆå°†æ¥ç”¨ï¼‰

    const appIndex = parseInt(document.getElementById('appTarget').value) || 0;
    const targetObj = SOUNDBOX_DB.apps[appIndex];
    const targetRT  = targetObj.t;

    const wallMat    = SOUNDBOX_DB.materials[document.getElementById('baseWall').value];
    const ceilingMat = SOUNDBOX_DB.materials[document.getElementById('baseCeiling').value];
    const floorMat   = SOUNDBOX_DB.materials[document.getElementById('baseFloor').value];

    let exArea = 0, exMat = null;
    if (document.getElementById('showSpecial').checked) {
        exArea = parseFloat(document.getElementById('exArea').value) || 0;
        exMat  = SOUNDBOX_DB.materials[document.getElementById('exMat').value];
    }

    const actualWallArea = Math.max(0, S_wall - exArea);
    const rt_before = [], rt_after = [];
    const m_coeffs = [0, 0, 0, 0, 0.002, 0.007];

    for (let i = 0; i < 6; i++) {
        let A_base = actualWallArea * wallMat.data[i]
                   + S_ceiling * ceilingMat.data[i]
                   + S_floor   * floorMat.data[i];
        if (exArea > 0 && exMat) A_base += exArea * exMat.data[i];
        const airAbsorption = 4 * m_coeffs[i] * V;

        let rt_b;
        if (currentMode === 'measure' && measurementData) {
            if (measurementData[i] !== null && measurementData[i] !== undefined) {
                rt_b = measurementData[i];
            } else {
                rt_before.push(null);
                rt_after.push(null);
                continue;
            }
        } else {
            rt_b = (0.161 * V) / (A_base + airAbsorption);
        }
        rt_before.push(rt_b);

        let A_panels = 0;
        for (let panelIdx = 0; panelIdx < 3; panelIdx++) {
            const spec = selectedSpecs[panelIdx];
            const qty  = parseInt(document.getElementById(`qty_${panelIdx}`).value) || 0;
            if (spec.category && spec.model && spec.thick && spec.size && qty > 0) {
                const product = SOUNDBOX_DB.products[spec.category].models[spec.model];
                A_panels += product.s[spec.size] * qty * (product.d[spec.thick][i] - wallMat.data[i]);
            }
        }

        let rt_a;
        if (currentMode === 'measure' && measurementData && measurementData[i] !== null && measurementData[i] !== undefined) {
            const A_current    = (0.161 * V) / rt_b - airAbsorption;
            const A_after      = A_current + A_panels;
            const avgAlpha_after = Math.min((A_after + airAbsorption) / S_total, 0.999);
            rt_a = (0.161 * V) / (-S_total * Math.log(1 - avgAlpha_after) + airAbsorption);
            rt_a = Math.max(0.1, rt_a);
        } else {
            const A_total = A_base + A_panels + airAbsorption;
            rt_a = (0.161 * V) / A_total;
        }
        rt_after.push(rt_a);
    }

    const validAfterVals  = rt_after.filter(v => v !== null);
    const validBeforeVals = rt_before.filter(v => v !== null);
    const avgRT_after  = validAfterVals.length  > 0 ? validAfterVals.reduce((s,v)=>s+v,0)  / validAfterVals.length  : 0;
    const avgRT_before = validBeforeVals.length > 0 ? validBeforeVals.reduce((s,v)=>s+v,0) / validBeforeVals.length : 0;

    const measuredBandCount = (currentMode === 'measure' && measurementData)
        ? measurementData.filter(v => v !== null).length : null;

    // â”€â”€ ãƒ‘ãƒãƒ«é¢ç©é›†è¨ˆï¼ˆå¸éŸ³ / æ‹¡æ•£ åˆ†é›¢ï¼‰+ scåŠ é‡å¹³å‡è¨ˆç®— â”€â”€
    let totalPanelM2     = 0;
    let diffusionPanelM2 = 0;

    // scåŠ é‡å¹³å‡: scãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’æŒã¤ãƒ‘ãƒãƒ«ã®ã¿å¯¾è±¡ï¼ˆ6ãƒãƒ³ãƒ‰ï¼‰
    const BANDS = 6;
    const scWeightedSum = new Array(BANDS).fill(0);
    let   scTotalM2     = 0;

    for (let panelIdx = 0; panelIdx < 3; panelIdx++) {
        const spec = selectedSpecs[panelIdx];
        const qty  = parseInt(document.getElementById(`qty_${panelIdx}`).value) || 0;
        if (spec.category && spec.model && spec.size && qty > 0) {
            const model    = SOUNDBOX_DB.products[spec.category].models[spec.model];
            const unitArea = model.s[spec.size];
            const panelM2  = unitArea * qty;
            totalPanelM2 += panelM2;
            if (DIFFUSION_CATS.includes(spec.category)) {
                diffusionPanelM2 += panelM2;
            }
            // scé…åˆ—ã‚’æŒã¤è£½å“ã®ã¿æ•£ä¹±ä¿‚æ•°é›†è¨ˆ
            if (model.sc && Array.isArray(model.sc) && unitArea > 0) {
                for (let b = 0; b < BANDS; b++) {
                    scWeightedSum[b] += (model.sc[b] || 0) * panelM2;
                }
                scTotalM2 += panelM2;
            }
            document.getElementById(`totalArea_${panelIdx}`).textContent = panelM2.toFixed(2) + 'ã¡';
        } else {
            document.getElementById(`totalArea_${panelIdx}`).textContent = '-';
        }
    }

    // scåŠ é‡å¹³å‡é…åˆ—ï¼ˆscãƒ‘ãƒãƒ«ãŒ1æšã‚‚ãªã‘ã‚Œã°nullï¼‰
    const scAvg = scTotalM2 > 0
        ? scWeightedSum.map(v => Math.round(v / scTotalM2 * 100) / 100)
        : null;

    const usableSurface = S_wall * 0.8;

    // â”€â”€ Schroederå‘¨æ³¢æ•°è¨ˆç®— â”€â”€
    // fg = 2000 Ã— âˆš(T60 / V)  [Hz]
    // æ¸¬å®šãƒ¢ãƒ¼ãƒ‰ã§ã¯æ¸¬å®šRT60ã®å¹³å‡å€¤ã‚’ä½¿ç”¨
    const fg = (avgRT_after > 0 && V > 0)
        ? Math.round(2000 * Math.sqrt(avgRT_after / V))
        : null;

    // â”€â”€ æ‹¡æ•£ã‚«ãƒãƒ¬ãƒƒã‚¸ç‡ â”€â”€
    const diffCoverageRate = usableSurface > 0 ? (diffusionPanelM2 / usableSurface) * 100 : 0;

    const achievementRate = avgRT_after > 0 ? (targetRT / avgRT_after) * 100 : 0;

    updateUI(rt_before, rt_after, avgRT_before, avgRT_after, targetRT, targetObj,
             achievementRate, totalPanelM2, usableSurface, V,
             diffusionIndicator, measuredBandCount, fg, diffCoverageRate, scAvg);
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// updateUI() â€” Rev 1.0
// Bæ¡ˆ: ã‚«ãƒ¼ãƒ‰ã¯ãƒ‘ãƒ¼ã‚»ãƒ³ãƒ†ãƒ¼ã‚¸ã®ã¿ãƒ»åˆ¤å®šã¯ãƒ•ãƒƒã‚¿ãƒ¼ã¸ / æœ‰åŠ¹ä¸‹é™å‘¨æ³¢æ•°è¡¨è¨˜
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function updateUI(rt_before, rt_after, avgBefore, avgAfter, targetRT, targetObj,
                  achievementRate, totalPanelM2, usableSurface, V,
                  diffusionIndicator, measuredBandCount, fg, diffCoverageRate, scAvg) {

    // â”€â”€ å¹³å‡RT60è¡¨ç¤º â”€â”€
    const has500 = measurementData && measurementData[2] !== null;
    const has1k  = measurementData && measurementData[3] !== null;
    const coreAvailable = currentMode !== 'measure' || (has500 || has1k);
    let avgLabel = '', bandInfoLabel = '';
    if (!coreAvailable) {
        avgLabel = 'N/A';
    } else if (measuredBandCount !== null) {
        avgLabel = avgAfter.toFixed(2) + 's';
        bandInfoLabel = 'Measured: ' + measuredBandCount + ' / 6';
    } else {
        avgLabel = avgAfter.toFixed(2) + 's';
    }
    document.getElementById('postRT_Avg').textContent = avgLabel;
    const _bandInfoEl = document.getElementById('measuredBandInfo');
    if (_bandInfoEl) _bandInfoEl.textContent = bandInfoLabel;
    document.getElementById('targetLabel').textContent = `ç›®æ¨™: ${targetRT}s`;
    document.getElementById('achievementRate').textContent = achievementRate.toFixed(0) + '%';
    document.getElementById('totalPanelArea').textContent  = `${totalPanelM2.toFixed(1)} / ${usableSurface.toFixed(1)}ã¡`;

    // â”€â”€ 3æšç›®ã‚«ãƒ¼ãƒ‰: æ‹¡æ•£ã‚«ãƒãƒ¬ãƒƒã‚¸ç‡ï¼ˆBæ¡ˆ: %ã®ã¿è¡¨ç¤ºãƒ»åˆ¤å®šã¯ãƒ•ãƒƒã‚¿ãƒ¼ã¸ï¼‰â”€â”€
    const hasDiffusionPanels = diffCoverageRate > 0;
    if (hasDiffusionPanels) {
        let coverageColor;
        if      (diffCoverageRate >= 30) coverageColor = 'var(--success)';
        else if (diffCoverageRate >= 15) coverageColor = 'var(--warning)';
        else                             coverageColor = 'var(--caution)';
        document.getElementById('diffusionBalance').innerHTML =
            `æ‹¡æ•£ã‚«ãƒãƒ¬ãƒƒã‚¸: <span style="color:${coverageColor}; font-weight:bold;">${diffCoverageRate.toFixed(0)}%</span>`;
    } else {
        document.getElementById('diffusionBalance').innerHTML =
            `<span style="color:var(--dim);">æ‹¡æ•£ã‚«ãƒãƒ¬ãƒƒã‚¸: â€”</span>`;
    }

    // â”€â”€ 3æšç›®ã‚«ãƒ¼ãƒ‰: æœ‰åŠ¹ä¸‹é™å‘¨æ³¢æ•°ï¼ˆæ—§ç§° Schroeder fgï¼‰â”€â”€
    let fgColor = 'var(--dim)', fgLabel = '';
    if (fg !== null) {
        if (fg < 300)      { fgColor = 'var(--success)'; fgLabel = 'ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ æœ‰åŠ¹åŸŸ'; }
        else if (fg < 500) { fgColor = 'var(--warning)'; fgLabel = 'å¢ƒç•ŒåŸŸ'; }
        else               { fgColor = 'var(--caution)'; fgLabel = 'å°éƒ¨å±‹ æ³¨æ„'; }
        document.getElementById('fgDisplay').innerHTML =
            `<span style="color:var(--dim);">æœ‰åŠ¹ä¸‹é™å‘¨æ³¢æ•°: </span><span style="color:${fgColor}; font-weight:bold;">${fg}Hz</span>` +
            ` <span style="color:${fgColor}; font-size:0.58rem;">${fgLabel}</span>`;
    } else {
        document.getElementById('fgDisplay').textContent = '';
    }

    // â”€â”€ å®Ÿç”¨æ€§è©•ä¾¡ã‚«ãƒ¼ãƒ‰ â”€â”€
    const cardHealth  = document.getElementById('cardHealth');
    const healthStatus = document.getElementById('healthStatus');
    const adviceHeader = document.getElementById('adviceHeader');
    const detailedNote = document.getElementById('detailedNote');

    let status, statusColor, adviceTagColor, adviceText, score;

    if (totalPanelM2 > usableSurface) {
        // è¨­ç½®é™ç•Œè¶…é
        status = 'è¨­ç½®é™ç•Œè¶…é'; statusColor = 'var(--danger)'; adviceTagColor = '#ff7b72'; score = -1;
        adviceHeader.textContent = 'FAIL'; adviceHeader.style.background = adviceTagColor;
        adviceText = `å£é¢ã®æœ‰åŠ¹é¢ç©ï¼ˆ80%ï¼‰ã‚’è¶…ãˆã‚‹ãƒ‘ãƒãƒ«ãŒé…ç½®ã•ã‚Œã¦ã„ã¾ã™ã€‚ãƒ‘ãƒãƒ«æšæ•°ã‚’æ¸›ã‚‰ã™ã‹ã€ã‚ˆã‚Šåšå‹ã®ãƒ‘ãƒãƒ«ã¸ã®å¤‰æ›´ã‚’æ¤œè¨ã—ã¦ãã ã•ã„ã€‚`;
    } else if (achievementRate >= 120) {
        // OVERï¼ˆãƒ‡ãƒƒãƒ‰ï¼‰
        status = 'éŸ¿ããŒå°‘ãªã„'; statusColor = 'var(--caution)'; adviceTagColor = '#f0883e'; score = 120;
        adviceHeader.textContent = 'OVER'; adviceHeader.style.background = adviceTagColor;
        adviceText = 'ç©ºé–“ãŒãƒ‡ãƒƒãƒ‰éãã‚‹å‚¾å‘ã«ã‚ã‚Šã¾ã™ã€‚';
        if (!hasDiffusionPanels) {
            adviceText += 'å¸éŸ³ãƒ‘ãƒãƒ«ã®ã•ã‚‰ãªã‚‹è¿½åŠ ã‚ˆã‚Šã€<strong>æ‹¡æ•£ãƒ‘ãƒãƒ«ã®å°å…¥</strong>ã‚’å„ªå…ˆã—ã¦æ¤œè¨ã—ã¦ãã ã•ã„ã€‚';
        } else if (diffCoverageRate < 15) {
            adviceText += 'å¸éŸ³ãƒ‘ãƒãƒ«ã®è¿½åŠ ã‚ˆã‚Šã‚‚<strong>æ‹¡æ•£ãƒ‘ãƒãƒ«ã‚’å„ªå…ˆã—ã¦è¿½åŠ </strong>ã—ã¦ãã ã•ã„ï¼ˆç¾åœ¨ã®æ‹¡æ•£ã‚«ãƒãƒ¬ãƒƒã‚¸: ' + diffCoverageRate.toFixed(0) + '%ï¼‰ã€‚';
        } else if (diffCoverageRate < 30) {
            adviceText += 'æ‹¡æ•£ãƒ‘ãƒãƒ«ã‚’ã•ã‚‰ã«è¿½åŠ ã—ã¦éŸ³å ´ã®å‡ä¸€æ€§ã‚’é«˜ã‚ã‚‹ã“ã¨ã‚’æ¨å¥¨ã—ã¾ã™ï¼ˆç¾åœ¨: ' + diffCoverageRate.toFixed(0) + '%ã€ç›®æ¨™: 30%ä»¥ä¸Šï¼‰ã€‚';
        } else {
            adviceText += 'æ‹¡æ•£ã‚«ãƒãƒ¬ãƒƒã‚¸ã¯ååˆ†ã§ã™ï¼ˆ' + diffCoverageRate.toFixed(0) + '%ï¼‰ã€‚é…ç½®ãƒãƒ©ãƒ³ã‚¹ã®è¦‹ç›´ã—ã‚’æ¤œè¨ã—ã¦ãã ã•ã„ã€‚';
        }
    } else if (achievementRate >= 100) {
        // IDEAL
        status = 'ç†æƒ³çš„'; statusColor = 'var(--success)'; adviceTagColor = '#39d353'; score = 100;
        adviceHeader.textContent = 'IDEAL'; adviceHeader.style.background = adviceTagColor;
        adviceText = 'ç›®æ¨™ã®æ®‹éŸ¿æ™‚é–“ã‚’é”æˆã—ã¦ã„ã¾ã™ã€‚';
        if (hasDiffusionPanels && diffCoverageRate < 15) {
            adviceText += '<br><br><strong style="color:var(--accent);">ğŸ’¡ æ‹¡æ•£æ”¹å–„ã®ä½™åœ°ã‚ã‚Š</strong><br>æ®‹éŸ¿æ™‚é–“ã¯é©åˆ‡ã§ã™ãŒã€æ‹¡æ•£é¢ãŒä¸è¶³ã—ã¦ã„ã¾ã™ï¼ˆ' + diffCoverageRate.toFixed(0) + '%ï¼‰ã€‚æ‹¡æ•£ãƒ‘ãƒãƒ«ã®è¿½åŠ ã§éŸ³å ´ã®å‡ä¸€æ€§ãŒå‘ä¸Šã—ã¾ã™ã€‚';
        } else if (!hasDiffusionPanels) {
            adviceText += '<br><br><strong style="color:var(--accent);">ğŸ’¡ æ‹¡æ•£ãƒ‘ãƒãƒ«ã‚‚æ¤œè¨ã—ã¦ã¿ã¦ãã ã•ã„</strong><br>æ®‹éŸ¿æ™‚é–“ã¯é”æˆæ¸ˆã¿ã§ã™ã€‚æ‹¡æ•£ãƒ‘ãƒãƒ«ã‚’è¿½åŠ ã™ã‚‹ã“ã¨ã§ã€ã‚ˆã‚Šå‡ä¸€ãªéŸ³å ´ã‚’å®Ÿç¾ã§ãã¾ã™ã€‚';
        }
    } else if (achievementRate >= 80) {
        // GOOD
        status = 'å®Ÿç”¨ãƒ¬ãƒ™ãƒ«'; statusColor = 'var(--accent)'; adviceTagColor = '#388bfd'; score = 80;
        adviceHeader.textContent = 'GOOD'; adviceHeader.style.background = adviceTagColor;
        adviceText = 'å®Ÿç”¨ä¸Šååˆ†ãªå°å…¥åŠ¹æœã§ã™ã€‚ä½åŸŸã®åˆ¶å¾¡ã«ã¯åšå‹ã‚’æ¤œè¨ã—ã¦ãã ã•ã„ã€‚';
        if (hasDiffusionPanels && diffCoverageRate < 15) {
            adviceText += '<br><br><strong style="color:var(--accent);">ğŸ’¡ æ‹¡æ•£æ”¹å–„ã®ä½™åœ°ã‚ã‚Š</strong><br>æ‹¡æ•£ãƒ‘ãƒãƒ«ã®è¿½åŠ ï¼ˆç›®æ¨™: 30%ä»¥ä¸Šï¼‰ã§éŸ³å ´å“è³ªã‚’ã•ã‚‰ã«å‘ä¸Šã§ãã¾ã™ï¼ˆç¾åœ¨: ' + diffCoverageRate.toFixed(0) + '%ï¼‰ã€‚';
        }
    } else {
        // UNDERï¼ˆå¸éŸ³ä¸è¶³ï¼‰
        status = 'å¸éŸ³ä¸è¶³'; statusColor = 'var(--danger)'; adviceTagColor = '#ff7b72'; score = 0;
        adviceHeader.textContent = 'UNDER'; adviceHeader.style.background = adviceTagColor;
        adviceText = 'ç›®æ¨™æ®‹éŸ¿æ™‚é–“ã«é”ã—ã¦ã„ã¾ã›ã‚“ã€‚å¸éŸ³ãƒ‘ãƒãƒ«ã®å¢—è¨­ã‚’æ¨å¥¨ã—ã¾ã™ã€‚';
    }

    healthStatus.textContent   = status;
    healthStatus.style.color   = statusColor;
    cardHealth.style.borderColor = statusColor;

    // â”€â”€ æœ‰åŠ¹ä¸‹é™å‘¨æ³¢æ•°ã‚¢ãƒ‰ãƒã‚¤ã‚¹ â”€â”€
    if (fg !== null) {
        if (fg > 500) {
            adviceText += '<br><br><strong style="color:var(--caution);">âš ï¸ æœ‰åŠ¹ä¸‹é™å‘¨æ³¢æ•°: ' + fg + 'Hzï¼ˆå°éƒ¨å±‹ï¼‰</strong><br>'
                + fg + 'Hzä»¥ä¸‹ã®å¸¯åŸŸã¯å®šåœ¨æ³¢ãŒæ”¯é…çš„ã¨ãªã‚Šã€ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ç²¾åº¦ãŒä½ä¸‹ã—ã¾ã™ã€‚ä½åŸŸã®ã‚¨ãƒãƒ«ã‚®ãƒ¼åˆ¶å¾¡ã«ã¯ã‚³ãƒ¼ãƒŠãƒ¼ã¸ã®ãƒ™ãƒ¼ã‚¹ãƒˆãƒ©ãƒƒãƒ—é…ç½®ã‚’å„ªå…ˆã—ã¦ãã ã•ã„ã€‚';
        } else if (fg > 300) {
            adviceText += '<br><br><span style="color:var(--dim); font-size:0.7rem;">æœ‰åŠ¹ä¸‹é™å‘¨æ³¢æ•°: ' + fg + 'Hzï¼ˆå¢ƒç•ŒåŸŸï¼‰â€” '
                + fg + 'Hzä»¥ä¸Šã§ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³çµæœã®ä¿¡é ¼æ€§ãŒé«˜ããªã‚Šã¾ã™ã€‚</span>';
        }
    }

    // â”€â”€ å°éƒ¨å±‹ãƒ»ä½åŸŸè­¦å‘Šï¼ˆæ—¢å­˜ãƒ­ã‚¸ãƒƒã‚¯ç¶™æ‰¿ï¼‰â”€â”€
    if (V < 30) {
        adviceText += '<br><br><strong style="color:#ffb86c;">âš ï¸ Small Room Analysis</strong><br>æœ¬ç©ºé–“ã¯å®¹ç©ãŒå°ã•ã„ãŸã‚ã€è¨ˆç®—ä¸Šã®æ•°å€¤ã‚ˆã‚Šã‚‚å¹³è¡Œé¢ã§ç™ºç”Ÿã™ã‚‹å®šåœ¨æ³¢ï¼ˆãƒ–ãƒ¼ãƒŸãƒ³ã‚°ï¼‰ã®æŠ‘åˆ¶ãŒé‡è¦ã§ã™ã€‚å…¥éš…ï¼ˆã‚³ãƒ¼ãƒŠãƒ¼ï¼‰ã¸ã®å¸éŸ³æé…ç½®ã‚’å„ªå…ˆã™ã‚‹ã“ã¨ã§ã€ä½åŸŸã®ã‚¨ãƒãƒ«ã‚®ãƒ¼ã‚’åŠ¹ç‡çš„ã«å‡¦ç†ã§ãã¾ã™ã€‚';
    }
    if (rt_after[0] !== null && avgAfter > 0 && rt_after[0] > avgAfter * 1.5) {
        adviceText += '<br><br><strong style="color:#ffb86c;">âš ï¸ 125Hz ä½åŸŸæ®‹éŸ¿è­¦å‘Š</strong><br>125Hzã®æ®‹éŸ¿æ™‚é–“ãŒçªå‡ºã—ã¦ã„ã¾ã™ã€‚ä½åŸŸã®åˆ¶å¾¡ã«ã¯120mmåšã®ãƒ‘ãƒãƒ«ã€ã¾ãŸã¯ã‚³ãƒ¼ãƒŠãƒ¼é…ç½®ã®ãƒ™ãƒ¼ã‚¹ãƒˆãƒ©ãƒƒãƒ—ã‚’æ¨å¥¨ã—ã¾ã™ã€‚';
    }

    detailedNote.innerHTML = adviceText;
    updateChart(rt_before, rt_after, targetRT, scAvg);
    lastData = { rt_after: avgAfter, rt_before: avgBefore, targetRT, achievementRate, totalPanelM2, V, status };
}

window.addEventListener('DOMContentLoaded', init);
</script>

<script>
// ========================================
// Web Worker: ãƒ–ãƒ­ãƒ¼ãƒ‰ãƒãƒ³ãƒ‰è§£æã‚¨ãƒ³ã‚¸ãƒ³ï¼ˆRev 1.0ï¼‰
// å‡¦ç†ãƒ•ãƒ­ãƒ¼: Farina deconv â†’ BPFÃ—18 â†’ SNR â†’ Schroeder â†’ RTè¨ˆç®—
// ========================================
const workerCode = `
'use strict';

let _fs  = 48000;
let _cfg = null;
let _noiseFloor = null;
let _latencyOffset = null;

self.onmessage = function(e) {
    const msg = e.data;
    if (msg.type === 'INIT') { _fs = msg.sampleRate; _cfg = msg.config; return; }
    if (msg.type === 'SET_LATENCY') { _latencyOffset = msg.latencyOffset; return; }
    if (msg.type === 'CALIBRATION') {
        const noiseRec = new Float32Array(msg.noiseRecording);
        _noiseFloor = calculateNoiseFloorFromRecording(noiseRec);
        self.postMessage({ type: 'calibrationDone' });
        return;
    }
    if (msg.type === 'ANALYZE_ALL') { analyzeAll(msg); }
};

function calculateNoiseFloorFromRecording(signal) {
    const bands = _cfg.bands;
    const fs    = _fs;
    const noiseFloor = new Array(bands.length);
    for (let bi = 0; bi < bands.length; bi++) {
        const fc = bands[bi];
        const sections = designButterworthBPF(fc, fs, 6, 0.05);
        const filtered = applyBiquadCascade(signal, sections);
        let sumSq = 0;
        for (let i = 0; i < filtered.length; i++) sumSq += filtered[i] * filtered[i];
        noiseFloor[bi] = Math.sqrt(sumSq / filtered.length);
    }
    return noiseFloor;
}

function nextPow2(n) { let p = 1; while (p < n) p <<= 1; return p; }

function fft(re, im) {
    const N = re.length;
    for (let i = 1, j = 0; i < N; i++) {
        let bit = N >> 1;
        for (; j & bit; bit >>= 1) j ^= bit;
        j ^= bit;
        if (i < j) { let t; t=re[i];re[i]=re[j];re[j]=t; t=im[i];im[i]=im[j];im[j]=t; }
    }
    for (let len = 2; len <= N; len <<= 1) {
        const ang = -2.0 * Math.PI / len;
        const wRe = Math.cos(ang), wIm = Math.sin(ang);
        for (let i = 0; i < N; i += len) {
            let uRe = 1.0, uIm = 0.0;
            const half = len >> 1;
            for (let k = 0; k < half; k++) {
                const m = i+k+half;
                const vRe = re[m]*uRe - im[m]*uIm, vIm = re[m]*uIm + im[m]*uRe;
                re[m]=re[i+k]-vRe; im[m]=im[i+k]-vIm; re[i+k]+=vRe; im[i+k]+=vIm;
                const nRe = uRe*wRe - uIm*wIm; uIm = uRe*wIm + uIm*wRe; uRe = nRe;
            }
        }
    }
}

function ifft(re, im) {
    const N = re.length;
    for (let i = 0; i < N; i++) im[i] = -im[i];
    fft(re, im);
    for (let i = 0; i < N; i++) { re[i] /= N; im[i] = -im[i] / N; }
}

function findSweepStart(recorded, sweep) {
    const fs = _fs;
    let searchStart, searchEnd;
    if (_latencyOffset !== null) {
        const searchMargin = Math.floor(1.0 * fs);
        searchStart = Math.max(0, _latencyOffset - searchMargin);
        searchEnd   = Math.min(recorded.length - sweep.length, _latencyOffset + searchMargin);
    } else {
        searchStart = Math.floor(0.2 * fs);
        searchEnd   = Math.min(Math.floor(2.5 * fs), recorded.length - sweep.length);
    }
    if (searchEnd <= searchStart) return Math.floor(0.5 * fs);

    const sweepDuration = sweep.length / fs;
    let checkStart, checkLength;
    if (sweepDuration > 2.0) {
        checkStart  = Math.round(0.15 * fs) + Math.round(2.5 * fs);
        checkLength = Math.min(Math.round(0.3 * fs), sweep.length - checkStart);
    } else {
        checkStart  = 0;
        checkLength = Math.min(Math.floor(0.2 * fs), sweep.length);
    }

    let maxCorr = -Infinity, bestOffset = searchStart;
    const searchEndAdj = Math.min(searchEnd, recorded.length - checkStart - checkLength);
    for (let offset = searchStart; offset < searchEndAdj; offset += 100) {
        let corr = 0;
        for (let i = 0; i < checkLength; i++) corr += recorded[offset+checkStart+i] * sweep[checkStart+i];
        if (corr > maxCorr) { maxCorr = corr; bestOffset = offset; }
    }
    const fineStart = Math.max(searchStart, bestOffset - 100);
    const fineEnd   = Math.min(searchEndAdj, bestOffset + 100);
    maxCorr = -Infinity;
    for (let offset = fineStart; offset < fineEnd; offset++) {
        let corr = 0;
        for (let i = 0; i < checkLength; i++) corr += recorded[offset+checkStart+i] * sweep[checkStart+i];
        if (corr > maxCorr) { maxCorr = corr; bestOffset = offset; }
    }
    return bestOffset;
}

function extractIRFarina(recorded, sweep, fLow, fHigh, durationSec) {
    const fs      = _fs;
    const guardPre= Math.round(0.15 * fs);
    const N_sweep = Math.round(durationSec * fs);
    const k       = Math.log(fHigh / fLow);
    const inv = new Float64Array(N_sweep);
    for (let n = 0; n < N_sweep; n++) {
        const srcIdx = guardPre + (N_sweep - 1 - n);
        const val    = srcIdx < sweep.length ? sweep[srcIdx] : 0;
        inv[n]       = val * Math.exp(-n * k / N_sweep);
    }
    const N = nextPow2(recorded.length + N_sweep);
    const yRe=new Float64Array(N), xRe=new Float64Array(N), yIm=new Float64Array(N), xIm=new Float64Array(N);
    for (let i=0;i<recorded.length;i++) yRe[i]=recorded[i];
    for (let i=0;i<N_sweep;i++)         xRe[i]=inv[i];
    fft(yRe,yIm); fft(xRe,xIm);
    const hRe=new Float64Array(N), hIm=new Float64Array(N);
    for (let i=0;i<N;i++) { hRe[i]=yRe[i]*xRe[i]-yIm[i]*xIm[i]; hIm[i]=yRe[i]*xIm[i]+yIm[i]*xRe[i]; }
    ifft(hRe,hIm);
    const preBuf   = Math.round(0.05 * fs);
    const peakOff  = guardPre + N_sweep - 1;
    const startIdx = Math.max(0, peakOff - preBuf);
    const irLength = Math.min(N - startIdx, recorded.length);
    const ir = new Float64Array(irLength);
    for (let i=0;i<irLength;i++) ir[i]=hRe[startIdx+i];
    return ir;
}

function designButterworthBPF(fc, fs, order, margin) {
    const nSec   = order / 2;
    const fL     = (fc / Math.SQRT2) * (1.0 + margin);
    const fH     = (fc * Math.SQRT2) * (1.0 - margin);
    const Q_target = fc / (fH - fL);
    const Q_sec    = Q_target / Math.sqrt(Math.pow(2, 1.0 / nSec) - 1.0);
    const w0       = 2.0 * Math.PI * fc / fs;
    const alpha    = Math.sin(w0) / (2.0 * Q_sec);
    const cosW0    = Math.cos(w0);
    const a0       = 1.0 + alpha;
    const sec = { b0: alpha/a0, b1: 0.0, b2: -alpha/a0, a1: -2.0*cosW0/a0, a2: (1.0-alpha)/a0 };
    return [{...sec},{...sec},{...sec}];
}

function applyBiquadCascade(signal, sections) {
    let buf = new Float64Array(signal);
    for (const s of sections) {
        const out = new Float64Array(buf.length);
        let x1=0,x2=0,y1=0,y2=0;
        for (let i=0;i<buf.length;i++) {
            const x0=buf[i], y0=s.b0*x0+s.b1*x1+s.b2*x2-s.a1*y1-s.a2*y2;
            out[i]=y0; x2=x1;x1=x0;y2=y1;y1=y0;
        }
        buf=out;
    }
    return buf;
}

function calcSNR(ir, bandIndex) {
    const N = ir.length;
    const peakSearchEnd = Math.min(N, Math.round(_fs * 0.1));
    let peakIdx=0, peakVal=0;
    for (let i=0;i<peakSearchEnd;i++) { const v=Math.abs(ir[i]); if(v>peakVal){peakVal=v;peakIdx=i;} }
    const winSamples = Math.max(10, Math.floor(N * 0.02));
    const irEnd      = Math.min(N, peakIdx + winSamples);
    const irCount    = irEnd - peakIdx;
    if (irCount <= 0) return { snr: 60, peakIdx: 0 };
    let irE=0;
    for (let i=peakIdx;i<irEnd;i++) irE+=ir[i]*ir[i];
    const irRMS = Math.sqrt(irE/irCount);
    let noiseRMS;
    if (_noiseFloor && bandIndex >= 0 && bandIndex < _noiseFloor.length) {
        noiseRMS = _noiseFloor[bandIndex];
    } else {
        const nStart=Math.floor(N*0.75); let nE=0;
        for (let i=nStart;i<N;i++) nE+=ir[i]*ir[i];
        noiseRMS=Math.sqrt(nE/(N-nStart));
    }
    if (noiseRMS < 1e-20) return { snr: 60, peakIdx: 0, noiseRMS: 1e-10 };
    return { snr: 20.0*Math.log10(irRMS/noiseRMS), peakIdx, noiseRMS };
}

function schroederIntegral(ir, snr, peakIdx, envNoiseRMS) {
    const N=ir.length, fs=_fs;
    let noisePower;
    if (envNoiseRMS && envNoiseRMS > 1e-20) {
        noisePower = envNoiseRMS * envNoiseRMS;
    } else {
        const noiseStart=Math.floor(N*0.90); let noiseSum=0;
        for (let i=noiseStart;i<N;i++) noiseSum+=ir[i]*ir[i];
        noisePower=noiseSum/(N-noiseStart);
    }
    if (noisePower < 1e-30) return null;
    const cum=new Float64Array(N);
    cum[N-1]=ir[N-1]*ir[N-1];
    for (let i=N-2;i>=0;i--) cum[i]=cum[i+1]+ir[i]*ir[i];
    let lundebyIdx=N-1;
    for (let i=peakIdx;i<N;i++) { if(cum[i]<=noisePower*(N-i)){lundebyIdx=i;break;} }
    const corrPeak=cum[peakIdx]-noisePower*(N-peakIdx);
    if (corrPeak<=0) return null;
    const edcDB=new Float64Array(N).fill(-999);
    let truncIdx=lundebyIdx;
    for (let i=peakIdx;i<=lundebyIdx;i++) {
        const corrected=cum[i]-noisePower*(N-i);
        if(corrected<=0){truncIdx=i;break;}
        edcDB[i]=10.0*Math.log10(corrected/corrPeak);
    }
    return { edcDB, truncIdx, peakIdx };
}

function calcRT(edcDB, truncIdx, peakIdx, fs) {
    const RT_MAX=5.0, RT_MIN=0.03, R2_MIN=0.80;
    function validate(result, method) {
        if (!result) return null;
        const {rt,r2}=result;
        if (rt<RT_MIN||rt>RT_MAX) return null;
        if (r2<R2_MIN) return null;
        return {rt60:rt,method,r2};
    }
    const maxSearchSec=RT_MAX*2.0;
    const v60=validate(lsqRT(edcDB,truncIdx,peakIdx,fs,-5,-65,maxSearchSec),'T60');
    if(v60) return v60;
    const r30=lsqRT(edcDB,truncIdx,peakIdx,fs,-5,-35,maxSearchSec);
    if(r30){const v30=validate({rt:r30.rt*2.0,r2:r30.r2},'T30');if(v30) return v30;}
    const r20=lsqRT(edcDB,truncIdx,peakIdx,fs,-5,-25,maxSearchSec);
    if(r20){const v20=validate({rt:r20.rt*3.0,r2:r20.r2},'T20');if(v20) return v20;}
    return null;
}

function lsqRT(edcDB, truncIdx, peakIdx, fs, startDB, endDB, maxSearchSec) {
    const searchEnd=(maxSearchSec!=null)?Math.min(truncIdx,peakIdx+Math.floor(maxSearchSec*fs)):truncIdx;
    let s=-1,e=-1;
    for (let i=peakIdx;i<searchEnd;i++) {
        if(s<0&&edcDB[i]<=startDB){s=i;continue;}
        if(s>=0&&edcDB[i]<=endDB){e=i;break;}
    }
    if(s<0||e<0||(e-s)<10) return null;
    let n=0,sumX=0,sumY=0,sumXY=0,sumXX=0;
    for(let i=s;i<=e;i++){const t=i/fs;sumX+=t;sumY+=edcDB[i];sumXY+=t*edcDB[i];sumXX+=t*t;n++;}
    const denom=n*sumXX-sumX*sumX;
    if(Math.abs(denom)<1e-15) return null;
    const slope=(n*sumXY-sumX*sumY)/denom;
    const intercept=(sumY-slope*sumX)/n;
    if(slope>=0) return null;
    const meanY=sumY/n;
    let ssTot=0,ssRes=0;
    for(let i=s;i<=e;i++){const t=i/fs,pred=slope*t+intercept;ssTot+=(edcDB[i]-meanY)**2;ssRes+=(edcDB[i]-pred)**2;}
    const r2=ssTot>0?1.0-ssRes/ssTot:0;
    return {rt:(endDB-startDB)/slope,r2};
}

function analyzeAll(msg) {
    const {recorded,sweep,fLow,fHigh,durationSec}=msg;
    const fs=_fs;
    const minSnr   =(_cfg&&_cfg.analysis)?_cfg.analysis.minSnr:15.0;
    const bpfOrder =(_cfg&&_cfg.analysis)?_cfg.analysis.bpfOrder:6;
    const bpfMargin=(_cfg&&_cfg.analysis)?_cfg.analysis.bpfMargin:0.05;
    const bands    =(_cfg&&_cfg.bands)?_cfg.bands:[100,125,160,200,250,315,400,500,630,800,1000,1250,1600,2000,2500,3150,4000,5000];
    try {
        const recF32=new Float32Array(recorded), swpF32=new Float32Array(sweep);
        const sweepStart=findSweepStart(recF32,swpF32);
        const reverbTail=Math.floor(5.0*fs);
        const endPos=Math.min(sweepStart+swpF32.length+reverbTail,recF32.length);
        const trimmed=recF32.slice(sweepStart,endPos);
        const ir=extractIRFarina(trimmed,swpF32,fLow,fHigh,durationSec);
        const thirdResults=new Array(bands.length).fill(null);
        const methodResults=new Array(bands.length).fill(null);
        const r2Results=new Array(bands.length).fill(null);
        for (let bi=0;bi<bands.length;bi++) {
            const band=bands[bi];
            self.postMessage({type:'bandProgress',band,index:bi,total:bands.length});
            const sections=designButterworthBPF(band,fs,bpfOrder,bpfMargin);
            const irFiltered=applyBiquadCascade(ir,sections);
            const {snr,peakIdx,noiseRMS}=calcSNR(irFiltered,-1);
            if(snr<minSnr) continue;
            const schResult=schroederIntegral(irFiltered,snr,peakIdx,noiseRMS);
            if(!schResult) continue;
            const {edcDB,truncIdx}=schResult;
            const rtResult=calcRT(edcDB,truncIdx,peakIdx,fs);
            if(!rtResult) continue;
            thirdResults[bi]=+rtResult.rt60.toFixed(3);
            methodResults[bi]=rtResult.method;
            r2Results[bi]=+rtResult.r2.toFixed(3);
        }
        self.postMessage({type:'result',thirdResults,methodResults,r2Results});
    } catch(err) {
        self.postMessage({type:'error',message:'analyzeAllå¤±æ•—: '+err.message});
    }
}
`;

let measurementWorker = null;

function initWorker() {
    const blob = new Blob([workerCode], { type: 'text/javascript' });
    measurementWorker = new Worker(URL.createObjectURL(blob));
    measurementWorker.onmessage = function(e) {
        if (e.data.type === 'debug') { console.log('[Worker] ' + e.data.message); return; }
        if (e.data.type === 'result') handleMeasurementResult(e.data);
        if (e.data.type === 'error')  handleMeasurementError(e.data.message);
    };
    measurementWorker.onerror = function(err) { console.error('Worker error:', err); };
}

function handleMeasurementResult(data) {
    const statusEl  = document.getElementById('measureStatus');
    const startBtn  = document.getElementById('startMeasBtn');
    const progressEl = document.getElementById('measureProgress');
    const warnEl    = document.getElementById('remeasureWarning');
    startBtn.disabled = false;
    progressEl.style.display = 'none';
    document.getElementById('recordingAlert').classList.remove('active');
    warnEl.style.display = 'none';

    const thirdResults = data.thirdResults;
    const octaveDefs   = MEASUREMENT_CONFIG.octaveBands;
    const octaveResults = new Array(6).fill(null);
    let validOctaveCount = 0;
    const missingBands = [], measuredBands = [];

    for (let i = 0; i < octaveDefs.length; i++) {
        const group  = octaveDefs[i];
        const values = group.indices.map(idx => thirdResults[idx]).filter(v => v !== null && v > 0);
        if (values.length > 0) {
            octaveResults[i] = values.reduce((s,v) => s+v, 0) / values.length;
            validOctaveCount++;
            measuredBands.push(group.label);
        } else {
            octaveResults[i] = null;
            missingBands.push(group.label);
        }
    }

    const methodResults = data.methodResults || new Array(18).fill(null);
    window._r2Results       = data.r2Results    || new Array(18).fill(null);
    window._methodResultsAll = methodResults;

    const miss500 = octaveResults[2] === null;
    const miss1k  = octaveResults[3] === null;
    if (miss500 && miss1k) {
        statusEl.textContent = 'âŒ æ¸¬å®šå¤±æ•—: 500Hzãƒ»1kHz ãŒå–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸ';
        statusEl.className = 'status-msg error';
        document.getElementById('warningReason').textContent = 'éŸ³éŸ¿è©•ä¾¡ã®ä¸­æ ¸å¸¯åŸŸï¼ˆ500Hzãƒ»1kHzï¼‰ãŒä¸¡æ–¹å–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼éŸ³é‡ã‚’ä¸Šã’ã‚‹ã‹ã€å¤–éƒ¨ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼ã§å†æ¸¬å®šã—ã¦ãã ã•ã„ã€‚';
        warnEl.className = 'warning-box'; warnEl.style.display = 'block';
        startBtn.disabled = false; return;
    }
    if (validOctaveCount === 0) {
        statusEl.textContent = 'âŒ æ¸¬å®šå¤±æ•—: æœ‰åŠ¹ãƒ‡ãƒ¼ã‚¿ãŒ0ãƒãƒ³ãƒ‰ã§ã™';
        statusEl.className = 'status-msg error';
        document.getElementById('warningReason').textContent = 'ã™ã¹ã¦ã®ãƒãƒ³ãƒ‰ã§SNRä¸è¶³ã®ãŸã‚æ¸¬å®šã§ãã¾ã›ã‚“ã§ã—ãŸã€‚ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼éŸ³é‡ã‚’ä¸Šã’ã‚‹ã‹ã€ç’°å¢ƒãƒã‚¤ã‚ºã‚’ä¸‹ã’ã¦å†æ¸¬å®šã—ã¦ãã ã•ã„ã€‚';
        warnEl.className = 'warning-box'; warnEl.style.display = 'block';
        startBtn.disabled = false; return;
    }

    measurementData = octaveResults;

    const METHOD_RANK = { 'T20': 0, 'T30': 1, 'T60': 2 };
    let lowestMethod = 'T60';
    for (let i = 0; i < octaveDefs.length; i++) {
        if (octaveResults[i] === null) continue;
        for (const bi of octaveDefs[i].indices) {
            const m = methodResults[bi];
            if (m && METHOD_RANK[m] < METHOD_RANK[lowestMethod]) lowestMethod = m;
        }
    }
    window._measurementMethod = lowestMethod;

    const _badge = document.getElementById('methodBadge');
    if (_badge) {
        const mc = { 'T60': 'var(--success)', 'T30': 'var(--warning)', 'T20': 'var(--caution)' };
        _badge.textContent = lowestMethod;
        _badge.style.background = mc[lowestMethod] || 'var(--warning)';
    }

    saveRoomSizeToBuffer();
    disableRoomSizeInputs();
    measurementActive = true;

    const bandSummary = 'Measured: ' + validOctaveCount + ' / 6 bands';
    if (validOctaveCount >= 5) {
        statusEl.textContent = 'âœ… æ¸¬å®šå®Œäº†ï¼ˆ' + bandSummary + 'ï¼‰';
        statusEl.className = 'status-msg success';
    } else if (validOctaveCount >= 3) {
        statusEl.textContent = 'âš ï¸ æ¸¬å®šå®Œäº†ï¼ˆ' + bandSummary + 'ï¼‰â€” ç²¾åº¦æ³¨æ„';
        statusEl.className = 'status-msg warning';
        document.getElementById('warningReason').textContent = 'æ¬ æãƒãƒ³ãƒ‰: ' + missingBands.join(', ') + '\nSNRä¸è¶³ã¾ãŸã¯EDCå“è³ªä¸è‰¯ã®ãŸã‚ä¸€éƒ¨ãƒãƒ³ãƒ‰ãŒå–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚å¤–éƒ¨ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼ã§ã®å†æ¸¬å®šã‚’æ¨å¥¨ã—ã¾ã™ã€‚';
        warnEl.className = 'warning-box warning-yellow'; warnEl.style.display = 'block';
    } else {
        statusEl.textContent = 'ğŸ”´ æ¸¬å®šå®Œäº†ï¼ˆ' + bandSummary + 'ï¼‰â€” ç²¾åº¦ä¸è¶³ãƒ»å†æ¸¬å®šæ¨å¥¨';
        statusEl.className = 'status-msg error';
        document.getElementById('warningReason').textContent = 'æ¬ æãƒãƒ³ãƒ‰: ' + missingBands.join(', ') + '\nå–å¾—ã§ããŸãƒãƒ³ãƒ‰ãŒå°‘ãªãã€éŸ³éŸ¿è©•ä¾¡ã®ä¿¡é ¼æ€§ãŒä½ã„çŠ¶æ…‹ã§ã™ã€‚ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼éŸ³é‡ã‚’ä¸Šã’ã‚‹ã‹ã€å¤–éƒ¨ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼ãƒ»ãƒã‚¤ã‚¯ã§å†æ¸¬å®šã—ã¦ãã ã•ã„ã€‚';
        warnEl.className = 'warning-box'; warnEl.style.display = 'block';
    }
    calculate();
}

function handleMeasurementError(message) {
    document.getElementById('startMeasBtn').disabled = false;
    document.getElementById('measureProgress').style.display = 'none';
    document.getElementById('recordingAlert').classList.remove('active');
    const statusEl = document.getElementById('measureStatus');
    statusEl.textContent = 'âŒ ' + message;
    statusEl.className = 'status-msg error';
}

window.addEventListener('DOMContentLoaded', function() { initWorker(); });
</script>

<script>
// ========================================
// æ¸¬å®šè¨­å®šï¼ˆRev 1.0 / Broadband Sweepä»•æ§˜ï¼‰
// ========================================
const MEASUREMENT_CONFIG = {
    sampleRate: 48000,
    bands: [100,125,160,200,250,315,400,500,630,800,1000,1250,1600,2000,2500,3150,4000,5000],
    octaveBands: [
        { label: '125Hz', indices: [0,1,2]    },
        { label: '250Hz', indices: [3,4,5]    },
        { label: '500Hz', indices: [6,7,8]    },
        { label: '1kHz',  indices: [9,10,11]  },
        { label: '2kHz',  indices: [12,13,14] },
        { label: '4kHz',  indices: [15,16,17] }
    ],
    timing: { delay: 1.0, stimulus: 5.0, recording: 5.0, totalPerBand: 5.0 },
    analysis: { bpfOrder: 6, bpfMargin: 0.05, minSnr: 15.0 },
    beep: { frequency: 1000, duration: 0.2, gain: 0.3, waitAfter: 1.0 },
    sweepGain: 0.7
};

let audioContext = null;
let mediaStream  = null;
let systemLatencyOffset = null;

function sleep(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }

async function measureNoiseFloor(ctx, stream) {
    const fs = ctx.sampleRate, duration = 5.0;
    const totalSamples = Math.round(duration * fs);
    const bufferSize = 4096, recorded = new Float32Array(totalSamples);
    let recordedSamples = 0, resolveRecording;
    const recordingDone = new Promise(r => { resolveRecording = r; });
    const source = ctx.createMediaStreamSource(stream);
    const processor = ctx.createScriptProcessor(bufferSize, 1, 1);
    processor.onaudioprocess = (e) => {
        const input = e.inputBuffer.getChannelData(0);
        for (let i = 0; i < input.length; i++) { if (recordedSamples < totalSamples) recorded[recordedSamples++] = input[i]; }
        if (recordedSamples >= totalSamples) resolveRecording();
    };
    const dummyDest = ctx.createMediaStreamDestination();
    source.connect(processor); processor.connect(dummyDest);
    await recordingDone;
    source.disconnect(); processor.disconnect();
    return recorded;
}

async function playBeep(ctx, speakerId) {
    const cfg = MEASUREMENT_CONFIG.beep;
    const osc = ctx.createOscillator(), gain = ctx.createGain();
    osc.type = 'sine'; osc.frequency.value = cfg.frequency;
    gain.gain.setValueAtTime(cfg.gain, ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + cfg.duration);
    osc.connect(gain);
    if (isIOS) {
        gain.connect(ctx.destination);
        if (ctx.state === 'suspended') await ctx.resume();
        osc.start(ctx.currentTime); osc.stop(ctx.currentTime + cfg.duration);
    } else {
        const destination = ctx.createMediaStreamDestination();
        gain.connect(destination);
        const audio = new Audio();
        audio.srcObject = destination.stream;
        if (speakerId && typeof audio.setSinkId === 'function') { try { await audio.setSinkId(speakerId); } catch(e) {} }
        osc.start(ctx.currentTime); osc.stop(ctx.currentTime + cfg.duration);
        await audio.play();
    }
    await sleep((cfg.duration + cfg.waitAfter) * 1000);
    osc.disconnect(); gain.disconnect();
}

function generateBroadbandSweep(sampleRate, durationSec) {
    const fLow=20, fHigh=20000;
    const guardPre=Math.round(0.15*sampleRate), guardPost=Math.round(0.10*sampleRate);
    const sweepSamples=Math.round(durationSec*sampleRate);
    const k=Math.log(fHigh/fLow)/durationSec;
    const totalSamples=guardPre+sweepSamples+guardPost;
    const sweep=new Float32Array(totalSamples);
    for (let i=0;i<sweepSamples;i++) {
        const t=i/sampleRate, phase=2*Math.PI*fLow*(Math.exp(k*t)-1)/k;
        sweep[guardPre+i]=Math.sin(phase)*MEASUREMENT_CONFIG.sweepGain;
    }
    const fadeSamples=Math.round(0.05*sampleRate);
    for (let i=0;i<fadeSamples;i++) {
        const p=i/fadeSamples;
        sweep[guardPre+i]*=0.5*(1-Math.cos(Math.PI*p));
        sweep[guardPre+sweepSamples-fadeSamples+i]*=0.5*(1+Math.cos(Math.PI*p));
    }
    return { sweep, fLow, fHigh, durationSec };
}

function generateCalibrationChirp(sampleRate) {
    const duration=0.1, f1=500, f2=2000;
    const samples=Math.floor(duration*sampleRate);
    const chirp=new Float32Array(samples);
    for (let i=0;i<samples;i++) {
        const t=i/sampleRate, phase=2*Math.PI*(f1*t+(f2-f1)*t*t/(2*duration));
        chirp[i]=Math.sin(phase);
    }
    for (let i=0;i<samples;i++) { const w=0.5*(1-Math.cos(2*Math.PI*i/samples)); chirp[i]*=w; }
    return chirp;
}

function findChirpOffset(recorded, chirp, sampleRate) {
    const searchSamples=Math.min(Math.floor(2.0*sampleRate), recorded.length-chirp.length);
    if (searchSamples<=0) return Math.floor(0.5*sampleRate);
    let maxCorr=-Infinity, bestOffset=0;
    for (let offset=0;offset<searchSamples;offset+=100) {
        let corr=0;
        for (let i=0;i<chirp.length;i++) corr+=recorded[offset+i]*chirp[i];
        if(corr>maxCorr){maxCorr=corr;bestOffset=offset;}
    }
    const fineStart=Math.max(0,bestOffset-100), fineEnd=Math.min(searchSamples,bestOffset+100);
    maxCorr=-Infinity;
    for (let offset=fineStart;offset<fineEnd;offset++) {
        let corr=0;
        for (let i=0;i<chirp.length;i++) corr+=recorded[offset+i]*chirp[i];
        if(corr>maxCorr){maxCorr=corr;bestOffset=offset;}
    }
    return bestOffset;
}

async function calibrateLatency(audioContext, mediaStream, speakerId) {
    const fs=audioContext.sampleRate;
    const chirp=generateCalibrationChirp(fs);
    const recordingDuration=2.6, totalSamples=Math.round(recordingDuration*fs);
    const bufferSize=4096, recorded=new Float32Array(totalSamples);
    let recordedSamples=0, resolveRecording;
    const recordingDone=new Promise(r=>{resolveRecording=r;});
    const source=audioContext.createMediaStreamSource(mediaStream);
    const processor=audioContext.createScriptProcessor(bufferSize,1,1);
    processor.onaudioprocess=(e)=>{
        const input=e.inputBuffer.getChannelData(0);
        for(let i=0;i<input.length;i++){if(recordedSamples<totalSamples)recorded[recordedSamples++]=input[i];}
        if(recordedSamples>=totalSamples)resolveRecording();
    };
    const dummyDest=audioContext.createMediaStreamDestination();
    source.connect(processor); processor.connect(dummyDest);
    await new Promise(resolve=>setTimeout(resolve,200));
    const chirpBuffer=audioContext.createBuffer(1,chirp.length,fs);
    chirpBuffer.copyToChannel(chirp,0);
    const chirpSource=audioContext.createBufferSource();
    chirpSource.buffer=chirpBuffer;
    if (isIOS) {
        chirpSource.connect(audioContext.destination);
        chirpSource.start(audioContext.currentTime);
    } else {
        const dest=audioContext.createMediaStreamDestination();
        chirpSource.connect(dest);
        const audio=new Audio(); audio.srcObject=dest.stream;
        if(speakerId&&typeof audio.setSinkId==='function'){try{await audio.setSinkId(speakerId);}catch(e){}}
        await audio.play(); chirpSource.start(audioContext.currentTime);
    }
    await recordingDone;
    source.disconnect(); processor.disconnect();
    return findChirpOffset(recorded,chirp,fs);
}

async function playAndRecord(ctx, stream, sweepData, centerHz, speakerId) {
    const cfg=MEASUREMENT_CONFIG.timing, fs=ctx.sampleRate;
    const preBuffer=Math.round(0.5*fs), postBuffer=Math.round(0.5*fs);
    const sweepSamples=sweepData.sweep.length, recordingSamples=Math.round(cfg.recording*fs);
    const totalSamples=preBuffer+sweepSamples+recordingSamples+postBuffer;
    const bufferSize=4096, recorded=new Float32Array(totalSamples);
    let recordedSamples=0, resolveRecording;
    const recordingDone=new Promise(r=>{resolveRecording=r;});
    const source=ctx.createMediaStreamSource(stream);
    const processor=ctx.createScriptProcessor(bufferSize,1,1);
    processor.onaudioprocess=(e)=>{
        const input=e.inputBuffer.getChannelData(0);
        for(let i=0;i<input.length;i++){if(recordedSamples<totalSamples)recorded[recordedSamples++]=input[i];}
        if(recordedSamples>=totalSamples)resolveRecording();
    };
    const dummyDest=ctx.createMediaStreamDestination();
    source.connect(processor); processor.connect(dummyDest);
    await new Promise(resolve=>setTimeout(resolve,200));
    const sweepBuffer=ctx.createBuffer(1,sweepData.sweep.length,fs);
    sweepBuffer.copyToChannel(sweepData.sweep,0);
    const sweepSource=ctx.createBufferSource();
    sweepSource.buffer=sweepBuffer;
    let audio=null;
    if (isIOS) {
        sweepSource.connect(ctx.destination);
        if(ctx.state==='suspended') await ctx.resume();
        sweepSource.start(ctx.currentTime);
    } else {
        const dest=ctx.createMediaStreamDestination();
        sweepSource.connect(dest);
        audio=new Audio(); audio.srcObject=dest.stream;
        if(speakerId&&typeof audio.setSinkId==='function'){try{await audio.setSinkId(speakerId);}catch(e){}}
        await audio.play();
        await new Promise(resolve=>setTimeout(resolve,100));
        sweepSource.start(ctx.currentTime);
    }
    await recordingDone;
    source.disconnect(); processor.disconnect();
    if(audio){audio.pause();audio.srcObject=null;}
    return recorded;
}

async function runMeasurementSequence() {
    const statusEl  = document.getElementById('measureStatus');
    const startBtn  = document.getElementById('startMeasBtn');
    const progressEl = document.getElementById('measureProgress');
    startBtn.disabled=true;
    document.getElementById('remeasureWarning').style.display='none';

    const snrProfile   = SNR_PROFILES[currentSNRProfile];
    const initTimeSec  = 20;
    progressEl.style.display='block';
    document.getElementById('progressBar').style.width='0%';
    document.getElementById('progressCount').textContent='æº–å‚™ä¸­...';
    document.getElementById('progressTime').textContent='æ®‹ã‚Šç´„ '+initTimeSec+' ç§’';
    document.getElementById('progressLabel').textContent='ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ä¸­...';

    try {
        audioContext=new (window.AudioContext||window.webkitAudioContext)({sampleRate:MEASUREMENT_CONFIG.sampleRate});
        const actualFs=audioContext.sampleRate;
        if(actualFs!==MEASUREMENT_CONFIG.sampleRate) throw new Error(`ã“ã®ãƒ‡ãƒã‚¤ã‚¹ã¯48kHzã‚µãƒ³ãƒ—ãƒ«ãƒ¬ãƒ¼ãƒˆã«å¯¾å¿œã—ã¦ã„ã¾ã›ã‚“ã€‚ï¼ˆæ¤œå‡ºå€¤: ${actualFs}Hzï¼‰`);
    } catch(err) {
        statusEl.textContent='âŒ '+err.message; statusEl.className='status-msg error';
        startBtn.disabled=false; progressEl.style.display='none'; return;
    }

    const configWithSNR={...MEASUREMENT_CONFIG,analysis:{...MEASUREMENT_CONFIG.analysis,minSnr:snrProfile.threshold}};
    measurementWorker.postMessage({type:'INIT',sampleRate:audioContext.sampleRate,config:configWithSNR});

    if(audioContext.state==='suspended'){try{await audioContext.resume();}catch(e){}}

    try {
        const micId=document.getElementById('micSelect').value;
        mediaStream=await navigator.mediaDevices.getUserMedia({audio:{deviceId:micId?{exact:micId}:undefined,echoCancellation:false,noiseSuppression:false,autoGainControl:false,sampleRate:MEASUREMENT_CONFIG.sampleRate}});
    } catch(err) {
        statusEl.textContent='âŒ ãƒã‚¤ã‚¯ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ: '+err.message; statusEl.className='status-msg error';
        startBtn.disabled=false; progressEl.style.display='none'; return;
    }

    const speakerId=document.getElementById('spkSelect').value;
    statusEl.textContent=`ğŸ”” æ¸¬å®šã‚’é–‹å§‹ã—ã¾ã™ã€‚é™ã‹ã«ã—ã¦ãã ã•ã„ï¼ˆç´„${initTimeSec}ç§’ï¼‰`;
    statusEl.className='status-msg calibrating';
    document.getElementById('recordingAlert').classList.add('active');
    try { await playBeep(audioContext,speakerId); } catch(e) {}

    statusEl.textContent='ğŸ” ã‚·ã‚¹ãƒ†ãƒ é…å»¶ã‚’æ¸¬å®šä¸­...ï¼ˆç´„3ç§’ï¼‰';
    statusEl.className='status-msg calibrating';
    document.getElementById('progressLabel').textContent='ã‚·ã‚¹ãƒ†ãƒ é…å»¶æ¸¬å®šä¸­...';
    try {
        systemLatencyOffset=await calibrateLatency(audioContext,mediaStream,speakerId);
        const latencyMs=(systemLatencyOffset/audioContext.sampleRate*1000).toFixed(0);
        statusEl.textContent='âœ… ã‚·ã‚¹ãƒ†ãƒ é…å»¶: '+latencyMs+'ms';
        statusEl.className='status-msg success';
        await sleep(1000);
    } catch(e) {
        systemLatencyOffset=Math.floor(0.5*audioContext.sampleRate);
    }

    statusEl.textContent='ğŸ“Š ç’°å¢ƒãƒã‚¤ã‚ºã‚’æ¸¬å®šä¸­...ï¼ˆ5ç§’ï¼‰';
    statusEl.className='status-msg calibrating';
    document.getElementById('progressLabel').textContent='ç’°å¢ƒãƒã‚¤ã‚ºæ¸¬å®šä¸­...';
    try {
        const noiseRecording=await measureNoiseFloor(audioContext,mediaStream);
        measurementWorker.postMessage({type:'CALIBRATION',noiseRecording:noiseRecording.buffer},[noiseRecording.buffer]);
    } catch(e) {}

    measurementWorker.postMessage({type:'SET_LATENCY',latencyOffset:systemLatencyOffset});

    statusEl.textContent='ğŸ”Š ã‚¹ã‚¤ãƒ¼ãƒ—å†ç”Ÿãƒ»éŒ²éŸ³ä¸­...ï¼ˆç´„12ç§’ï¼‰';
    statusEl.className='status-msg analyzing';
    document.getElementById('progressLabel').textContent='ã‚¹ã‚¤ãƒ¼ãƒ—å†ç”Ÿä¸­...';
    await sleep(MEASUREMENT_CONFIG.timing.delay*1000);

    const sweepResult=generateBroadbandSweep(audioContext.sampleRate,MEASUREMENT_CONFIG.timing.stimulus);
    const {sweep:sweepSignal,fLow:sweepFLow,fHigh:sweepFHigh,durationSec:sweepDuration}=sweepResult;
    const sweepDataObj={sweep:sweepSignal};

    const recordingTotalMs=(MEASUREMENT_CONFIG.timing.stimulus+MEASUREMENT_CONFIG.timing.recording+1.5)*1000;
    const recStart=Date.now();
    document.getElementById('progressBar').style.width='0%';
    document.getElementById('progressCount').textContent='éŒ²éŸ³ä¸­...';
    document.getElementById('progressLabel').textContent='ğŸ”Š ã‚¹ã‚¤ãƒ¼ãƒ—å†ç”Ÿãƒ»æ®‹éŸ¿éŒ²éŸ³ä¸­';

    const recProgressTimer=setInterval(()=>{
        const elapsed=Date.now()-recStart;
        const pct=Math.min(Math.round(elapsed/recordingTotalMs*50),49);
        const remaining=Math.max(0,Math.ceil((recordingTotalMs-elapsed)/1000));
        document.getElementById('progressBar').style.width=pct+'%';
        document.getElementById('progressTime').textContent='æ®‹ã‚Šç´„ '+remaining+' ç§’';
    },300);

    let recorded;
    try {
        recorded=await playAndRecord(audioContext,mediaStream,sweepDataObj,0,speakerId);
    } catch(err) {
        clearInterval(recProgressTimer);
        statusEl.textContent='âŒ éŒ²éŸ³å¤±æ•—: '+err.message; statusEl.className='status-msg error';
        startBtn.disabled=false; progressEl.style.display='none'; return;
    }
    clearInterval(recProgressTimer);
    document.getElementById('progressBar').style.width='50%';
    document.getElementById('progressCount').textContent='éŒ²éŸ³å®Œäº†';

    statusEl.textContent='ğŸ”„ Farinaæ³•ãƒ‡ã‚³ãƒ³ãƒœãƒªãƒ¥ãƒ¼ã‚·ãƒ§ãƒ³ãƒ»è§£æä¸­...';
    statusEl.className='status-msg analyzing';

    const analysisResult=await new Promise((resolve)=>{
        let completedCount=0;
        measurementWorker.onmessage=(e)=>{
            if(e.data.type==='debug'){console.log('[Worker] '+e.data.message);return;}
            if(e.data.type==='bandProgress'){
                completedCount++;
                const {band,index,total}=e.data;
                const analysisPct=Math.round((completedCount/total)*50);
                document.getElementById('progressBar').style.width=(50+analysisPct)+'%';
                document.getElementById('progressCount').textContent='è§£æ: '+completedCount+' / '+total+' ãƒãƒ³ãƒ‰';
                document.getElementById('progressTime').textContent='';
                document.getElementById('progressLabel').textContent='ğŸ”„ '+band+'Hz è§£æä¸­...';
                statusEl.textContent='ğŸ”„ Farinaæ³•è§£æä¸­... '+band+'Hz ['+completedCount+'/'+total+']';
                return;
            }
            if(e.data.type==='result') resolve(e.data);
            if(e.data.type==='error') resolve({type:'error',thirdResults:new Array(18).fill(null)});
        };
        measurementWorker.postMessage({type:'ANALYZE_ALL',recorded:recorded.buffer,sweep:sweepSignal.buffer,fLow:sweepFLow,fHigh:sweepFHigh,durationSec:sweepDuration},[recorded.buffer,sweepSignal.buffer]);
    });

    document.getElementById('recordingAlert').classList.remove('active');
    if(mediaStream){mediaStream.getTracks().forEach(t=>t.stop());mediaStream=null;}
    if(audioContext){try{await audioContext.close();}catch(e){}audioContext=null;}

    handleMeasurementResult({type:'result',thirdResults:analysisResult.thirdResults});
}
</script>

<script>
// ========================================
// Google Form é€ä¿¡ãƒ»ã‚°ãƒ©ãƒ•æç”»
// ========================================
function sendToGoogleForm() {
    const formUrl = "https://docs.google.com/forms/d/e/1FAIpQLSedr8Z99dcRJuV3qYRmYddUUzYGrnvrz2aU3zbFvrwVpbTreQ/viewform";
    const appSelect = document.getElementById('appTarget');
    const app = appSelect.options[appSelect.selectedIndex].text;
    const w=document.getElementById('w').value, d=document.getElementById('d').value, h=document.getElementById('h').value;
    const size=`${w}m Ã— ${d}m Ã— ${h}m`;
    const wallSelect=document.getElementById('baseWall'), ceilingSelect=document.getElementById('baseCeiling'), floorSelect=document.getElementById('baseFloor');
    const base=`å£: ${wallSelect.options[wallSelect.selectedIndex].text}, å¤©äº•: ${ceilingSelect.options[ceilingSelect.selectedIndex].text}, åºŠ: ${floorSelect.options[floorSelect.selectedIndex].text}`;
    let productList="";
    for (let i=0;i<3;i++) {
        const spec=selectedSpecs[i], qty=parseInt(document.getElementById(`qty_${i}`).value)||0;
        if(spec.category&&spec.model&&spec.thick&&spec.size&&qty>0)
            productList+=`ãƒ»${SOUNDBOX_DB.products[spec.category].models[spec.model].n} / ${spec.thick}mm / ${spec.size} Ã— ${qty}æš\n`;
    }
    if(!productList) productList="é¸æŠãªã—";
    const rtText=document.getElementById('postRT_Avg').textContent;
    const params=new URLSearchParams();
    params.append("usp","pp_url");
    params.append("entry.1871431492",app);
    params.append("entry.1902994140",size);
    params.append("entry.779901469",base);
    params.append("entry.364281805",productList);
    params.append("entry.1449240528",rtText);
    window.open(`${formUrl}?${params.toString()}`,'_blank');
}

// updateChart() â€” Rev 1.1
// è¿½åŠ : ç¬¬2Yè»¸ï¼ˆæ•£ä¹±ä¿‚æ•° s, 0ã€œ1.0ï¼‰/ scAvgæ›²ç·šï¼ˆscãƒ‘ãƒãƒ«è¿½åŠ æ™‚ã®ã¿è¡¨ç¤ºï¼‰
function updateChart(rt_before, rt_after, targetRT, scAvg) {
    const ctx = document.getElementById('rtChart').getContext('2d');
    if (chart) chart.destroy();

    function makePointStyles(data) { return data.map(v => v===null ? 'crossRot' : 'circle'); }
    function makePointRadii(data, r)  { return data.map(v => v===null ? 7 : r); }
    function makePointColors(data, c) { return data.map(v => v===null ? '#ff7b72' : c); }
    function fillNullForPlot(data) {
        return data.map((v,i)=>{
            if(v!==null) return v;
            const prev=data.slice(0,i).reverse().find(x=>x!==null);
            const next=data.slice(i+1).find(x=>x!==null);
            if(prev!==null&&next!==null) return (prev+next)/2;
            return prev!==null?prev:(next!==null?next:0);
        });
    }

    const beforePlot = fillNullForPlot(rt_before);
    const afterPlot  = fillNullForPlot(rt_after);
    const hasScData  = scAvg !== null;

    // datasetsæ§‹ç¯‰
    const datasets = [
        {
            label: 'ç¾çŠ¶ (Before)', data: beforePlot, spanGaps: true,
            yAxisID: 'y',
            borderColor: '#8b949e', backgroundColor: 'rgba(139,148,158,0.05)',
            borderDash: [5,5], borderWidth: 2, fill: false, tension: 0.3,
            pointStyle: makePointStyles(rt_before),
            pointRadius: makePointRadii(rt_before, 4),
            pointBackgroundColor: makePointColors(rt_before, '#8b949e'),
            pointBorderColor: makePointColors(rt_before, '#8b949e')
        },
        {
            label: 'å¯¾ç­–å¾Œ (After)', data: afterPlot, spanGaps: true,
            yAxisID: 'y',
            borderColor: '#39d353', backgroundColor: 'rgba(57,211,83,0.1)',
            borderWidth: 3, fill: true, tension: 0.3,
            pointStyle: makePointStyles(rt_after),
            pointRadius: makePointRadii(rt_after, 5),
            pointBackgroundColor: makePointColors(rt_after, '#39d353'),
            pointBorderColor: makePointColors(rt_after, '#fff'),
            pointBorderWidth: 2
        },
        {
            label: 'ç›®æ¨™å€¤', data: FREQS.map(() => targetRT),
            yAxisID: 'y',
            borderColor: '#388bfd', backgroundColor: 'rgba(56,139,253,0.05)',
            borderWidth: 2, borderDash: [10,5], fill: false, pointRadius: 0
        }
    ];

    // scAvgãŒã‚ã‚‹å ´åˆã®ã¿æ•£ä¹±ä¿‚æ•°æ›²ç·šã‚’è¿½åŠ 
    if (hasScData) {
        datasets.push({
            label: 'æ•£ä¹±ä¿‚æ•° sï¼ˆå‚ç…§ï¼‰', data: scAvg,
            yAxisID: 'ysc',
            borderColor: '#e3b341', backgroundColor: 'rgba(227,179,65,0.08)',
            borderWidth: 2, borderDash: [4,3], fill: false, tension: 0.3,
            pointRadius: 4,
            pointBackgroundColor: '#e3b341',
            pointBorderColor: '#e3b341'
        });
    }

    // scalesæ§‹ç¯‰ï¼ˆscAvgãŒã‚ã‚‹å ´åˆã®ã¿å³Yè»¸ã‚’è¿½åŠ ï¼‰
    const scales = {
        y: {
            min: 0, max: 2.5,
            position: 'left',
            grid: { color: '#30363d' },
            ticks: { color: '#8b949e', font: { size: 11 }, callback: v => v.toFixed(1)+'s' },
            title: { display: true, text: 'RT60 (sec)', color: '#8b949e', font: { size: 12, weight: 'bold' } }
        },
        x: { grid: { color: '#30363d' }, ticks: { color: '#8b949e', font: { size: 11 } } }
    };
    if (hasScData) {
        scales.ysc = {
            min: 0, max: 1.0,
            position: 'right',
            grid: { drawOnChartArea: false },
            ticks: {
                color: '#e3b341', font: { size: 10 },
                callback: v => v.toFixed(1)
            },
            title: { display: true, text: 'æ•£ä¹±ä¿‚æ•° s', color: '#e3b341', font: { size: 11, weight: 'bold' } }
        };
    }

    chart = new Chart(ctx, {
        type: 'line',
        data: { labels: FREQS.map(f => f + 'Hz'), datasets },
        options: {
            responsive: true, maintainAspectRatio: false, spanGaps: true,
            interaction: { mode: 'index', intersect: false },
            scales,
            plugins: {
                legend: {
                    display: true, position: 'top',
                    labels: {
                        color: '#e6edf3', font: { size: 11 }, padding: 15, usePointStyle: true,
                        generateLabels: function(chart) {
                            const orig = Chart.defaults.plugins.legend.labels.generateLabels(chart);
                            orig.forEach(item => { item.pointStyle = 'circle'; });
                            return orig;
                        }
                    }
                },
                tooltip: {
                    backgroundColor: 'rgba(22,27,34,0.95)', titleColor: '#e6edf3', bodyColor: '#e6edf3',
                    borderColor: '#30363d', borderWidth: 1, padding: 10,
                    callbacks: {
                        label: function(ctx) {
                            // æ•£ä¹±ä¿‚æ•°æ›²ç·š
                            if (ctx.dataset.yAxisID === 'ysc') {
                                return 'æ•£ä¹±ä¿‚æ•° sï¼ˆå‚ç…§ï¼‰: ' + ctx.parsed.y.toFixed(2) + '  â€»RT60ã¨ã¯ç‹¬ç«‹ã—ãŸæŒ‡æ¨™';
                            }
                            // ç›®æ¨™å€¤
                            if (ctx.datasetIndex === 2) return ctx.dataset.label + ': ' + ctx.parsed.y.toFixed(2) + 's';
                            // Before / After
                            const raw = ctx.datasetIndex === 0 ? rt_before[ctx.dataIndex] : rt_after[ctx.dataIndex];
                            if (raw === null) return ctx.dataset.label + ': N/Aï¼ˆæ¸¬å®šä¸å¯ï¼‰';
                            const bi = ctx.dataIndex;
                            const r2   = (window._r2Results && window._r2Results[bi] != null) ? window._r2Results[bi] : null;
                            const meth = (window._methodResultsAll && window._methodResultsAll[bi]) ? window._methodResultsAll[bi] : null;
                            let suffix = '';
                            if (meth && r2 != null) suffix = ' (' + meth + ', RÂ²=' + r2.toFixed(2) + ')';
                            else if (meth) suffix = ' (' + meth + ')';
                            return ctx.dataset.label + ': ' + raw.toFixed(2) + 's' + suffix;
                        }
                    }
                }
            }
        }
    });
}
</script>
</body>
</html>
