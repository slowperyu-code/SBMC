<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
    <link rel="canonical" href="https://soundbox.altwaves.co.jp/">
    <meta name="description" content="Soundbox Engine v6.1 (Rev 18.11): Sabine-Eyring Hybrid Professional System with Real-time Measurement">
    <title>Soundbox Material Calculator v7 | ãƒ—ãƒ­ãƒ•ã‚§ãƒƒã‚·ãƒ§ãƒŠãƒ«èª¿éŸ³è¨­è¨ˆãƒ„ãƒ¼ãƒ«</title>
    
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        :root { 
            --primary: #39d353; 
            --bg: #0d1117; 
            --card: #161b22; 
            --text: #e6edf3; 
            --dim: #8b949e; 
            --border: #30363d; 
            --accent: #388bfd; 
            --danger: #ff7b72; 
            --warning: #d29922; 
            --success: #39d353; 
            --caution: #f0883e;
        }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif; background-color: var(--bg); color: var(--text); padding: 15px; margin: 0; font-size: 13px; line-height: 1.4; }
        .container { max-width: 1000px; min-width: 800px; margin: auto; background: var(--card); padding: 25px; border-radius: 12px; border: 1px solid var(--border); box-shadow: 0 10px 40px rgba(0,0,0,0.5); position: relative; }
        .header { border-bottom: 1px solid var(--border); margin-bottom: 20px; padding-bottom: 12px; position: relative; }
        .header-top { display: flex; justify-content: space-between; align-items: flex-start; }
        h2 { color: var(--primary); margin: 0; font-size: 1.4rem; letter-spacing: 0.5px; }
        .subtitle { font-size: 0.85rem; color: var(--text); margin-top: 5px; font-weight: 500; }
        .logic-note { position: absolute; bottom: 8px; right: 0; font-size: 0.65rem; color: var(--dim); font-style: italic; }
        .btn-group { display: flex; gap: 10px; }
        .btn-base { border: none; padding: 7px 16px; border-radius: 4px; font-size: 0.75rem; cursor: pointer; font-weight: bold; transition: opacity 0.2s; text-decoration: none; }
        .btn-print { background: var(--border); color: var(--text); border: 1px solid var(--border); }
        .btn-estimate { background: var(--accent); color: white; }
        .btn-base:hover { opacity: 0.8; }
        .section-title { font-size: 0.8rem; font-weight: bold; color: var(--accent); margin: 20px 0 10px 0; border-left: 3px solid var(--accent); padding-left: 8px; }
        input, select, .custom-select-trigger { background: var(--bg); border: 1px solid var(--border); color: var(--text); padding: 0 10px; border-radius: 4px; width: 100%; box-sizing: border-box; font-size: 0.75rem; height: 36px; line-height: 34px; display: flex; align-items: center; }
        .grid-3 { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-bottom: 10px; }
        .grid-row { display: grid; grid-template-columns: 2fr 3.5fr 0.8fr 0.8fr 1fr; gap: 8px; margin-bottom: 8px; align-items: end; }
        label { font-size: 0.65rem; color: var(--dim); margin-bottom: 4px; display: block; }
        .custom-select-container { position: relative; width: 100%; }
        .custom-select-trigger { cursor: pointer; overflow: hidden; white-space: nowrap; text-overflow: ellipsis; border: 1px solid var(--border); }
        .sub-panel { display: none; position: absolute; top: 100%; left: 0; width: 540px; background: #1c2128; border: 1px solid var(--accent); border-radius: 8px; z-index: 100; box-shadow: 0 10px 30px rgba(0,0,0,0.8); padding: 15px; margin-top: 5px; }
        .sub-panel.active { display: block; }
        .panel-cols { display: grid; grid-template-columns: 1.4fr 0.8fr 1.2fr; gap: 12px; }
        .col-title { font-size: 0.6rem; color: var(--accent); margin-bottom: 8px; font-weight: bold; border-bottom: 1px solid var(--border); padding-bottom: 4px; }
        .col-item { padding: 6px 10px; border-radius: 4px; cursor: pointer; margin-bottom: 3px; font-size: 0.7rem; color: var(--text); }
        .col-item:hover { background: var(--border); }
        .col-item.selected { background: var(--accent); color: white; font-weight: bold; }
        .res-panel { display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; margin: 20px 0; }
        .res-card { background: var(--bg); padding: 15px; border-radius: 10px; border: 2px solid var(--border); text-align: center; }
        .res-val { font-size: 1.6rem; font-weight: bold; font-family: "Roboto Mono", monospace; }
        .chart-wrapper { position: relative; height: 320px; margin-top: 10px; border: 1px solid var(--border); border-radius: 8px; padding: 10px; background: rgba(0,0,0,0.2); }
        .footer-note { margin-top: 20px; padding: 18px; background: rgba(56, 139, 253, 0.05); border-radius: 8px; border: 1px solid var(--border); }
        .advice-tag { display: inline-block; padding: 2px 8px; border-radius: 4px; font-weight: bold; margin-bottom: 8px; font-size: 0.7rem; color: #000; }
        #print-only-notice { display: none; margin-top: 30px; padding: 20px; border: 1px solid #ddd; border-radius: 8px; font-size: 0.75rem; line-height: 1.6; color: #333; }
        .mode-switcher { display: flex; background: var(--bg); padding: 4px; border-radius: 8px; border: 1px solid var(--border); margin-bottom: 20px; }
        .mode-btn { flex: 1; padding: 10px; border: none; background: transparent; color: var(--dim); cursor: pointer; border-radius: 6px; font-weight: bold; transition: 0.2s; font-size: 0.75rem; }
        .mode-btn.active { background: var(--accent); color: white; }
        .mode-btn.active.measure { background: var(--warning); color: #000; }
        .calc-badge { display: inline-block; padding: 2px 6px; border-radius: 3px; font-size: 0.6rem; font-weight: bold; margin-left: 5px; background: var(--accent); color: white; }
        .measurement-panel { background: rgba(56, 139, 253, 0.05); border: 1px solid var(--accent); border-radius: 8px; padding: 15px; margin-bottom: 20px; }
        .measure-controls { display: grid; grid-template-columns: 1fr 1fr auto; gap: 10px; align-items: end; }
        .status-msg { font-size: 0.75rem; margin-top: 10px; font-weight: 500; min-height: 1.2em; padding: 8px; border-radius: 4px; text-align: center; }
        .status-msg.ready { color: var(--dim); }
        .status-msg.calibrating { background: rgba(210, 153, 34, 0.1); color: var(--warning); }
        .status-msg.analyzing { background: rgba(56, 139, 253, 0.1); color: var(--accent); }
        .status-msg.success { background: rgba(57, 211, 83, 0.1); color: var(--success); }
        .status-msg.warning { background: rgba(210, 153, 34, 0.2); color: var(--warning); }
        .status-msg.error { background: rgba(255, 123, 114, 0.1); color: var(--danger); }

        /* ========================================
           æ¸¬å®šé€²æ—ãƒãƒ¼ï¼ˆRev 18.11 æ–°è¦è¿½åŠ ï¼‰
           ======================================== */
        .measure-progress {
            margin-top: 10px;
            padding: 10px 12px;
            background: rgba(0,0,0,0.2);
            border-radius: 6px;
            border: 1px solid var(--border);
        }
        .measure-progress-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }
        .measure-progress-label {
            font-size: 0.72rem;
            color: var(--text);
            font-weight: 500;
        }
        .measure-progress-count {
            font-size: 0.65rem;
            color: var(--dim);
            font-family: "Roboto Mono", monospace;
        }
        .measure-progress-bar-track {
            width: 100%;
            height: 8px;
            background: var(--border);
            border-radius: 4px;
            overflow: hidden;
        }
        .measure-progress-bar-fill {
            height: 100%;
            width: 0%;
            background: var(--accent);
            border-radius: 4px;
            transition: width 0.4s ease;
        }
        .measure-progress-time {
            font-size: 0.65rem;
            color: var(--dim);
            margin-top: 5px;
            text-align: right;
        }
        /* ======================================== */

        .recording-flash { display: none; background: rgba(255, 123, 114, 0.1); border: 2px solid var(--danger); border-radius: 8px; padding: 15px; margin-top: 10px; text-align: center; }
        .recording-flash.active { display: block; animation: flash-border 1s infinite; }
        .flash-icon { font-size: 2rem; animation: blink 1s infinite; }
        .flash-text { font-size: 0.9rem; font-weight: bold; color: var(--danger); margin-top: 8px; }
        @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }
        @keyframes flash-border { 0%, 100% { border-color: var(--danger); } 50% { border-color: rgba(255, 123, 114, 0.3); } }
        .snr-indicator { margin-top: 10px; padding: 10px; background: rgba(0,0,0,0.2); border-radius: 6px; }
        .snr-bar { position: relative; width: 100%; height: 20px; background: var(--border); border-radius: 10px; overflow: hidden; margin-top: 5px; }
        .snr-value { height: 100%; background: linear-gradient(90deg, var(--danger), var(--warning), var(--success)); transition: width 0.3s; display: flex; align-items: center; justify-content: flex-end; padding-right: 8px; font-size: 0.7rem; font-weight: bold; color: white; }
        .warning-box { background: rgba(255, 123, 114, 0.1); border: 1px solid var(--danger); border-radius: 6px; padding: 12px; margin-top: 10px; font-size: 0.75rem; }
        .warning-box.warning-yellow { background: rgba(210, 153, 34, 0.15); border: 1px solid var(--warning); }
        .warning-box button { margin-top: 8px; padding: 6px 12px; background: var(--danger); color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.7rem; font-weight: bold; }
        .warning-box.warning-yellow button { background: var(--warning); }
        .warning-box button:hover { opacity: 0.8; }
        #warning-reason { margin-top: 5px; font-size: 0.7rem; color: var(--dim); }

        @media print {
            @page { size: A4; margin: 15mm; }
            body { background: white !important; color: black !important; padding: 0; }
            .container { box-shadow: none !important; border: none !important; width: 100% !important; max-width: none !important; min-width: 0 !important; background: white !important; padding: 0 !important; }
            .no-print, .logic-note, .mode-switcher, .measurement-panel { display: none !important; }
            .header { border-bottom: 2pt solid black !important; }
            h2, .section-title, .res-val, .subtitle { color: black !important; }
            input, select, .custom-select-trigger { border: none !important; background: transparent !important; color: black !important; padding: 0 !important; height: auto !important; appearance: none; }
            .grid-row { border-bottom: 0.5pt solid #eee; padding-bottom: 5px; }
            .res-card { border: 1pt solid black !important; background: white !important; }
            .chart-wrapper { border: 1pt solid #ccc !important; background: white !important; height: 300px !important; }
            .footer-note { border: 1pt solid #ccc !important; background: #f9f9f9 !important; color: black !important; }
            #print-only-notice { display: block !important; border: none !important; }
        }
    </style>
</head>
<body>
<div class="container">
    <div class="header">
        <div class="header-top">
            <h2>Soundbox Material Calculator</h2>
            <div class="btn-group no-print">
                <button class="btn-base btn-print" onclick="prepareForPrint()">çµæœã‚’å°åˆ· / PDFä¿å­˜</button>
                <button class="btn-base btn-estimate" onclick="sendToGoogleForm()">ã“ã®å†…å®¹ã§è¦‹ç©ã‚‚ã‚Šä¾é ¼</button>
            </div>
        </div>
        <div class="subtitle">Soundbox Engine v6.1 (Rev 18.11): Sabine-Eyring Hybrid System with Real-time Measurement</div>
        <div class="logic-note">Hybrid Calculation Engine Active</div>
    </div>

    <div class="mode-switcher no-print">
        <button class="mode-btn active" id="btnSim" onclick="setMode('sim')">è¨­è¨ˆã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ (Sabine)</button>
        <button class="mode-btn" id="btnMeasure" onclick="setMode('measure')">å®Ÿæ¸¬å€¤ãƒ™ãƒ¼ã‚¹æ”¹å–„ (Eyring)</button>
    </div>

    <div id="measurementPanel" class="measurement-panel no-print" style="display:none;">
        <div style="font-size:0.8rem; font-weight:bold; color:var(--accent); margin-bottom:12px;">
            ğŸ¤ PRO æ¸¬å®šãƒ¢ãƒ¼ãƒ‰ (Eyring Method / Log-Sweep Analysis)
        </div>
        
        <div class="measure-controls">
            <div>
                <label>å…¥åŠ›ãƒ‡ãƒã‚¤ã‚¹ (ãƒã‚¤ã‚¯)</label>
                <select id="micSelect">
                    <option value="">ãƒ‡ãƒã‚¤ã‚¹ã‚’é¸æŠ...</option>
                </select>
            </div>
            <div>
                <label>å‡ºåŠ›ãƒ‡ãƒã‚¤ã‚¹ (ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼)</label>
                <select id="spkSelect">
                    <option value="">ãƒ‡ãƒã‚¤ã‚¹ã‚’é¸æŠ...</option>
                </select>
            </div>
            
            <!-- SNRãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠ -->
            <div style="margin-top: 12px;">
                <label>æ¸¬å®šç²¾åº¦ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«</label>
                <select id="snrProfile" onchange="updateSNRProfileInfo()">
                    <option value="low">ä½ï¼ˆå†…è”µãƒ‡ãƒã‚¤ã‚¹å‘ã‘ï¼‰</option>
                    <option value="medium" selected>ä¸­ï¼ˆæ¨å¥¨ãƒ»Bluetoothï¼‰</option>
                    <option value="high">é«˜ï¼ˆISOæº–æ‹ ï¼‰</option>
                </select>
                <small id="snrProfileInfo" style="display:block; margin-top:4px; color:var(--dim); font-size:0.7rem;">
                    ä¸€èˆ¬çš„ãªéŸ³éŸ¿æ¸¬å®šã«é©ã—ã¦ã„ã¾ã™
                </small>
            </div>
            
            <button class="btn-base btn-estimate" id="startMeasBtn" onclick="runMeasurementSequence()">
                æ¸¬å®šé–‹å§‹
            </button>
        </div>
        
        <div id="measureStatus" class="status-msg ready">Ready - ãƒ‡ãƒã‚¤ã‚¹ã‚’é¸æŠã—ã¦æ¸¬å®šé–‹å§‹ã—ã¦ãã ã•ã„</div>

        <!-- ========================================
             æ¸¬å®šé€²æ—ãƒãƒ¼ï¼ˆRev 18.11 æ–°è¦è¿½åŠ ï¼‰
             #measureStatus ã®ç›´ä¸‹ã«é…ç½®
             ======================================== -->
        <div id="measureProgress" class="measure-progress" style="display:none;">
            <div class="measure-progress-header">
                <span id="progressLabel" class="measure-progress-label">æº–å‚™ä¸­...</span>
                <span id="progressCount" class="measure-progress-count">0 / 18</span>
            </div>
            <div class="measure-progress-bar-track">
                <div id="progressBar" class="measure-progress-bar-fill"></div>
            </div>
            <div id="progressTime" class="measure-progress-time">æ®‹ã‚Šç´„ 93 ç§’</div>
        </div>
        <!-- ======================================== -->
        
        <div id="snrIndicator" class="snr-indicator" style="display:none;">
            <label style="font-size:0.7rem; color:var(--dim);">ä¿¡å·å¯¾é›‘éŸ³æ¯” (S/N Ratio)</label>
            <div class="snr-bar">
                <div id="snrValue" class="snr-value" style="width:0%;"></div>
            </div>
        </div>
        
        <div id="recordingAlert" class="recording-flash">
            <div class="flash-icon">ğŸ”´</div>
            <div class="flash-text">ğŸ“¢ æ¸¬å®šä¸­ã§ã™ - é™ã‹ã«ã—ã¦ãã ã•ã„</div>
        </div>
        
        <div id="remeasureWarning" class="warning-box" style="display:none;">
            <strong>âš ï¸ ãƒ‡ãƒ¼ã‚¿å“è³ªãŒä¸è¶³ã—ã¦ã„ã¾ã™</strong>
            <div id="warningReason"></div>
            <button onclick="runMeasurementSequence()">å†æ¸¬å®šã‚’å®Ÿè¡Œ</button>
        </div>
        
        <div id="manualInputPanel" style="display:none; margin-top:15px; padding:12px; background:rgba(0,0,0,0.2); border-radius:6px;">
            <label style="font-size:0.7rem; color:var(--warning); font-weight:bold;">
                æ‰‹å‹•å…¥åŠ›ãƒ¢ãƒ¼ãƒ‰ï¼ˆæ¸¬å®šå€¤ã‚’ç›´æ¥å…¥åŠ›ï¼‰
            </label>
            <div style="display: grid; grid-template-columns: repeat(6, 1fr); gap: 5px; margin-top: 8px;">
                <div><label>125Hz</label><input type="number" id="m125" value="0.80" step="0.01" style="height:28px; font-size:0.7rem; text-align:center;" oninput="calculate()"></div>
                <div><label>250Hz</label><input type="number" id="m250" value="0.70" step="0.01" style="height:28px; font-size:0.7rem; text-align:center;" oninput="calculate()"></div>
                <div><label>500Hz</label><input type="number" id="m500" value="0.60" step="0.01" style="height:28px; font-size:0.7rem; text-align:center;" oninput="calculate()"></div>
                <div><label>1kHz</label><input type="number" id="m1k" value="0.60" step="0.01" style="height:28px; font-size:0.7rem; text-align:center;" oninput="calculate()"></div>
                <div><label>2kHz</label><input type="number" id="m2k" value="0.50" step="0.01" style="height:28px; font-size:0.7rem; text-align:center;" oninput="calculate()"></div>
                <div><label>4kHz</label><input type="number" id="m4k" value="0.50" step="0.01" style="height:28px; font-size:0.7rem; text-align:center;" oninput="calculate()"></div>
            </div>
            <div style="font-size:0.65rem; color:var(--dim); margin-top:8px;">
                â€» è‡ªå‹•æ¸¬å®šãŒåˆ©ç”¨ã§ããªã„å ´åˆã€å¤–éƒ¨æ¸¬å®šå™¨ã§å–å¾—ã—ãŸæ®‹éŸ¿æ™‚é–“ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„
            </div>
        </div>
    </div>

    <div class="section-title">1. åŸºæœ¬ç’°å¢ƒè¨­å®š</div>
    <div class="grid-3">
        <div>
            <label>åˆ©ç”¨ç›®çš„ (ç›®æ¨™å€¤)</label>
            <select id="appTarget"></select>
        </div>
        <div>
            <label>éƒ¨å±‹ã‚µã‚¤ã‚º W / D / H [m]</label>
            <div style="display:flex; gap:4px;">
                <input type="number" id="w" value="4.0" step="0.1">
                <input type="number" id="d" value="6.0" step="0.1">
                <input type="number" id="h" value="2.6" step="0.1">
            </div>
        </div>
        <div>
            <label>å£é¢ä»•ä¸Šã’ (ãƒ™ãƒ¼ã‚¹)</label>
            <select id="baseWall"></select>
        </div>
    </div>
    <div class="grid-3">
        <div><label>å¤©äº•ä»•ä¸Šã’</label><select id="baseCeiling"></select></div>
        <div><label>åºŠä»•ä¸Šã’</label><select id="baseFloor"></select></div>
        <div style="display:flex; align-items:flex-end; padding-bottom:5px;">
            <input type="checkbox" id="showSpecial" style="width:16px; margin-right:8px;">
            <label for="showSpecial" style="margin:0; cursor:pointer; color:var(--accent);">é–‹å£éƒ¨(çª“ç­‰)ã‚’è€ƒæ…®ã™ã‚‹</label>
        </div>
    </div>

    <div id="specialPanel" style="display:none; background: rgba(56, 139, 253, 0.05); padding: 12px; border-radius: 6px; margin-bottom: 10px; border: 1px dashed var(--accent);">
        <div class="grid-3" style="grid-template-columns: 2fr 1fr 1fr;">
            <div><label>è¿½åŠ ç´ æ</label><select id="exMat"></select></div>
            <div><label>é¢ç© [ã¡]</label><input type="number" id="exArea" value="2.0" step="0.1"></div>
        </div>
    </div>

    <div class="section-title">2. è£½å“ã‚»ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³</div>
    <div id="sbInputs"></div>

    <div class="res-panel">
        <div class="res-card">
            <label style="font-size:0.6rem">å¹³å‡æ®‹éŸ¿æ™‚é–“ (500Hz-1kHz)</label>
            <div id="postRT_Avg" class="res-val">-</div>
            <div id="targetLabel" style="font-size:0.6rem; color:var(--dim)">ç›®æ¨™: -</div>
            <div id="calcMethod" style="font-size:0.55rem; color:var(--dim); margin-top:3px;">
                <span class="calc-badge" id="methodBadge">SABINE</span>
            </div>
        </div>
        <div class="res-card" id="cardHealth">
            <label style="font-size:0.6rem">å®Ÿç”¨æ€§è©•ä¾¡</label>
            <div id="achievementRate" class="res-val">-</div>
            <div id="healthStatus" style="font-size:0.65rem; font-weight:bold;">-</div>
        </div>
        <div class="res-card">
            <label style="font-size:0.6rem">å°å…¥é¢ç© / æ‹¡æ•£å¯„ä¸åº¦</label>
            <div id="totalPanelArea" class="res-val" style="font-size:1.1rem;">-</div>
            <div id="diffusionBalance" style="font-size:0.65rem; color:var(--primary)">-</div>
        </div>
    </div>

    <div class="chart-wrapper"><canvas id="rtChart"></canvas></div>

    <div class="footer-note">
        <div id="adviceHeader" class="advice-tag"></div>
        <div id="detailedNote" style="font-size:0.75rem;"></div>
    </div>

    <div id="print-only-notice">
        <strong>ã€ã”æ¡ˆå†…ã€‘</strong><br>
        æœ¬ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³çµæœã¯ã€å…¥åŠ›ã•ã‚ŒãŸæ¡ä»¶ä¸‹ã«ãŠã‘ã‚‹ã‚»ãƒ¼ãƒ“ãƒ³å¼ã«åŸºã¥ã„ãŸè¨ˆç®—ç›®å®‰ã§ã‚ã‚Šã€å®Ÿéš›ã®æ–½å·¥ç¾å ´ã®ç’°å¢ƒï¼ˆå®¶å…·ã®é…ç½®ã€ä¸‹åœ°ã®æ§‹é€ ã€æ¸©æ¹¿åº¦ç­‰ï¼‰ã«ã‚ˆã‚Šå¤‰å‹•ã™ã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚<br>
        ã‚ˆã‚Šé«˜åº¦ãªè©³ç´°è§£æã‚„ã€ãƒ‘ãƒãƒ«ã®å…·ä½“çš„ãªé…ç½®è¨ˆç”»ï¼ˆåå°„éŸ³åˆ†å¸ƒã®æœ€é©åŒ–ãªã©ï¼‰ã‚’ã”å¸Œæœ›ã®å ´åˆã¯ã€<strong>AFMG EASE</strong> ã«ã‚ˆã‚‹ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã€ã¾ãŸã¯å¼Šç¤¾å°‚é–€ã‚¹ã‚¿ãƒƒãƒ•ã¾ã§ãŠå•ã„åˆã‚ã›ãã ã•ã„ã€‚
    </div>
</div>

<script>
const SOUNDBOX_DB = {
    apps: [
        { id: "office", name: "ã‚ªãƒ•ã‚£ã‚¹ / ä¸€èˆ¬ä¼šè­°å®¤ (0.6s)", t: 0.6 },
        { id: "web_mtg", name: "Webä¼šè­°å®¤ / ã‚ªãƒ³ãƒ©ã‚¤ãƒ³MTG (0.4s)", t: 0.4 },
        { id: "studio", name: "ãƒ¬ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚¹ã‚¿ã‚¸ã‚ª (0.4s)", t: 0.4 },
        { id: "audio", name: "ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªãƒ«ãƒ¼ãƒ  / ãƒ›ãƒ¼ãƒ ã‚·ã‚¢ã‚¿ãƒ¼ (0.45s)", t: 0.45 },
        { id: "living", name: "ãƒªãƒ“ãƒ³ã‚° / ä¸€èˆ¬ä½å®… (0.5s)", t: 0.5 },
        { id: "broadcast", name: "é…ä¿¡ã‚¹ã‚¿ã‚¸ã‚ª / ãƒãƒƒãƒ‰ã‚­ãƒ£ã‚¹ãƒˆ (0.35s)", t: 0.35 },
        { id: "classroom", name: "æ•™å®¤ / ã‚»ãƒŸãƒŠãƒ¼ãƒ«ãƒ¼ãƒ  (0.7s)", t: 0.7 },
        { id: "hall", name: "å¤šç›®çš„ãƒ›ãƒ¼ãƒ« / ä½“è‚²é¤¨ (1.2s)", t: 1.2 }
    ],
    materials: {
        "plasterboard": { name: "çŸ³è†ãƒœãƒ¼ãƒ‰ + å£ç´™", data: [0.29, 0.10, 0.05, 0.04, 0.07, 0.09] },
        "concrete": { name: "ã‚³ãƒ³ã‚¯ãƒªãƒ¼ãƒˆæ‰“æ”¾ã—", data: [0.01, 0.01, 0.01, 0.02, 0.02, 0.03] },
        "glass": { name: "ã‚¬ãƒ©ã‚¹çª“ / é¡", data: [0.35, 0.25, 0.18, 0.12, 0.07, 0.04] },
        "carpet": { name: "ã‚¿ã‚¤ãƒ«ã‚«ãƒ¼ãƒšãƒƒãƒˆ", data: [0.02, 0.05, 0.10, 0.20, 0.30, 0.40] },
        "wood": { name: "ãƒ•ãƒ­ãƒ¼ãƒªãƒ³ã‚° / æœ¨æ¿", data: [0.15, 0.11, 0.10, 0.07, 0.06, 0.07] },
        "curtain": { name: "ã‚«ãƒ¼ãƒ†ãƒ³ (é‡ç›®/ãƒ—ãƒªãƒ¼ãƒ„æœ‰)", data: [0.07, 0.31, 0.49, 0.75, 0.70, 0.60] },
        "gw_insulation": { name: "ã‚°ãƒ©ã‚¹ã‚¦ãƒ¼ãƒ«æ–­ç†±æ (50mm/32k)", data: [0.25, 0.65, 0.95, 0.98, 0.95, 0.90] }
    },
    products: {
        "STANDARD": {
            name: "1. ã‚¹ã‚¿ãƒ³ãƒ€ãƒ¼ãƒ‰ãƒ‘ãƒãƒ« (EQ Series)",
            models: {
                "STD": { n: "EQ Standard", d: { "30": [0.20, 0.50, 0.95, 1.05, 1.05, 1.00], "60": [0.30, 0.80, 1.10, 1.10, 1.00, 1.00], "120": [0.50, 0.95, 1.10, 1.05, 1.00, 0.95] }, s: { "6x6": 0.36, "6x12": 0.72 } },
                "R": { n: "EQ R (Rococo)", d: { "30": [0.25, 0.55, 0.98, 1.08, 1.07, 1.02], "60": [0.35, 0.85, 1.12, 1.12, 1.02, 1.02], "120": [0.55, 0.98, 1.12, 1.08, 1.02, 0.98] }, s: { "6x6": 0.36, "6x12": 0.72 } },
                "B": { n: "EQ B (Baroque)", d: { "30": [0.22, 0.52, 0.96, 1.06, 1.06, 1.01], "60": [0.32, 0.82, 1.11, 1.11, 1.01, 1.01], "120": [0.52, 0.96, 1.11, 1.06, 1.01, 0.96] }, s: { "6x6": 0.36, "6x12": 0.72 } },
                "F": { n: "EQ Fabric", d: { "30": [0.18, 0.48, 0.93, 1.03, 1.03, 0.98], "60": [0.28, 0.78, 1.08, 1.08, 0.98, 0.98] }, s: { "6x6": 0.36, "6x12": 0.72 } }
            }
        },
        "OFFICE_FABRIC": {
            name: "2. ã‚ªãƒ•ã‚£ã‚¹ç”¨ãƒ•ã‚¡ãƒ–ãƒªãƒƒã‚¯ (Walleasear)",
            models: {
                "EQ30T": { n: "EQ 30T (å¤§é¢ç©æ–½å·¥)", d: { "30": [0.19, 0.49, 0.94, 1.04, 1.04, 0.99] }, s: { "12x6": 0.72, "24x6": 1.44 } },
                "EQ60T": { n: "EQ 60T (å¤§é¢ç©æ–½å·¥)", d: { "60": [0.29, 0.79, 1.09, 1.09, 0.99, 0.99] }, s: { "12x6": 0.72, "24x6": 1.44 } },
                "EQ100T": { n: "EQ 100T (å¤§é¢ç©æ–½å·¥)", d: { "100": [0.45, 0.92, 1.10, 1.07, 1.00, 0.96] }, s: { "12x6": 0.72, "24x6": 1.44 } }
            }
        },
        "ENGINEERING": {
            name: "3. ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ãƒªãƒ³ã‚°è£½å“",
            models: {
                "MT_BAFFLE": { n: "MT Baffle (å¤©äº•åŠä¸‹ã’)", d: { "40": [0.42, 0.78, 0.95, 0.98, 0.98, 0.96] }, s: { "6x4": 0.24, "12x4": 0.48 } },
                "CM": { n: "CM Series (ã‚¯ãƒ©ã‚¦ãƒ‰/å¤©äº•ç”¨)", d: { "30": [0.21, 0.53, 0.88, 0.96, 0.98, 0.94], "60": [0.38, 0.84, 1.05, 1.08, 1.02, 0.98] }, s: { "6x6": 0.36 } },
                "IMAGINE": { n: "Imagine Panel (æ„åŒ ãƒ‘ãƒãƒ«)", d: { "30": [0.17, 0.46, 0.91, 1.02, 1.03, 0.97] }, s: { "6x6": 0.36 } }
            }
        },
        "BROADBAND": {
            name: "4. ãƒ–ãƒ­ãƒ¼ãƒ‰ãƒãƒ³ãƒ‰å¸éŸ³æ",
            models: {
                "F300H": { n: "F300H (é«˜åŸŸç‰¹åŒ–)", d: { "30": [0.10, 0.35, 0.70, 0.95, 1.08, 1.05] }, s: { "3x3": 0.09 } },
                "F300M": { n: "F300M (ä¸­åŸŸç‰¹åŒ–)", d: { "30": [0.15, 0.55, 0.98, 1.05, 0.95, 0.85] }, s: { "3x3": 0.09 } },
                "F300W": { n: "F300W (ä½åŸŸç‰¹åŒ–)", d: { "30": [0.35, 0.75, 0.95, 0.90, 0.80, 0.70] }, s: { "3x3": 0.09 } }
            }
        },
        "BASSTRAP": {
            name: "5. ãƒ™ãƒ¼ã‚¹ãƒˆãƒ©ãƒƒãƒ— (ä½åŸŸåˆ¶å¾¡)",
            models: {
                "C300W": { n: "C300W (ã‚³ãƒ¼ãƒŠãƒ¼ç”¨)", d: { "300": [0.65, 0.95, 1.05, 1.00, 0.92, 0.85] }, s: { "3x3": 0.09 } },
                "CYLINDER350": { n: "Cylinder 350 (å††ç­’å‹)", d: { "350": [0.70, 0.98, 1.08, 1.02, 0.94, 0.88] }, s: { "custom": 0.12 } }
            }
        },
        "DIFFUSION": {
            name: "6. æ‹¡æ•£ãƒ‘ãƒãƒ« (éŸ¿ãã®èª¿æ•´)",
            models: {
                "CLOUD2C": { n: "Cloud 2C (å¹³é¢æ‹¡æ•£)", d: { "70": [0.05, 0.10, 0.15, 0.12, 0.10, 0.08] }, s: { "6x6": 0.36 }, diffusion: 0.7 },
                "CLOUD2D": { n: "Cloud 2D (å‡¹å‡¸æ‹¡æ•£)", d: { "70": [0.08, 0.15, 0.22, 0.18, 0.15, 0.12] }, s: { "6x6": 0.36 }, diffusion: 0.85 },
                "PEAK_SQ": { n: "Peak SQ (ã‚¹ã‚«ã‚¤ãƒ©ã‚¤ãƒ³)", d: { "80": [0.10, 0.18, 0.25, 0.20, 0.18, 0.15] }, s: { "6x6": 0.36 }, diffusion: 0.9 },
                "QRD_N29": { n: "QRD N29 (äºŒæ¬¡å…ƒæ‹¡æ•£)", d: { "100": [0.12, 0.20, 0.28, 0.25, 0.22, 0.18] }, s: { "6x6": 0.36 }, diffusion: 0.95 }
            }
        },
        "HYBRID": {
            name: "7. ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰ (å¸éŸ³+æ‹¡æ•£)",
            models: {
                "AQ1000S": { n: "AQ 1000S", d: { "50": [0.25, 0.60, 0.85, 0.88, 0.82, 0.75] }, s: { "6x6": 0.36 }, diffusion: 0.4 },
                "WAVE600": { n: "WAVE 600", d: { "60": [0.30, 0.68, 0.92, 0.95, 0.88, 0.80] }, s: { "6x6": 0.36 }, diffusion: 0.5 },
                "BREEZE": { n: "Breeze (æ„åŒ æ€§ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰)", d: { "40": [0.20, 0.55, 0.88, 0.92, 0.85, 0.78] }, s: { "6x6": 0.36 }, diffusion: 0.35 }
            }
        }
    }
};

const FREQS = [125, 250, 500, 1000, 2000, 4000];
let chart;
let selectedSpecs = [{}, {}, {}];
let lastData = {};
let currentMode = 'sim';
let measurementData = null;
let roomSizeBuffer = { w: 4.0, d: 6.0, h: 2.6 }; // éƒ¨å±‹ã‚µã‚¤ã‚ºã®ãƒãƒƒãƒ•ã‚¡
let measurementActive = false; // æ¸¬å®šå€¤ä½¿ç”¨ä¸­ãƒ•ãƒ©ã‚°
const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent); // iOSåˆ¤å®š

// SNRãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«å®šç¾©ï¼ˆ3æ®µéšï¼‰
const SNR_PROFILES = {
    low: {
        label: 'ä½ï¼ˆå†…è”µãƒ‡ãƒã‚¤ã‚¹å‘ã‘ï¼‰',
        threshold: 8,          // SNRé–¾å€¤ [dB]
        description: 'ã‚¹ãƒãƒ›/PCå†…è”µã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼ãƒ»ãƒã‚¤ã‚¯',
        warning: 'ç²¾åº¦ã¯ä½ä¸‹ã—ã¾ã™ãŒã€ç°¡æ˜“æ¸¬å®šãŒå¯èƒ½ã§ã™',
        skipBands: [0, 1, 2],  // 100, 125, 160Hz ã‚’æ¸¬å®šå¯¾è±¡å¤–ï¼ˆå†…è”µSPã®ç‰©ç†é™ç•Œï¼‰
        totalBands: 15,        // 18 - 3 = 15ãƒãƒ³ãƒ‰æ¸¬å®š
        minValidOctaves: 4     // 5ã‚ªã‚¯ã‚¿ãƒ¼ãƒ–ï¼ˆ250Hzã€œ4kHzï¼‰ä¸­4ä»¥ä¸Šã§æœ‰åŠ¹
    },
    medium: {
        label: 'ä¸­ï¼ˆBluetooth/å°å‹ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼ï¼‰',
        threshold: 15,         // dB
        description: 'Bluetoothã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼ã€å°å‹å¤–éƒ¨ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼',
        warning: 'ä¸€èˆ¬çš„ãªéŸ³éŸ¿æ¸¬å®šã«é©ã—ã¦ã„ã¾ã™',
        skipBands: [],         // å…¨18ãƒãƒ³ãƒ‰æ¸¬å®šï¼ˆ125Hzå¤±æ•—æ™‚ã¯Sabineè£œå®Œï¼‰
        totalBands: 18,
        minValidOctaves: 4     // 6ã‚ªã‚¯ã‚¿ãƒ¼ãƒ–ä¸­4ä»¥ä¸Š
    },
    high: {
        label: 'é«˜ï¼ˆISOæº–æ‹ ãƒ»ãƒ—ãƒ­æ¸¬å®šï¼‰',
        threshold: 25,         // dB
        description: 'å°‚ç”¨æ¸¬å®šæ©Ÿå™¨ã€å¤§å‹ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼ã‚·ã‚¹ãƒ†ãƒ ',
        warning: 'ISO 3382æº–æ‹ ã®é«˜ç²¾åº¦æ¸¬å®š',
        skipBands: [],         // å…¨18ãƒãƒ³ãƒ‰æ¸¬å®š
        totalBands: 18,
        minValidOctaves: 5     // 6ã‚ªã‚¯ã‚¿ãƒ¼ãƒ–ä¸­5ä»¥ä¸Šï¼ˆé«˜ç²¾åº¦è¦ä»¶ï¼‰
    }
};

let currentSNRProfile = 'medium'; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ

function init() {
    const appSelect = document.getElementById('appTarget');
    SOUNDBOX_DB.apps.forEach((app, idx) => {
        const option = document.createElement('option');
        option.value = idx;
        option.textContent = app.name;
        appSelect.appendChild(option);
    });

    const materialSelects = ['baseWall', 'baseCeiling', 'baseFloor', 'exMat'];
    materialSelects.forEach(selectId => {
        const select = document.getElementById(selectId);
        for (let key in SOUNDBOX_DB.materials) {
            const option = document.createElement('option');
            option.value = key;
            option.textContent = SOUNDBOX_DB.materials[key].name;
            select.appendChild(option);
        }
    });

    const sbInputsContainer = document.getElementById('sbInputs');
    sbInputsContainer.innerHTML = '';
    for (let i = 0; i < 3; i++) {
        const row = document.createElement('div');
        row.className = 'grid-row';
        row.innerHTML = `
            <div><label>ã‚«ãƒ†ã‚´ãƒªãƒ¼</label><select id="cat_${i}" onchange="onCategoryChange(${i})"></select></div>
            <div class="custom-select-container">
                <div class="custom-select-trigger" id="trigger_${i}" onclick="togglePanel(${i})">è£½å“ã‚¹ãƒšãƒƒã‚¯ã‚’é¸æŠ...</div>
                <div class="sub-panel" id="panel_${i}">
                    <div class="panel-cols">
                        <div id="col_model_${i}"></div>
                        <div id="col_thick_${i}"></div>
                        <div id="col_size_${i}"></div>
                    </div>
                </div>
            </div>
            <input type="number" id="qty_${i}" value="0" min="0" step="1" oninput="calculate()">
            <div id="unitArea_${i}" style="font-size:0.65rem; color:var(--dim); text-align:center;">-</div>
            <div id="totalArea_${i}" style="font-size:0.7rem; color:var(--primary); text-align:right; font-weight:bold;">-</div>
        `;
        sbInputsContainer.appendChild(row);

        const catSelect = document.getElementById(`cat_${i}`);
        const defaultOption = document.createElement('option');
        defaultOption.value = '';
        defaultOption.textContent = 'é¸æŠã—ã¦ãã ã•ã„...';
        catSelect.appendChild(defaultOption);
        for (let catKey in SOUNDBOX_DB.products) {
            const option = document.createElement('option');
            option.value = catKey;
            option.textContent = SOUNDBOX_DB.products[catKey].name;
            catSelect.appendChild(option);
        }
    }

    document.getElementById('appTarget').addEventListener('change', calculate);
    document.getElementById('w').addEventListener('input', calculate);
    document.getElementById('d').addEventListener('input', calculate);
    document.getElementById('h').addEventListener('input', calculate);
    document.getElementById('baseWall').addEventListener('change', calculate);
    document.getElementById('baseCeiling').addEventListener('change', calculate);
    document.getElementById('baseFloor').addEventListener('change', calculate);
    document.getElementById('exArea').addEventListener('input', calculate);
    document.getElementById('exMat').addEventListener('change', calculate);
    document.getElementById('showSpecial').addEventListener('change', function() {
        document.getElementById('specialPanel').style.display = this.checked ? 'block' : 'none';
        calculate();
    });
    calculate();
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// éƒ¨å±‹ã‚µã‚¤ã‚ºå…¥åŠ›æ¬„ã®åˆ¶å¾¡
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function saveRoomSizeToBuffer() {
    roomSizeBuffer.w = parseFloat(document.getElementById('w').value);
    roomSizeBuffer.d = parseFloat(document.getElementById('d').value);
    roomSizeBuffer.h = parseFloat(document.getElementById('h').value);
}

function restoreRoomSizeFromBuffer() {
    document.getElementById('w').value = roomSizeBuffer.w;
    document.getElementById('d').value = roomSizeBuffer.d;
    document.getElementById('h').value = roomSizeBuffer.h;
}

function disableRoomSizeInputs() {
    document.getElementById('w').disabled = true;
    document.getElementById('d').disabled = true;
    document.getElementById('h').disabled = true;
}

function enableRoomSizeInputs() {
    document.getElementById('w').disabled = false;
    document.getElementById('d').disabled = false;
    document.getElementById('h').disabled = false;
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SNRãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«æƒ…å ±æ›´æ–°
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function updateSNRProfileInfo() {
    const select = document.getElementById('snrProfile');
    const info = document.getElementById('snrProfileInfo');
    const profile = SNR_PROFILES[select.value];
    
    if (profile) {
        const skipNote = profile.skipBands.length > 0 ? 'ãƒ»125Hzå¸¯åŸŸã¯ç†è«–å€¤' : '';
        info.textContent = `${profile.description} - SNRé–¾å€¤: ${profile.threshold}dB - ${profile.totalBands}ãƒãƒ³ãƒ‰æ¸¬å®š${skipNote}`;
        currentSNRProfile = select.value;
    }
}

function setMode(mode) {
    currentMode = mode;
    const btnSim = document.getElementById('btnSim');
    const btnMeasure = document.getElementById('btnMeasure');
    
    if (mode === 'sim') {
        btnSim.classList.add('active');
        btnSim.classList.remove('measure');
        btnMeasure.classList.remove('active', 'measure');
        document.getElementById('measurementPanel').style.display = 'none';
        
        // ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒ¢ãƒ¼ãƒ‰ï¼šéƒ¨å±‹ã‚µã‚¤ã‚ºå…¥åŠ›ã‚’å¾©å…ƒãƒ»ç·¨é›†å¯èƒ½
        enableRoomSizeInputs();
        if (measurementActive) {
            restoreRoomSizeFromBuffer();
        }
        measurementActive = false;
        
    } else {
        btnSim.classList.remove('active');
        btnMeasure.classList.add('active', 'measure');
        document.getElementById('measurementPanel').style.display = 'block';
        enumerateDevices();
        
        // æ¸¬å®šãƒ¢ãƒ¼ãƒ‰ï¼šæ¸¬å®šå€¤ãŒã‚ã‚‹å ´åˆã¯ã‚°ãƒ¬ãƒ¼ã‚¢ã‚¦ãƒˆ
        if (measurementData && measurementData.length > 0) {
            disableRoomSizeInputs();
            measurementActive = true;
        } else {
            enableRoomSizeInputs();
            measurementActive = false;
        }
    }
    
    const methodBadge = document.getElementById('methodBadge');
    methodBadge.textContent = mode === 'sim' ? 'SABINE' : 'EYRING';
    methodBadge.style.background = mode === 'sim' ? 'var(--accent)' : 'var(--warning)';
    calculate();
}

async function enumerateDevices() {
    const statusEl = document.getElementById('measureStatus');
    const micSelect = document.getElementById('micSelect');
    const spkSelect = document.getElementById('spkSelect');
    
    try {
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            throw new Error('ã“ã®ãƒ–ãƒ©ã‚¦ã‚¶ã¯éŸ³å£°å…¥åŠ›ã«å¯¾å¿œã—ã¦ã„ã¾ã›ã‚“ã€‚Chrome/Edge/Firefoxã‚’ã”åˆ©ç”¨ãã ã•ã„ã€‚');
        }
        if (location.protocol !== 'https:' && location.hostname !== 'localhost') {
            throw new Error('ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ä¸Šã®ç†ç”±ã«ã‚ˆã‚Šã€HTTPSãƒšãƒ¼ã‚¸ã§ã®ã¿å‹•ä½œã—ã¾ã™ã€‚');
        }
        
        statusEl.textContent = 'ãƒã‚¤ã‚¯ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹æ¨©é™ã‚’ãƒªã‚¯ã‚¨ã‚¹ãƒˆä¸­...';
        statusEl.className = 'status-msg calibrating';
        
        // æ¨©é™å–å¾—ï¼ˆãƒ‡ãƒã‚¤ã‚¹ãƒ©ãƒ™ãƒ«ã‚’è§£æ”¾ã™ã‚‹ãŸã‚ï¼‰
        let stream;
        try {
            stream = await navigator.mediaDevices.getUserMedia({
                audio: {
                    echoCancellation: false,
                    noiseSuppression: false,
                    autoGainControl: false
                }
            });
        } catch (permError) {
            if (permError.name === 'NotAllowedError') {
                throw new Error('ãƒã‚¤ã‚¯ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ãŒæ‹’å¦ã•ã‚Œã¾ã—ãŸã€‚ãƒ–ãƒ©ã‚¦ã‚¶ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ãƒãƒ¼æ¨ªã®ã‚¢ã‚¤ã‚³ãƒ³ã‹ã‚‰ãƒã‚¤ã‚¯ã‚’è¨±å¯ã—ã¦ãã ã•ã„ã€‚');
            } else if (permError.name === 'NotFoundError') {
                throw new Error('ãƒã‚¤ã‚¯ãƒ‡ãƒã‚¤ã‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚ãƒã‚¤ã‚¯ãŒæ¥ç¶šã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèªã—ã¦ãã ã•ã„ã€‚');
            } else {
                throw new Error('ãƒã‚¤ã‚¯ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + permError.message);
            }
        }
        
        // æ¨©é™å–å¾—ç›´å¾Œã¯300mså¾…æ©Ÿï¼ˆãƒ–ãƒ©ã‚¦ã‚¶ã®ãƒ‡ãƒã‚¤ã‚¹æƒ…å ±æ›´æ–°ã‚’å¾…ã¤ï¼‰
        statusEl.textContent = 'ãƒ‡ãƒã‚¤ã‚¹ã‚’æ¤œç´¢ä¸­...';
        await new Promise(resolve => setTimeout(resolve, 300));
        
        // ãƒ‡ãƒã‚¤ã‚¹ãƒªã‚¹ãƒˆå–å¾—
        const devices = await navigator.mediaDevices.enumerateDevices();
        
        // ã‚¹ãƒˆãƒªãƒ¼ãƒ åœæ­¢
        if (stream) {
            stream.getTracks().forEach(track => track.stop());
        }
        
        // setSinkIdå¯¾å¿œãƒã‚§ãƒƒã‚¯
        const canSetSink = 'setSinkId' in HTMLAudioElement.prototype;
        
        // ãƒªã‚¹ãƒˆåˆæœŸåŒ–
        micSelect.innerHTML = '<option value="">ãƒ‡ãƒã‚¤ã‚¹ã‚’é¸æŠ...</option>';
        spkSelect.innerHTML = '<option value="">(æ—¢å®šã®å‡ºåŠ›)</option>';
        
        let micCount = 0, spkCount = 0;
        
        devices.forEach(device => {
            const option = document.createElement('option');
            option.value = device.deviceId;
            option.textContent = device.label || `${device.kind === 'audioinput' ? 'ãƒã‚¤ã‚¯' : 'ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼'} (${device.deviceId.substr(0, 8)}...)`;
            
            if (device.kind === 'audioinput') {
                micSelect.appendChild(option);
                micCount++;
            } else if (device.kind === 'audiooutput') {
                if (!canSetSink) {
                    option.disabled = true;
                    option.textContent += ' (éå¯¾å¿œ)';
                }
                spkSelect.appendChild(option);
                spkCount++;
            }
        });
        
        // çµæœè¡¨ç¤º
        if (micCount > 0) {
            let message = `âœ… ãƒ‡ãƒã‚¤ã‚¹æ¤œå‡ºå®Œäº†: ãƒã‚¤ã‚¯ ${micCount}å°ã€ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼ ${spkCount}å°`;
            if (!canSetSink) {
                message += '\nâš ï¸ ã“ã®ãƒ–ãƒ©ã‚¦ã‚¶ã¯ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼é¸æŠã«éå¯¾å¿œã§ã™ã€‚ã‚·ã‚¹ãƒ†ãƒ è¨­å®šã®æ—¢å®šãƒ‡ãƒã‚¤ã‚¹ãŒä½¿ç”¨ã•ã‚Œã¾ã™ã€‚';
            }
            statusEl.textContent = message;
            statusEl.className = 'status-msg ready';
            
            // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆé¸æŠ
            if (micSelect.options.length > 1) micSelect.selectedIndex = 1;
            if (spkSelect.options.length > 1 && canSetSink) spkSelect.selectedIndex = 1;
        } else {
            statusEl.textContent = 'âš ï¸ ãƒã‚¤ã‚¯ãƒ‡ãƒã‚¤ã‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚ãƒã‚¤ã‚¯ãŒæ¥ç¶šã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèªã—ã¦ãã ã•ã„ã€‚';
            statusEl.className = 'status-msg error';
        }
        
    } catch (error) {
        statusEl.textContent = 'âŒ ' + (error.message || 'ãƒ‡ãƒã‚¤ã‚¹ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ');
        statusEl.className = 'status-msg error';
        micSelect.innerHTML = '<option value="">ãƒ‡ãƒã‚¤ã‚¹ã‚’é¸æŠ...</option>';
        spkSelect.innerHTML = '<option value="">ãƒ‡ãƒã‚¤ã‚¹ã‚’é¸æŠ...</option>';
    }
}

function onCategoryChange(index) {
    selectedSpecs[index] = {};
    document.getElementById(`trigger_${index}`).textContent = 'è£½å“ã‚¹ãƒšãƒƒã‚¯ã‚’é¸æŠ...';
    document.getElementById(`panel_${index}`).classList.remove('active');
    document.getElementById(`unitArea_${index}`).textContent = '-';
    document.getElementById(`totalArea_${index}`).textContent = '-';
    renderPanel(index);
    calculate();
}

function togglePanel(index) {
    const panel = document.getElementById(`panel_${index}`);
    const isActive = panel.classList.contains('active');
    document.querySelectorAll('.sub-panel').forEach(p => p.classList.remove('active'));
    if (!isActive) { panel.classList.add('active'); renderPanel(index); }
}

function renderPanel(index) {
    const categoryKey = document.getElementById(`cat_${index}`).value;
    if (!categoryKey) {
        document.getElementById(`col_model_${index}`).innerHTML = '<div class="col-title">MODEL</div>';
        document.getElementById(`col_thick_${index}`).innerHTML = '<div class="col-title">THICKNESS</div>';
        document.getElementById(`col_size_${index}`).innerHTML = '<div class="col-title">SIZE</div>';
        return;
    }
    const category = SOUNDBOX_DB.products[categoryKey];
    const spec = selectedSpecs[index];
    const modelCol = document.getElementById(`col_model_${index}`);
    modelCol.innerHTML = '<div class="col-title">MODEL</div>';
    for (let modelKey in category.models) {
        const modelDiv = document.createElement('div');
        modelDiv.className = 'col-item' + (spec.model === modelKey ? ' selected' : '');
        modelDiv.textContent = category.models[modelKey].n;
        modelDiv.onclick = () => selectModel(index, categoryKey, modelKey);
        modelCol.appendChild(modelDiv);
    }
    const thickCol = document.getElementById(`col_thick_${index}`);
    thickCol.innerHTML = '<div class="col-title">THICKNESS</div>';
    if (spec.model) {
        const model = category.models[spec.model];
        for (let thickKey in model.d) {
            const thickDiv = document.createElement('div');
            thickDiv.className = 'col-item' + (spec.thick === thickKey ? ' selected' : '');
            thickDiv.textContent = thickKey + 'mm';
            thickDiv.onclick = () => selectThickness(index, categoryKey, spec.model, thickKey);
            thickCol.appendChild(thickDiv);
        }
    }
    const sizeCol = document.getElementById(`col_size_${index}`);
    sizeCol.innerHTML = '<div class="col-title">SIZE</div>';
    if (spec.model && spec.thick) {
        const model = category.models[spec.model];
        for (let sizeKey in model.s) {
            const sizeDiv = document.createElement('div');
            sizeDiv.className = 'col-item' + (spec.size === sizeKey ? ' selected' : '');
            sizeDiv.textContent = sizeKey;
            sizeDiv.onclick = () => selectSize(index, categoryKey, spec.model, spec.thick, sizeKey);
            sizeCol.appendChild(sizeDiv);
        }
    }
}

function selectModel(index, categoryKey, modelKey) { selectedSpecs[index] = { category: categoryKey, model: modelKey }; renderPanel(index); }
function selectThickness(index, categoryKey, modelKey, thickKey) { selectedSpecs[index].thick = thickKey; renderPanel(index); }
function selectSize(index, categoryKey, modelKey, thickKey, sizeKey) {
    selectedSpecs[index].size = sizeKey;
    const model = SOUNDBOX_DB.products[categoryKey].models[modelKey];
    document.getElementById(`trigger_${index}`).textContent = `${model.n} / ${thickKey}mm / ${sizeKey}`;
    document.getElementById(`unitArea_${index}`).textContent = model.s[sizeKey].toFixed(2) + 'ã¡';
    document.getElementById(`panel_${index}`).classList.remove('active');
    calculate();
}

function prepareForPrint() { window.print(); }

function calculate() {
    const w = parseFloat(document.getElementById('w').value) || 0.1;
    const d = parseFloat(document.getElementById('d').value) || 0.1;
    const h = parseFloat(document.getElementById('h').value) || 0.1;
    const V = w * d * h;
    const S_total = 2 * (w * d + d * h + h * w);
    const S_wall = 2 * (d * h + h * w);
    const S_ceiling = w * d;
    const S_floor = w * d;
    if (V <= 0 || S_total <= 0) return;
    const L_mean = (4 * V) / S_total;
    const diffusionIndicator = (L_mean * 0.12).toFixed(2);
    const appIndex = parseInt(document.getElementById('appTarget').value) || 0;
    const targetObj = SOUNDBOX_DB.apps[appIndex];
    const targetRT = targetObj.t;
    const wallMat = SOUNDBOX_DB.materials[document.getElementById('baseWall').value];
    const ceilingMat = SOUNDBOX_DB.materials[document.getElementById('baseCeiling').value];
    const floorMat = SOUNDBOX_DB.materials[document.getElementById('baseFloor').value];
    let exArea = 0, exMat = null;
    if (document.getElementById('showSpecial').checked) {
        exArea = parseFloat(document.getElementById('exArea').value) || 0;
        exMat = SOUNDBOX_DB.materials[document.getElementById('exMat').value];
    }
    const actualWallArea = Math.max(0, S_wall - exArea);
    const rt_before = [], rt_after = [];
    const m_coeffs = [0, 0, 0, 0, 0.002, 0.007];
    
    for (let i = 0; i < 6; i++) {
        let A_base = actualWallArea * wallMat.data[i] + S_ceiling * ceilingMat.data[i] + S_floor * floorMat.data[i];
        if (exArea > 0 && exMat) A_base += exArea * exMat.data[i];
        const airAbsorption = 4 * m_coeffs[i] * V;
        
        // Beforeå€¤ã®æ±ºå®š
        let rt_b;
        if (currentMode === 'measure' && measurementData && measurementData[i]) {
            // æ¸¬å®šãƒ¢ãƒ¼ãƒ‰ï¼šæ¸¬å®šå€¤ã‚’ä½¿ç”¨
            rt_b = measurementData[i];
        } else {
            // ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒ¢ãƒ¼ãƒ‰ï¼šéƒ¨å±‹ã‚µã‚¤ã‚ºã‹ã‚‰è¨ˆç®—
            rt_b = (0.161 * V) / (A_base + airAbsorption);
        }
        rt_before.push(rt_b);
        
        // ãƒ‘ãƒãƒ«å¸éŸ³åŠ›ã®è¨ˆç®—
        let A_panels = 0;
        for (let panelIdx = 0; panelIdx < 3; panelIdx++) {
            const spec = selectedSpecs[panelIdx];
            const qty = parseInt(document.getElementById(`qty_${panelIdx}`).value) || 0;
            if (spec.category && spec.model && spec.thick && spec.size && qty > 0) {
                const product = SOUNDBOX_DB.products[spec.category].models[spec.model];
                A_panels += product.s[spec.size] * qty * (product.d[spec.thick][i] - wallMat.data[i]);
            }
        }
        
        // Afterå€¤ã®è¨ˆç®—
        let rt_a;
        if (currentMode === 'measure' && measurementData && measurementData[i]) {
            // æ¸¬å®šãƒ¢ãƒ¼ãƒ‰ï¼šæ¸¬å®šå€¤ã‹ã‚‰ãƒ‘ãƒãƒ«åŠ¹æœã‚’æ¸›ç®—
            // ãƒ‘ãƒãƒ«ãªã—çŠ¶æ…‹ã®RT â†’ ãƒ‘ãƒãƒ«ã‚ã‚ŠçŠ¶æ…‹ã®RTã¸ã®å¤‰åŒ–é‡ã‚’è¨ˆç®—
            const A_total = A_base + A_panels + airAbsorption;
            const avgAlpha = Math.min(A_total / S_total, 0.999);
            const rt_with_panels = (0.161 * V) / (-S_total * Math.log(1 - avgAlpha) + airAbsorption);
            
            // ç¾çŠ¶ã®å¸éŸ³åŠ›ã‚’é€†ç®—
            const A_current = (0.161 * V) / rt_b - airAbsorption;
            // ãƒ‘ãƒãƒ«è¿½åŠ å¾Œã®å¸éŸ³åŠ›
            const A_after = A_current + A_panels;
            const avgAlpha_after = Math.min((A_after + airAbsorption) / S_total, 0.999);
            rt_a = (0.161 * V) / (-S_total * Math.log(1 - avgAlpha_after) + airAbsorption);
            rt_a = Math.max(0.1, rt_a); // æœ€å°0.1ç§’
        } else {
            // ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒ¢ãƒ¼ãƒ‰ï¼šSabineå¼
            const A_total = A_base + A_panels + airAbsorption;
            rt_a = (0.161 * V) / A_total;
        }
        rt_after.push(rt_a);
    }
    const avgRT_after = (rt_after[2] + rt_after[3]) / 2;
    const avgRT_before = (rt_before[2] + rt_before[3]) / 2;
    let totalPanelM2 = 0;
    for (let panelIdx = 0; panelIdx < 3; panelIdx++) {
        const spec = selectedSpecs[panelIdx];
        const qty = parseInt(document.getElementById(`qty_${panelIdx}`).value) || 0;
        if (spec.category && spec.model && spec.size && qty > 0) {
            const unitArea = SOUNDBOX_DB.products[spec.category].models[spec.model].s[spec.size];
            totalPanelM2 += unitArea * qty;
            document.getElementById(`totalArea_${panelIdx}`).textContent = (unitArea * qty).toFixed(2) + 'ã¡';
        } else {
            document.getElementById(`totalArea_${panelIdx}`).textContent = '-';
        }
    }
    const usableSurface = S_wall * 0.8;
    const achievementRate = (targetRT / avgRT_after) * 100;
    updateUI(rt_before, rt_after, avgRT_before, avgRT_after, targetRT, targetObj, achievementRate, totalPanelM2, usableSurface, V, diffusionIndicator);
}

function updateUI(rt_before, rt_after, avgBefore, avgAfter, targetRT, targetObj, achievementRate, totalPanelM2, usableSurface, V, diffusionIndicator) {
    document.getElementById('postRT_Avg').textContent = avgAfter.toFixed(2) + 's';
    document.getElementById('targetLabel').textContent = `ç›®æ¨™: ${targetRT}s`;
    document.getElementById('achievementRate').textContent = achievementRate.toFixed(0) + '%';
    document.getElementById('totalPanelArea').textContent = `${totalPanelM2.toFixed(1)} / ${usableSurface.toFixed(1)}ã¡`;
    document.getElementById('diffusionBalance').style.display = 'none'; // æ‹¡æ•£å¯„ä¸åº¦ã¯æœªå®Ÿè£…ã®ãŸã‚éè¡¨ç¤º
    const cardHealth = document.getElementById('cardHealth');
    const healthStatus = document.getElementById('healthStatus');
    const adviceHeader = document.getElementById('adviceHeader');
    const detailedNote = document.getElementById('detailedNote');
    let status, statusColor, adviceTagColor, adviceText;
    if (totalPanelM2 > usableSurface) {
        status = 'è¨­ç½®é™ç•Œè¶…é'; statusColor = 'var(--danger)'; adviceTagColor = '#ff7b72';
        adviceHeader.textContent = 'FAIL'; adviceHeader.style.background = adviceTagColor;
        adviceText = 'å£é¢ã®æœ‰åŠ¹é¢ç©ï¼ˆ80%ï¼‰ã‚’è¶…ãˆã‚‹ãƒ‘ãƒãƒ«ãŒé…ç½®ã•ã‚Œã¦ã„ã¾ã™ã€‚ãƒ‘ãƒãƒ«æšæ•°ã‚’æ¸›ã‚‰ã™ã‹ã€ã‚ˆã‚Šåšå‹ã®ãƒ‘ãƒãƒ«ã¸ã®å¤‰æ›´ã‚’æ¤œè¨ã—ã¦ãã ã•ã„ã€‚';
    } else if (achievementRate >= 120) {
        status = 'éŸ¿ããŒå°‘ãªã„'; statusColor = 'var(--caution)'; adviceTagColor = '#f0883e';
        adviceHeader.textContent = 'OVER'; adviceHeader.style.background = adviceTagColor;
        adviceText = 'ç©ºé–“ãŒãƒ‡ãƒƒãƒ‰éãã‚‹å‚¾å‘ã«ã‚ã‚Šã¾ã™ã€‚æ‹¡æ•£ãƒ‘ãƒãƒ«ã‚’æ´»ç”¨ã—ã¦ãã ã•ã„ã€‚';
    } else if (achievementRate >= 100) {
        status = 'ç†æƒ³çš„'; statusColor = 'var(--success)'; adviceTagColor = '#39d353';
        adviceHeader.textContent = 'IDEAL'; adviceHeader.style.background = adviceTagColor;
        adviceText = 'ç†æƒ³çš„ãªæ•°å€¤ã§ã™ã€‚ç›®æ¨™ã®æ®‹éŸ¿æ™‚é–“ã‚’é”æˆã—ã¦ã„ã¾ã™ã€‚';
    } else if (achievementRate >= 80) {
        status = 'å®Ÿç”¨ãƒ¬ãƒ™ãƒ«'; statusColor = 'var(--accent)'; adviceTagColor = '#388bfd';
        adviceHeader.textContent = 'GOOD'; adviceHeader.style.background = adviceTagColor;
        adviceText = 'å®Ÿç”¨ä¸Šååˆ†ãªå°å…¥åŠ¹æœã§ã™ã€‚ä½åŸŸã®åˆ¶å¾¡ã«ã¯åšå‹ã‚’æ¤œè¨ã—ã¦ãã ã•ã„ã€‚';
    } else {
        status = 'å¸éŸ³ä¸è¶³'; statusColor = 'var(--danger)'; adviceTagColor = '#ff7b72';
        adviceHeader.textContent = 'UNDER'; adviceHeader.style.background = adviceTagColor;
        adviceText = 'ç›®æ¨™æ®‹éŸ¿æ™‚é–“ã«é”ã—ã¦ã„ã¾ã›ã‚“ã€‚ãƒ‘ãƒãƒ«å¢—è¨­ã‚’æ¨å¥¨ã—ã¾ã™ã€‚';
    }
    healthStatus.textContent = status;
    healthStatus.style.color = statusColor;
    cardHealth.style.borderColor = statusColor;
    if (V < 30) {
        adviceText += '<br><br><strong style="color:#ffb86c;">âš ï¸ Small Room Analysis</strong><br>æœ¬ç©ºé–“ã¯å®¹ç©ãŒå°ã•ã„ãŸã‚ã€è¨ˆç®—ä¸Šã®æ•°å€¤ã‚ˆã‚Šã‚‚ã€å¹³è¡Œé¢ã§ç™ºç”Ÿã™ã‚‹å®šåœ¨æ³¢ï¼ˆãƒ–ãƒ¼ãƒŸãƒ³ã‚°ï¼‰ã®æŠ‘åˆ¶ãŒé‡è¦ã§ã™ã€‚å£é¢ã®ä¸­å¤®ã ã‘ã§ãªãã€å…¥éš…ï¼ˆã‚³ãƒ¼ãƒŠãƒ¼ï¼‰ã¸ã®å¸éŸ³æé…ç½®ã‚’å„ªå…ˆã™ã‚‹ã“ã¨ã§ã€ä½åŸŸã®ã‚¨ãƒãƒ«ã‚®ãƒ¼ã‚’åŠ¹ç‡çš„ã«å‡¦ç†ã§ãã¾ã™ã€‚';
    }
    if (rt_after[0] > avgAfter * 1.5) {
        adviceText += '<br><br><strong style="color:#ffb86c;">âš ï¸ 125Hz ä½åŸŸæ®‹éŸ¿è­¦å‘Š</strong><br>125Hzã®æ®‹éŸ¿æ™‚é–“ãŒçªå‡ºã—ã¦ã„ã¾ã™ã€‚ä½åŸŸã®åˆ¶å¾¡ã«ã¯120mmåšã®ãƒ‘ãƒãƒ«ã€ã¾ãŸã¯ã‚³ãƒ¼ãƒŠãƒ¼é…ç½®ã®ãƒ™ãƒ¼ã‚¹ãƒˆãƒ©ãƒƒãƒ—ã‚’æ¨å¥¨ã—ã¾ã™ã€‚';
    }
    detailedNote.innerHTML = adviceText;
    updateChart(rt_before, rt_after, targetRT);
    lastData = { rt_after: avgAfter, rt_before: avgBefore, targetRT, achievementRate, totalPanelM2, V, status };
}

window.addEventListener('DOMContentLoaded', init);
</script>

<script>
// ========================================
// Web Worker: 1/3ã‚ªã‚¯ã‚¿ãƒ¼ãƒ–å¸¯åŸŸè§£æã‚¨ãƒ³ã‚¸ãƒ³ï¼ˆRev 18.11 Part 4ï¼‰
// å‡¦ç†ãƒ•ãƒ­ãƒ¼: IRæŠ½å‡º â†’ BPF â†’ SNR â†’ ã‚·ãƒ¥ãƒ¬ãƒ¼ãƒ€ãƒ¼ç©åˆ† â†’ RTè¨ˆç®—
// ========================================
const workerCode = `
'use strict';

// INITå—ä¿¡ã§è¨­å®šã‚’ä¿æŒ
let _fs  = 48000;
let _cfg = null;
let _noiseFloor = null; // ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³çµæœï¼ˆ18ãƒãƒ³ãƒ‰ï¼‰
let _latencyOffset = null; // ãƒ¬ã‚¤ãƒ†ãƒ³ã‚·ãƒ¼ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³çµæœï¼ˆã‚µãƒ³ãƒ—ãƒ«æ•°ï¼‰

self.onmessage = function(e) {
    const msg = e.data;
    if (msg.type === 'INIT') {
        _fs  = msg.sampleRate;
        _cfg = msg.config;
        return;
    }
    if (msg.type === 'SET_LATENCY') {
        _latencyOffset = msg.latencyOffset;
        console.log('### Worker: ãƒ¬ã‚¤ãƒ†ãƒ³ã‚·ãƒ¼ã‚ªãƒ•ã‚»ãƒƒãƒˆå—ä¿¡: ' + _latencyOffset + 'ã‚µãƒ³ãƒ—ãƒ« (' + (_latencyOffset/_fs).toFixed(3) + 's)');
        return;
    }
    if (msg.type === 'CALIBRATION') {
        // éŒ²éŸ³ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰ãƒãƒ³ãƒ‰åˆ¥ãƒã‚¤ã‚ºãƒ•ãƒ­ã‚¢ã‚’è¨ˆç®—
        const noiseRec = new Float32Array(msg.noiseRecording);
        _noiseFloor = calculateNoiseFloorFromRecording(noiseRec);
        self.postMessage({ type: 'calibrationDone' }); // å®Œäº†é€šçŸ¥
        return;
    }
    if (msg.type === 'ANALYZE_BAND') {
        analyzeBand(msg);
    }
};

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   ãƒã‚¤ã‚ºéŒ²éŸ³ã‹ã‚‰18ãƒãƒ³ãƒ‰åˆ¥ãƒã‚¤ã‚ºãƒ•ãƒ­ã‚¢ã‚’è¨ˆç®—
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function calculateNoiseFloorFromRecording(signal) {
    const bands = _cfg.bands;
    const fs    = _fs;
    const noiseFloor = new Array(bands.length);

    for (let bi = 0; bi < bands.length; bi++) {
        const fc = bands[bi];
        
        // å„ãƒãƒ³ãƒ‰ã§BPFé©ç”¨
        const sections = designButterworthBPF(fc, fs, 6, 0.05);
        const filtered = applyBiquadCascade(signal, sections);
        
        // RMSè¨ˆç®—
        let sumSq = 0;
        for (let i = 0; i < filtered.length; i++) {
            sumSq += filtered[i] * filtered[i];
        }
        noiseFloor[bi] = Math.sqrt(sumSq / filtered.length);
    }
    
    return noiseFloor;
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   Cooley-Tukey FFTï¼ˆåŸºæ•°2ãƒ»ã‚¤ãƒ³ãƒ—ãƒ¬ãƒ¼ã‚¹ï¼‰
   å‚è€ƒ: J.W.Cooley & J.W.Tukey (1965)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function nextPow2(n) {
    let p = 1;
    while (p < n) p <<= 1;
    return p;
}

function fft(re, im) {
    const N = re.length;
    // ãƒ“ãƒƒãƒˆé€†é †ä¸¦ã¹æ›¿ãˆ
    for (let i = 1, j = 0; i < N; i++) {
        let bit = N >> 1;
        for (; j & bit; bit >>= 1) j ^= bit;
        j ^= bit;
        if (i < j) {
            let t;
            t = re[i]; re[i] = re[j]; re[j] = t;
            t = im[i]; im[i] = im[j]; im[j] = t;
        }
    }
    // ãƒã‚¿ãƒ•ãƒ©ã‚¤æ¼”ç®—
    for (let len = 2; len <= N; len <<= 1) {
        const ang = -2.0 * Math.PI / len;
        const wRe = Math.cos(ang);
        const wIm = Math.sin(ang);
        for (let i = 0; i < N; i += len) {
            let uRe = 1.0, uIm = 0.0;
            const half = len >> 1;
            for (let k = 0; k < half; k++) {
                const m   = i + k + half;
                const vRe = re[m] * uRe - im[m] * uIm;
                const vIm = re[m] * uIm + im[m] * uRe;
                re[m]   = re[i + k] - vRe;
                im[m]   = im[i + k] - vIm;
                re[i+k] += vRe;
                im[i+k] += vIm;
                const nRe = uRe * wRe - uIm * wIm;
                uIm = uRe * wIm + uIm * wRe;
                uRe = nRe;
            }
        }
    }
}

function ifft(re, im) {
    const N = re.length;
    for (let i = 0; i < N; i++) im[i] = -im[i];
    fft(re, im);
    for (let i = 0; i < N; i++) {
        re[i] /=  N;
        im[i]  = -im[i] / N;
    }
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   ç›¸äº’ç›¸é–¢ã«ã‚ˆã‚‹Sweepé–‹å§‹ä½ç½®æ¤œå‡º
   Bluetoothé…å»¶ãƒ»ã‚¸ãƒƒã‚¿ãƒ¼ã«å¯¾å¿œ
   2æ®µéšã‚¹ã‚­ãƒ£ãƒ³: ç²—ã„ã‚¹ã‚­ãƒ£ãƒ³ â†’ ç´°ã‹ã„èª¿æ•´
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function findSweepStart(recorded, sweep) {
    const fs = _fs;
    
    // ãƒ¬ã‚¤ãƒ†ãƒ³ã‚·ãƒ¼ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³çµæœã‚’ä½¿ç”¨ã—ã¦æ¤œç´¢ç¯„å›²ã‚’çµã‚‹
    let searchStart, searchEnd;
    
    if (_latencyOffset !== null) {
        // ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³æ¸ˆã¿ï¼šÂ±1.0ç§’æ¤œç´¢ï¼ˆ0.5ç§’ã‹ã‚‰æ‹¡å¤§ï¼‰
        const searchMargin = Math.floor(1.0 * fs);
        searchStart = Math.max(0, _latencyOffset - searchMargin);
        searchEnd = Math.min(recorded.length - sweep.length, _latencyOffset + searchMargin);
        
        self.postMessage({ 
            type: 'debug', 
            message: 'Search range (calibrated): ' + (searchStart/fs).toFixed(3) + 's - ' + (searchEnd/fs).toFixed(3) + 's (Â±1.0s around ' + (_latencyOffset/fs).toFixed(3) + 's)'
        });
    } else {
        // ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãªã—ï¼šå¾“æ¥ã®åºƒç¯„å›²æ¤œç´¢
        searchStart = Math.floor(0.2 * fs); // 200msã‚¹ã‚­ãƒƒãƒ—
        searchEnd = Math.min(Math.floor(2.5 * fs), recorded.length - sweep.length);
        
        self.postMessage({ 
            type: 'debug', 
            message: 'Search range (uncalibrated): ' + (searchStart/fs).toFixed(3) + 's - ' + (searchEnd/fs).toFixed(3) + 's'
        });
    }
    
    if (searchEnd <= searchStart) {
        self.postMessage({ 
            type: 'debug', 
            message: 'Warning: Invalid search range, using fallback'
        });
        return Math.floor(0.5 * fs);
    }
    
    // Check length: first 0.2s of sweep
    const checkLength = Math.min(Math.floor(0.2 * fs), sweep.length);
    
    // Step 1: Coarse scan (100-sample steps)
    let maxCorr = -Infinity;
    let bestOffset = searchStart;
    
    for (let offset = searchStart; offset < searchEnd; offset += 100) {
        let corr = 0;
        for (let i = 0; i < checkLength; i++) {
            corr += recorded[offset + i] * sweep[i];
        }
        if (corr > maxCorr) {
            maxCorr = corr;
            bestOffset = offset;
        }
    }
    
    // Step 2: Fine adjustment (1-sample steps within Â±100 range)
    const fineStart = Math.max(searchStart, bestOffset - 100);
    const fineEnd = Math.min(searchEnd, bestOffset + 100);
    maxCorr = -Infinity;
    
    for (let offset = fineStart; offset < fineEnd; offset++) {
        let corr = 0;
        for (let i = 0; i < checkLength; i++) {
            corr += recorded[offset + i] * sweep[i];
        }
        if (corr > maxCorr) {
            maxCorr = corr;
            bestOffset = offset;
        }
    }
    
    // Step 3: Calculate correlation confidence (normalized)
    let recEnergy = 0;
    let swpEnergy = 0;
    for (let i = 0; i < checkLength; i++) {
        recEnergy += recorded[bestOffset + i] * recorded[bestOffset + i];
        swpEnergy += sweep[i] * sweep[i];
    }
    
    const normalizedCorr = maxCorr / (Math.sqrt(recEnergy * swpEnergy) + 1e-10);
    
    // Debug log
    self.postMessage({ 
        type: 'debug', 
        message: 'Correlation: offset=' + bestOffset + ' samples (' + (bestOffset/fs).toFixed(3) + 's), confidence=' + normalizedCorr.toFixed(3)
    });
    
    if (normalizedCorr < 0.3) {
        self.postMessage({ 
            type: 'debug', 
            message: 'Warning: Low correlation confidence (' + normalizedCorr.toFixed(3) + ' < 0.3)' 
        });
    }
    
    return bestOffset;
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   é€†ç•³ã¿è¾¼ã¿ã«ã‚ˆã‚‹ã‚¤ãƒ³ãƒ‘ãƒ«ã‚¹å¿œç­”(IR)æŠ½å‡º
   H(f) = Y(f) Â· X*(f) / (|X(f)|Â² + Îµ)
   æ­£è¦åŒ–é€†ãƒ•ã‚£ãƒ«ã‚¿ï¼ˆWienerãƒ•ã‚£ãƒ«ã‚¿å½¢å¼ï¼‰
   ISO 3382-1:2009 Annex Aæº–æ‹ 
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function extractIR(recorded, sweep) {
    const N = nextPow2((recorded.length + sweep.length - 1) * 2);
    const yRe = new Float64Array(N);
    const yIm = new Float64Array(N);
    const xRe = new Float64Array(N);
    const xIm = new Float64Array(N);

    for (let i = 0; i < recorded.length; i++) yRe[i] = recorded[i];
    for (let i = 0; i < sweep.length;    i++) xRe[i] = sweep[i];

    fft(yRe, yIm);
    fft(xRe, xIm);

    // æ­£è¦åŒ–: ã‚¼ãƒ­é™¤ç®—ãƒ»ä½ã‚¨ãƒãƒ«ã‚®ãƒ¼å¸¯åŸŸã®ç™ºæ•£ã‚’é˜²æ­¢
    const eps = 1e-9;
    const hRe = new Float64Array(N);
    const hIm = new Float64Array(N);
    for (let i = 0; i < N; i++) {
        const denom = xRe[i]*xRe[i] + xIm[i]*xIm[i] + eps;
        hRe[i] = (yRe[i]*xRe[i] + yIm[i]*xIm[i]) / denom;
        hIm[i] = (yIm[i]*xRe[i] - yRe[i]*xIm[i]) / denom;
    }

    ifft(hRe, hIm);

    // å®Ÿéƒ¨ã®ã¿ï¼ˆã‚¤ãƒ³ãƒ‘ãƒ«ã‚¹å¿œç­”ï¼‰ã‚’éŒ²éŸ³é•·ã§åˆ‡ã‚Šå–ã£ã¦è¿”å´
    return new Float64Array(hRe.buffer, 0, recorded.length);
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   6æ¬¡ Butterworth BPFï¼ˆ2æ¬¡Biquad Ã— 3æ®µã‚«ã‚¹ã‚±ãƒ¼ãƒ‰ï¼‰
   ANSI S1.11 / ISO 3382æº–æ‹ 
   ã‚«ã‚¹ã‚±ãƒ¼ãƒ‰è£œæ­£: Q_sec = Q_target / sqrt(2^(1/k) - 1)
   å…¨ã‚»ã‚¯ã‚·ãƒ§ãƒ³åŒä¸€ä¿‚æ•°ï¼ˆcenter fcå…±é€šï¼‰
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function designButterworthBPF(fc, fs, order, margin) {
    const nSec = order / 2; // 6æ¬¡ â†’ 3ã‚»ã‚¯ã‚·ãƒ§ãƒ³

    // 1/3ã‚ªã‚¯ã‚¿ãƒ¼ãƒ–å¸¯åŸŸå¹…ï¼ˆ5%å†…å´ã«çµã‚‹ï¼‰
    const fL = (fc / Math.SQRT2) * (1.0 + margin);
    const fH = (fc * Math.SQRT2) * (1.0 - margin);
    const Q_target = fc / (fH - fL);

    // ã‚«ã‚¹ã‚±ãƒ¼ãƒ‰è£œæ­£: kæ®µã§æ‰€å®šã®-3dBå¸¯åŸŸå¹…ã‚’ä¿è¨¼
    const Q_sec = Q_target / Math.sqrt(Math.pow(2, 1.0 / nSec) - 1.0);

    const w0    = 2.0 * Math.PI * fc / fs;
    const alpha = Math.sin(w0) / (2.0 * Q_sec);
    const cosW0 = Math.cos(w0);
    const a0    = 1.0 + alpha;

    const sec = {
        b0:  alpha / a0,
        b1:  0.0,
        b2: -alpha / a0,
        a1: -2.0 * cosW0 / a0,
        a2: (1.0 - alpha) / a0
    };

    // 3ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã¯åŒä¸€ä¿‚æ•°
    return [{ ...sec }, { ...sec }, { ...sec }];
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   Biquadã‚«ã‚¹ã‚±ãƒ¼ãƒ‰é©ç”¨ï¼ˆæ™‚é–“åŸŸIIRãƒ•ã‚£ãƒ«ã‚¿ï¼‰
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function applyBiquadCascade(signal, sections) {
    let buf = new Float64Array(signal);
    for (const s of sections) {
        const out = new Float64Array(buf.length);
        let x1 = 0.0, x2 = 0.0, y1 = 0.0, y2 = 0.0;
        for (let i = 0; i < buf.length; i++) {
            const x0 = buf[i];
            const y0 = s.b0*x0 + s.b1*x1 + s.b2*x2
                     - s.a1*y1 - s.a2*y2;
            out[i] = y0;
            x2 = x1; x1 = x0;
            y2 = y1; y1 = y0;
        }
        buf = out;
    }
    return buf;
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   SNRè¨ˆç®—
   IRãƒ”ãƒ¼ã‚¯ä»˜è¿‘ã‚¨ãƒãƒ«ã‚®ãƒ¼ vs æœ«å°¾ãƒã‚¤ã‚ºãƒ•ãƒ­ã‚¢ã®
   ã‚¨ãƒãƒ«ã‚®ãƒ¼å¯†åº¦æ¯”ï¼ˆã‚µãƒ³ãƒ—ãƒ«æ•°æ­£è¦åŒ–ï¼‰
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   SNRè¨ˆç®—
   äº‹å‰æ¸¬å®šã—ãŸãƒã‚¤ã‚ºãƒ•ãƒ­ã‚¢ãŒã‚ã‚Œã°ãã‚Œã‚’ä½¿ç”¨
   ãªã‘ã‚Œã°IRæœ«å°¾ã‹ã‚‰æ¨å®šï¼ˆå¾“æ¥æ–¹å¼ï¼‰
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function calcSNR(ir, bandIndex) {
    const N = ir.length;

    // ãƒ”ãƒ¼ã‚¯ä½ç½®ã‚’æ¢ã™
    let peakIdx = 0, peakVal = 0;
    for (let i = 0; i < N; i++) {
        const v = Math.abs(ir[i]);
        if (v > peakVal) { peakVal = v; peakIdx = i; }
    }

    // ãƒ”ãƒ¼ã‚¯å¾Œ15%ã‚’IRå¸¯
    const irEnd   = Math.min(N, peakIdx + Math.floor(N * 0.15));
    const irCount = irEnd - peakIdx;
    if (irCount <= 0) return 60;

    let irE = 0;
    for (let i = peakIdx; i < irEnd; i++) irE += ir[i]*ir[i];
    const irRMS = Math.sqrt(irE / irCount);

    // ãƒã‚¤ã‚ºãƒ¬ãƒ™ãƒ«: ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³çµæœã‚’å„ªå…ˆ
    let noiseRMS;
    if (_noiseFloor && bandIndex >= 0 && bandIndex < _noiseFloor.length) {
        noiseRMS = _noiseFloor[bandIndex];
    } else {
        // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: IRæœ«å°¾ã‹ã‚‰æ¨å®š
        const nStart  = Math.floor(N * 0.75);
        const nCount  = N - nStart;
        if (nCount <= 0) return 60;
        let nE = 0;
        for (let i = nStart; i < N; i++) nE += ir[i]*ir[i];
        noiseRMS = Math.sqrt(nE / nCount);
    }

    if (noiseRMS < 1e-20) return 60;
    return 20.0 * Math.log10(irRMS / noiseRMS);
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   ã‚·ãƒ¥ãƒ¬ãƒ¼ãƒ€ãƒ¼ç©åˆ†ï¼ˆå¾Œé€€ç´¯ç© + å‹•çš„æ‰“ã¡åˆ‡ã‚Šï¼‰
   EDC(t) = âˆ«[tâ†’âˆ] hÂ²(Ï„)dÏ„
   æ‰“ã¡åˆ‡ã‚Š: ãƒã‚¤ã‚ºå¯†åº¦ã®3å€ã‚’ä¸‹å›ã£ãŸæ™‚ç‚¹
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function schroederIntegral(ir) {
    const N = ir.length;

    // â”€â”€ Lundebyæ³•ã«ã‚ˆã‚‹ãƒã‚¤ã‚ºå¯†åº¦ã®åå¾©æ¨å®š â”€â”€
    // Ref: Lundeby et al. (1995) "Uncertainties of measurements in room acoustics", JASA 97(3)
    // ISO 3382-2:2008 ã§ã‚‚æ¨å¥¨ã•ã‚Œã‚‹ã‚¢ãƒ—ãƒ­ãƒ¼ãƒ

    // Step 1: 10msæ™‚é–“çª“ã§RMSã‚¨ãƒãƒ«ã‚®ãƒ¼å¯†åº¦ã‚’è¨ˆç®—
    const winLen = Math.max(1, Math.round(_fs * 0.01)); // 10msçª“ï¼ˆæœ€ä½1ã‚µãƒ³ãƒ—ãƒ«ï¼‰
    const nWin   = Math.floor(N / winLen);
    if (nWin < 5) {
        // IRé•·ãŒæ¥µç«¯ã«çŸ­ã„å ´åˆã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼ˆæœ«å°¾25%ï¼‰
        const nStart = Math.floor(N * 0.75);
        let nE = 0;
        for (let i = nStart; i < N; i++) nE += ir[i] * ir[i];
        const noiseDensity = nE / (N - nStart);
        const cum = new Float64Array(N);
        cum[N - 1] = ir[N - 1] * ir[N - 1];
        for (let i = N - 2; i >= 0; i--) cum[i] = cum[i + 1] + ir[i] * ir[i];
        const peak  = cum[0] > 0 ? cum[0] : 1e-20;
        const edcDB = new Float64Array(N).fill(-999);
        let truncIdx = N - 1;
        for (let i = 0; i < N; i++) {
            if (cum[i] <= noiseDensity * (N - i) * 3.0) { truncIdx = i; break; }
            edcDB[i] = 10.0 * Math.log10(cum[i] / peak);
        }
        return { edcDB, truncIdx };
    }

    // å„çª“ã®ã‚¨ãƒãƒ«ã‚®ãƒ¼å¯†åº¦ï¼ˆ1ã‚µãƒ³ãƒ—ãƒ«ã‚ãŸã‚Šï¼‰
    const winEnergy = new Float64Array(nWin);
    for (let w = 0; w < nWin; w++) {
        let e = 0;
        for (let i = w * winLen; i < (w + 1) * winLen; i++) e += ir[i] * ir[i];
        winEnergy[w] = e / winLen;
    }

    // Step 2: æœ«å°¾10%ã‹ã‚‰ãƒã‚¤ã‚ºå¯†åº¦ã®åˆæœŸæ¨å®š
    const noiseTailStart = Math.floor(nWin * 0.90);
    let noiseSum = 0;
    for (let w = noiseTailStart; w < nWin; w++) noiseSum += winEnergy[w];
    let noiseDensity = noiseSum / (nWin - noiseTailStart);

    // Step 3: åå¾©åæŸï¼ˆæœ€å¤§5å›ï¼‰
    // ãƒ”ãƒ¼ã‚¯çª“ã‚’æ¢ã™
    let peakWin = 0;
    let peakVal = 0;
    for (let w = 0; w < nWin; w++) {
        if (winEnergy[w] > peakVal) { peakVal = winEnergy[w]; peakWin = w; }
    }

    let crossWin = nWin - 1; // EDCãŒãƒã‚¤ã‚º+10dBã‚’ä¸‹å›ã‚‹çª“ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
    for (let iter = 0; iter < 5; iter++) {
        // ãƒã‚¤ã‚ºå¯†åº¦ã®10å€ï¼ˆ+10dBï¼‰ã‚’é–¾å€¤ã¨ã™ã‚‹
        const threshold = noiseDensity * 10.0;

        // ãƒ”ãƒ¼ã‚¯çª“ä»¥é™ã§é–¾å€¤ã‚’ä¸‹å›ã‚‹æœ€åˆã®çª“ã‚’æ¢ã™
        let newCrossWin = nWin - 1;
        for (let w = peakWin; w < nWin; w++) {
            if (winEnergy[w] <= threshold) { newCrossWin = w; break; }
        }
        crossWin = newCrossWin;

        // crossWinä»¥é™ã§ãƒã‚¤ã‚ºå¯†åº¦ã‚’å†æ¨å®š
        const reNoiseStart = Math.min(crossWin + 1, nWin - 1);
        let reSum = 0;
        let reCount = nWin - reNoiseStart;
        if (reCount <= 0) break; // ãƒã‚¤ã‚ºåŒºé–“ãŒãªã„å ´åˆã¯åæŸã¨ã¿ãªã™
        for (let w = reNoiseStart; w < nWin; w++) reSum += winEnergy[w];
        const newNoiseDensity = reSum / reCount;

        // åæŸåˆ¤å®š: å¤‰åŒ–ç‡1%æœªæº€
        const change = Math.abs(newNoiseDensity - noiseDensity) / (noiseDensity + 1e-30);
        noiseDensity = newNoiseDensity;
        if (change < 0.01) break;
    }

    // truncIdx: crossWinçª“ã®ã‚µãƒ³ãƒ—ãƒ«ä½ç½®ï¼ˆæœ«ç«¯ï¼‰
    const truncIdx = Math.min(crossWin * winLen, N - 1);

    // â”€â”€ å¾Œé€€ç©åˆ†ï¼ˆSchroederç©åˆ†ï¼‰ â”€â”€
    const cum = new Float64Array(N);
    cum[N - 1] = ir[N - 1] * ir[N - 1];
    for (let i = N - 2; i >= 0; i--) cum[i] = cum[i + 1] + ir[i] * ir[i];

    // dBå¤‰æ›ï¼ˆtruncIdxã¾ã§ï¼‰
    const peak  = cum[0] > 0 ? cum[0] : 1e-20;
    const edcDB = new Float64Array(N).fill(-999);
    for (let i = 0; i < truncIdx; i++) {
        if (cum[i] > 0) edcDB[i] = 10.0 * Math.log10(cum[i] / peak);
    }

    // è¨ºæ–­ãƒ­ã‚°
    const truncSec    = (truncIdx / _fs).toFixed(3);
    const lastValidDB = edcDB[truncIdx - 1] > -999 ? edcDB[truncIdx - 1].toFixed(1) : 'N/A';
    self.postMessage({ type: 'debug',
        message: '[Lundeby] N=' + N + ' truncIdx=' + truncIdx + '(' + truncSec + 's)' +
                 ' lastValidDB=' + lastValidDB + 'dB' +
                 ' noiseDensity=' + noiseDensity.toExponential(3) +
                 ' crossWin=' + crossWin + '/' + nWin
    });

    return { edcDB, truncIdx };
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   RTè¨ˆç®—ï¼ˆæœ€å°äºŒä¹—ç·šå½¢å›å¸°ï¼‰
   T60â†’T30â†’T20 ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
   ISO 3382-2:2008 æº–æ‹ 
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function calcRT(edcDB, truncIdx, fs) {
    // T60: -5dB â†’ -65dB
    const r60 = lsqRT(edcDB, truncIdx, fs, -5, -65);
    if (r60 !== null) return { rt60: r60,       method: 'T60' };

    // T30: -5dB â†’ -35dB â†’ Ã—2å¤–æŒ¿
    const r30 = lsqRT(edcDB, truncIdx, fs, -5, -35);
    if (r30 !== null) return { rt60: r30 * 2.0, method: 'T30' };

    // T20: -5dB â†’ -25dB â†’ Ã—3å¤–æŒ¿
    const r20 = lsqRT(edcDB, truncIdx, fs, -5, -25);
    if (r20 !== null) return { rt60: r20 * 3.0, method: 'T20' };

    return null;
}

function lsqRT(edcDB, truncIdx, fs, startDB, endDB) {
    let s = -1, e = -1;
    for (let i = 0; i < truncIdx; i++) {
        if (s < 0 && edcDB[i] <= startDB) { s = i; continue; }
        if (s >= 0 && edcDB[i] <= endDB)  { e = i; break; }
    }
    if (s < 0 || e < 0 || (e - s) < 10) return null;

    let n = 0, sumX = 0, sumY = 0, sumXY = 0, sumXX = 0;
    for (let i = s; i <= e; i++) {
        const t = i / fs;
        sumX  += t;
        sumY  += edcDB[i];
        sumXY += t * edcDB[i];
        sumXX += t * t;
        n++;
    }
    const denom = n * sumXX - sumX * sumX;
    if (Math.abs(denom) < 1e-15) return null;

    const slope = (n * sumXY - sumX * sumY) / denom;
    if (slope >= 0) return null; // æ¸›è¡°ã—ã¦ã„ãªã„

    return (endDB - startDB) / slope;
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   ãƒ¡ã‚¤ãƒ³è§£æé–¢æ•°
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function analyzeBand(msg) {
    const { band, recorded, sweep } = msg;
    const fs       = _fs;
    const minSnr   = (_cfg && _cfg.analysis) ? _cfg.analysis.minSnr   : 15.0;
    const bpfOrder = (_cfg && _cfg.analysis) ? _cfg.analysis.bpfOrder :  6;
    const bpfMargin= (_cfg && _cfg.analysis) ? _cfg.analysis.bpfMargin: 0.05;

    // ãƒãƒ³ãƒ‰ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’æ±‚ã‚ã‚‹ï¼ˆãƒã‚¤ã‚ºãƒ•ãƒ­ã‚¢å‚ç…§ç”¨ï¼‰
    const bandIndex = (_cfg && _cfg.bands) ? _cfg.bands.indexOf(band) : -1;

    // ç›´æ¥console.logï¼ˆWorkerã‹ã‚‰ã§ã‚‚å‡ºåŠ›ã•ã‚Œã‚‹ï¼‰
    console.log('### Worker analyzeBand START:', band + 'Hz');
    console.log('  recorded length:', recorded.byteLength, 'bytes');
    console.log('  sweep length:', sweep.byteLength, 'bytes');
    
    // postMessageçµŒç”±ã§ã‚‚ãƒ­ã‚°
    self.postMessage({ 
        type: 'debug', 
        message: band + 'Hz analysis started: rec=' + recorded.byteLength + 'bytes, sweep=' + sweep.byteLength + 'bytes'
    });

    try {
        const recF32 = new Float32Array(recorded);
        const swpF32 = new Float32Array(sweep);
        
        console.log('### Worker: Float32Array conversion done');
        console.log('  recF32.length:', recF32.length, 'samples');
        console.log('  swpF32.length:', swpF32.length, 'samples');

        // â‘  ç›¸äº’ç›¸é–¢ã§Sweepé–‹å§‹ä½ç½®ã‚’æ¤œå‡ºï¼ˆBluetoothé…å»¶è£œæ­£ï¼‰
        console.log('### Worker: Starting findSweepStart...');
        const sweepStart = findSweepStart(recF32, swpF32);
        console.log('### Worker: findSweepStart returned:', sweepStart);
        
        // â‘¡ å¿…è¦ãªç¯„å›²ã‚’åˆ‡ã‚Šå‡ºã—
        // Sweepæœ¬ä½“ + æ®‹éŸ¿ï¼ˆ2.5ç§’ï¼‰ã‚’ç¢ºä¿
        const requiredLength = swpF32.length + Math.floor(2.5 * fs);
        const endPos = Math.min(sweepStart + requiredLength, recF32.length);
        const trimmed = recF32.slice(sweepStart, endPos);
        
        // Sweepä¿¡å·ã‚‚åŒã˜é•·ã•ã«èª¿æ•´ï¼ˆã‚¼ãƒ­ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ï¼‰
        const swpAdjusted = new Float32Array(trimmed.length);
        swpAdjusted.set(swpF32, 0);

        // â‘¢ IRæŠ½å‡ºï¼ˆé€†ç•³ã¿è¾¼ã¿ï¼‰
        console.log('### Worker: Starting extractIR...');
        const ir = extractIR(trimmed, swpAdjusted);
        console.log('### Worker: extractIR done');

        // â‘£ 6æ¬¡Butterworth BPFé©ç”¨
        console.log('### Worker: Starting BPF...');
        const sections  = designButterworthBPF(band, fs, bpfOrder, bpfMargin);
        const irFiltered = applyBiquadCascade(ir, sections);
        console.log('### Worker: BPF done');

        // â‘¤ SNRåˆ¤å®šï¼ˆã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³çµæœã‚’å„ªå…ˆåˆ©ç”¨ï¼‰
        console.log('### Worker: Calculating SNR...');
        const snr = calcSNR(irFiltered, bandIndex);
        console.log('### Worker: SNR =', snr.toFixed(1), 'dB, threshold =', minSnr, 'dB');
        
        if (snr < minSnr) {
            console.log('### Worker: SNR insufficient, sending skip result');
            self.postMessage({
                type: 'bandResult', band, rt60: null,
                snr: +snr.toFixed(1),
                reason: 'SNR ' + snr.toFixed(1) + 'dB < ' + minSnr + 'dB'
            });
            return;
        }

        // â‘¥ ã‚·ãƒ¥ãƒ¬ãƒ¼ãƒ€ãƒ¼ç©åˆ†
        const { edcDB, truncIdx } = schroederIntegral(irFiltered);

        // â‘¦ RTè¨ˆç®—
        const rtResult = calcRT(edcDB, truncIdx, fs);
        if (!rtResult) {
            self.postMessage({
                type: 'bandResult', band, rt60: null,
                snr: +snr.toFixed(1),
                reason: 'RTè¨ˆç®—å¤±æ•—ï¼ˆæ¸›è¡°ã‚«ãƒ¼ãƒ–ä¸ååˆ†ï¼‰'
            });
            return;
        }

        self.postMessage({
            type:   'bandResult',
            band,
            rt60:   +rtResult.rt60.toFixed(3),
            snr:    +snr.toFixed(1),
            method: rtResult.method
        });

    } catch (err) {
        self.postMessage({
            type: 'bandResult', band, rt60: null, snr: 0,
            reason: 'Workerå†…éƒ¨ã‚¨ãƒ©ãƒ¼: ' + err.message
        });
    }
}
`;

let measurementWorker = null;

function initWorker() {
    const blob = new Blob([workerCode], { type: 'text/javascript' });
    measurementWorker = new Worker(URL.createObjectURL(blob));
    measurementWorker.onmessage = function(e) {
        // ãƒ‡ãƒãƒƒã‚°ï¼šå…¨ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ãƒ­ã‚°
        console.log('=== Worker Message Received ===', e.data.type);
        
        if (e.data.type === 'debug') {
            // 3ã¤ã®æ–¹æ³•ã§ãƒ­ã‚°å‡ºåŠ›
            console.log('[Worker] ' + e.data.message);
            console.info('[Worker-INFO] ' + e.data.message);
            console.warn('[Worker-DEBUG] ' + e.data.message);
            return;
        }
        if (e.data.type === 'result') handleMeasurementResult(e.data);
        if (e.data.type === 'error') handleMeasurementError(e.data.message);
    };
    measurementWorker.onerror = function(err) { console.error('Worker error:', err); };
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Part 5: æ¸¬å®šçµæœãƒãƒ³ãƒ‰ãƒ©
// 18ãƒãƒ³ãƒ‰ï¼ˆ1/3octï¼‰â†’ 6ãƒãƒ³ãƒ‰ï¼ˆã‚ªã‚¯ã‚¿ãƒ¼ãƒ–ï¼‰é›†ç´„
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function handleMeasurementResult(data) {
    const statusEl   = document.getElementById('measureStatus');
    const startBtn   = document.getElementById('startMeasBtn');
    const progressEl = document.getElementById('measureProgress');
    const warnEl     = document.getElementById('remeasureWarning');

    // UIåˆæœŸåŒ–
    startBtn.disabled = false;
    progressEl.style.display = 'none';
    document.getElementById('recordingAlert').classList.remove('active');

    const thirdResults = data.thirdResults; // 18æœ¬ã®1/3ã‚ªã‚¯ã‚¿ãƒ¼ãƒ–RT60é…åˆ—
    const octaveDefs   = MEASUREMENT_CONFIG.octaveBands; // 6ã‚°ãƒ«ãƒ¼ãƒ—å®šç¾©
    const octaveResults = new Array(6).fill(null);

    let validOctaveCount = 0;
    const missingBands = [];

    const profile          = SNR_PROFILES[currentSNRProfile];
    const minValidOctaves  = profile.minValidOctaves;
    const is125HzSkipped   = profile.skipBands.includes(0); // lowãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«

    // â”€â”€ 18ãƒãƒ³ãƒ‰ â†’ 6ã‚ªã‚¯ã‚¿ãƒ¼ãƒ–ãƒãƒ³ãƒ‰ã«é›†ç´„ â”€â”€
    for (let i = 0; i < octaveDefs.length; i++) {
        const group = octaveDefs[i];
        const values = group.indices
            .map(idx => thirdResults[idx])
            .filter(v => v !== null && v > 0);

        if (values.length > 0) {
            // æœ‰åŠ¹ãª1/3octãƒãƒ³ãƒ‰ã®å¹³å‡ã‚’ã‚ªã‚¯ã‚¿ãƒ¼ãƒ–ãƒãƒ³ãƒ‰å€¤ã¨ã™ã‚‹
            octaveResults[i] = values.reduce((sum, val) => sum + val, 0) / values.length;
            validOctaveCount++;
        } else {
            // 3æœ¬ã™ã¹ã¦null â†’ ã“ã®ã‚ªã‚¯ã‚¿ãƒ¼ãƒ–ãƒãƒ³ãƒ‰ã¯æ¬ æ
            if (i === 0 && is125HzSkipped) {
                missingBands.push('125Hzï¼ˆç†è«–å€¤ï¼‰');
            } else {
                missingBands.push(group.label);
            }
        }
    }

    // â”€â”€ æœ‰åŠ¹ãƒãƒ³ãƒ‰æ•°åˆ¤å®šï¼ˆ3æ®µéšè¡¨ç¤ºï¼‰ â”€â”€
    if (validOctaveCount < minValidOctaves) {
        // ğŸ”´ å¤±æ•—
        statusEl.textContent = 'âŒ æ¸¬å®šå¤±æ•—: æœ‰åŠ¹ãƒ‡ãƒ¼ã‚¿ä¸è¶³';
        statusEl.className = 'status-msg error';

        const reasonText =
            'æ¸¬å®šã•ã‚ŒãŸæœ‰åŠ¹ãƒãƒ³ãƒ‰æ•°: ' + validOctaveCount + ' / ' + (6 - profile.skipBands.length / 3 | 0) + '\n' +
            'æœ€ä½' + minValidOctaves + 'ãƒãƒ³ãƒ‰ãŒå¿…è¦ã§ã™ãŒã€é”æˆã§ãã¾ã›ã‚“ã§ã—ãŸã€‚\n\n' +
            'æ¬ æãƒãƒ³ãƒ‰: ' + missingBands.join(', ') + '\n\n' +
            'æ”¹å–„ç­–:\n' +
            'ãƒ»ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼éŸ³é‡ã‚’ä¸Šã’ã¦ãã ã•ã„\n' +
            'ãƒ»ç’°å¢ƒãƒã‚¤ã‚ºã‚’ä¸‹ã’ã¦ãã ã•ã„\n' +
            'ãƒ»ä½åŸŸãŒå‡ºãªã„ã‚¹ãƒãƒ›ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼ã®å ´åˆã¯å¤–éƒ¨ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼ä½¿ç”¨ã‚’æ¨å¥¨';
        document.getElementById('warningReason').textContent = reasonText;
        warnEl.className = 'warning-box';
        warnEl.style.display = 'block';
        return;
    }

    // â”€â”€ æ¸¬å®šæˆåŠŸ: measurementDataã«æ ¼ç´ã—ã¦calculate()å®Ÿè¡Œ â”€â”€
    measurementData = octaveResults;
    
    // éƒ¨å±‹ã‚µã‚¤ã‚ºã‚’ãƒãƒƒãƒ•ã‚¡ã«ä¿å­˜ã—ã€å…¥åŠ›æ¬„ã‚’ã‚°ãƒ¬ãƒ¼ã‚¢ã‚¦ãƒˆ
    saveRoomSizeToBuffer();
    disableRoomSizeInputs();
    measurementActive = true;

    if (validOctaveCount === (6 - (profile.skipBands.length > 0 ? 1 : 0))) {
        // ğŸŸ¢ å®Œå…¨æˆåŠŸï¼ˆå…¨æ¸¬å®šå¯¾è±¡ãƒãƒ³ãƒ‰æˆåŠŸï¼‰
        statusEl.textContent = is125HzSkipped
            ? 'âœ… æ¸¬å®šå®Œäº†ï¼ˆå…¨æ¸¬å®šãƒãƒ³ãƒ‰æˆåŠŸãƒ»125Hzã¯ç†è«–å€¤ï¼‰'
            : 'âœ… æ¸¬å®šå®Œäº†ï¼ˆå…¨ãƒãƒ³ãƒ‰æˆåŠŸï¼‰';
        statusEl.className = 'status-msg success';
        warnEl.style.display = 'none';
        
    } else {
        // ğŸŸ¡ è­¦å‘Šä»˜ãæˆåŠŸï¼ˆä¸€éƒ¨ãƒãƒ³ãƒ‰æ¬ æï¼‰
        statusEl.textContent = 'âš ï¸ æ¸¬å®šå®Œäº†ï¼ˆå‚è€ƒå€¤ã¨ã—ã¦åˆ©ç”¨å¯èƒ½: ' + validOctaveCount + '/6ãƒãƒ³ãƒ‰ï¼‰';
        statusEl.className = 'status-msg warning';

        let warnText = 'ä¸€éƒ¨ã®ãƒãƒ³ãƒ‰ã§ãƒ‡ãƒ¼ã‚¿ãŒå–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚\n' +
            'æ¬ æãƒãƒ³ãƒ‰: ' + missingBands.join(', ') + '\n\n' +
            'æ¸¬å®šå€¤ã¯å‚è€ƒå€¤ã¨ã—ã¦åˆ©ç”¨ã§ãã¾ã™ãŒã€å…¨ãƒãƒ³ãƒ‰ã§ã®æ¸¬å®šã‚’æ¨å¥¨ã—ã¾ã™ã€‚';
        if (is125HzSkipped) {
            warnText += '\n\nâ€» 125Hzã¯å†…è”µã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼ã®ç‰©ç†é™ç•Œã®ãŸã‚æ¸¬å®šå¯¾è±¡å¤–ã§ã™ã€‚Sabineç†è«–å€¤ã§è£œå®Œã—ã¦ã„ã¾ã™ã€‚';
        }
        if (missingBands.some(b => b !== '125Hzï¼ˆç†è«–å€¤ï¼‰' && !b.includes('ç†è«–å€¤'))) {
            warnText += '\n\næ”¹å–„ç­–: ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼éŸ³é‡ã‚’ä¸Šã’ã‚‹ã‹ã€å¤–éƒ¨ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼ã®ä½¿ç”¨ã‚’ã”æ¤œè¨ãã ã•ã„ã€‚';
        }
        document.getElementById('warningReason').textContent = warnText;
        warnEl.className = 'warning-box warning-yellow';
        warnEl.style.display = 'block';
    }

    // Eyringãƒ¢ãƒ¼ãƒ‰ã§calculate()ã‚’å®Ÿè¡Œ
    calculate();
}


function handleMeasurementError(message) {
    const statusEl = document.getElementById('measureStatus');
    document.getElementById('startMeasBtn').disabled = false;
    document.getElementById('measureProgress').style.display = 'none';
    document.getElementById('recordingAlert').classList.remove('active');
    statusEl.textContent = 'âŒ ' + message;
    statusEl.className = 'status-msg error';
}

window.addEventListener('DOMContentLoaded', function() { initWorker(); });
</script>

<script>
// ========================================
// æ¸¬å®šè¨­å®šï¼ˆRev 18.11 Stepped Sweepä»•æ§˜ï¼‰
// ========================================
const MEASUREMENT_CONFIG = {

    // ã‚µãƒ³ãƒ—ãƒ«ãƒ¬ãƒ¼ãƒˆè¦æ±‚å€¤ï¼ˆ48kHzå›ºå®šï¼‰
    // AudioContextä½œæˆå¾Œã«å®Ÿæ¸¬å€¤ã¨ç…§åˆã—ã€ä¸ä¸€è‡´ã®å ´åˆã¯ã‚¨ãƒ©ãƒ¼
    sampleRate: 48000,

    // æ¸¬å®šãƒãƒ³ãƒ‰: 1/3ã‚ªã‚¯ã‚¿ãƒ¼ãƒ– 18ãƒãƒ³ãƒ‰ï¼ˆISO 266:2003æº–æ‹ ï¼‰
    // 3ãƒãƒ³ãƒ‰ãšã¤ã‚°ãƒ«ãƒ¼ãƒ—åŒ–ã—ã¦6ã‚ªã‚¯ã‚¿ãƒ¼ãƒ–ãƒãƒ³ãƒ‰ã«é›†ç´„ã™ã‚‹
    bands: [
        100, 125, 160,   // â†’ 125Hz ã‚ªã‚¯ã‚¿ãƒ¼ãƒ–ãƒãƒ³ãƒ‰
        200, 250, 315,   // â†’ 250Hz
        400, 500, 630,   // â†’ 500Hz
        800, 1000, 1250, // â†’ 1kHz
        1600, 2000, 2500,// â†’ 2kHz
        3150, 4000, 5000 // â†’ 4kHz
    ],

    // ã‚ªã‚¯ã‚¿ãƒ¼ãƒ–ãƒãƒ³ãƒ‰é›†ç´„ã‚°ãƒ«ãƒ¼ãƒ—
    // indices ã¯ä¸Šè¨˜ bands é…åˆ—ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã«å¯¾å¿œ
    octaveBands: [
        { label: '125Hz', indices: [0, 1, 2]   },
        { label: '250Hz', indices: [3, 4, 5]   },
        { label: '500Hz', indices: [6, 7, 8]   },
        { label: '1kHz',  indices: [9, 10, 11] },
        { label: '2kHz',  indices: [12, 13, 14]},
        { label: '4kHz',  indices: [15, 16, 17]}
    ],

    // ã‚¿ã‚¤ãƒŸãƒ³ã‚°è¨­å®šï¼ˆ1ãƒãƒ³ãƒ‰ã‚ãŸã‚Š / å˜ä½: ç§’ï¼‰
    // Bluetoothé…å»¶ãƒ»ç›¸äº’ç›¸é–¢ã«å¯¾å¿œã—ãŸä½™è£•ã‚’æŒã£ãŸè¨­å®š
    timing: {
        delay:         1.0,  // Bluetoothå®‰å®šåŒ–å¾…æ©Ÿï¼ˆ0.5â†’1.0ç§’ï¼‰
        stimulus:      1.5,  // å¸¯åŸŸé™å®š Log-Sweep å†ç”Ÿ
        recording:     2.5,  // æ®‹éŸ¿æ¸›è¡°éŒ²éŸ³ï¼ˆä½™è£•è¿½åŠ  2.0â†’2.5ç§’ï¼‰
        totalPerBand:  5.0   // åˆè¨ˆ: 18ãƒãƒ³ãƒ‰ Ã— 5.0ç§’ = 90ç§’
    },

    // è§£æãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
    analysis: {
        bpfOrder:  6,     // Butterworth BPF æ¬¡æ•°ï¼ˆ36dB/octï¼‰
        bpfMargin: 0.05,  // ã‚«ãƒƒãƒˆã‚ªãƒ•ã‚’è¦æ ¼ã‚ˆã‚Š5%å†…å´ã«è¨­å®šï¼ˆéš£æ¥å¸¯åŸŸæ¼ã‚Œé˜²æ­¢ï¼‰
        minSnr:    15.0   // æ¡ç”¨æœ€ä½SNR [dB]ã€‚æœªæº€ã¯nullï¼ˆBæ¡ˆ: æ¬ ææ‰±ã„ï¼‰
    },

    // æ¸¬å®šé–‹å§‹ã‚¢ãƒŠã‚¦ãƒ³ã‚¹BeepéŸ³
    beep: {
        frequency:  1000, // Hz
        duration:   0.2,  // ç§’
        gain:       0.3,  // éŸ³é‡
        waitAfter:  1.0   // Beepå¾Œã®æº–å‚™å¾…æ©Ÿï¼ˆç§’ï¼‰
    },

    // sweepGain: Sweepä¿¡å·ã®å‡ºåŠ›ã‚²ã‚¤ãƒ³
    sweepGain: 0.7
};

let audioContext = null;
let mediaStream = null;
let systemLatencyOffset = null;  // ãƒ¬ã‚¤ãƒ†ãƒ³ã‚·ãƒ¼ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³çµæœï¼ˆã‚µãƒ³ãƒ—ãƒ«æ•°ï¼‰

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£: æŒ‡å®šãƒŸãƒªç§’å¾…æ©Ÿ
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// é€²æ—UIæ›´æ–°
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function updateProgress(measuredCount, bandHz, status, totalBands) {
    const total = totalBands || MEASUREMENT_CONFIG.bands.length;
    const pct = Math.round((measuredCount / total) * 100);
    const remaining = Math.round((total - measuredCount) * MEASUREMENT_CONFIG.timing.totalPerBand);

    const icons = { measuring: 'ğŸ”Š', ok: 'âœ…', skip: 'âš ï¸', stopping: 'ğŸ›‘' };
    const icon = icons[status] || 'ğŸ”Š';

    document.getElementById('progressBar').style.width = pct + '%';
    document.getElementById('progressCount').textContent = measuredCount + ' / ' + total;
    document.getElementById('progressTime').textContent = 'æ®‹ã‚Šç´„ ' + remaining + ' ç§’';
    document.getElementById('progressLabel').textContent =
        icon + ' ' + bandHz + 'Hz ' + (status === 'measuring' ? 'æ¸¬å®šä¸­...' :
                                        status === 'ok'        ? 'å®Œäº†' :
                                        status === 'skip'      ? 'SNRä¸è¶³ â†’ ã‚¹ã‚­ãƒƒãƒ—' :
                                        status === 'stopping'  ? 'æ—©æœŸåœæ­¢åˆ¤å®šä¸­...' : '');
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³: ãƒã‚¤ã‚ºãƒ•ãƒ­ã‚¢æ¸¬å®šï¼ˆ2ç§’ç„¡éŸ³éŒ²éŸ³ï¼‰
// éŒ²éŸ³ãƒ‡ãƒ¼ã‚¿ã‚’ãã®ã¾ã¾Workerã«é€ã‚Šã€Workerå´ã§ãƒãƒ³ãƒ‰åˆ¥è§£æ
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function measureNoiseFloor(ctx, stream) {
    const fs = ctx.sampleRate;
    const duration = 5.0; // ç§’ï¼ˆ2ç§’â†’5ç§’ã«å»¶é•·ï¼šçªç™ºãƒã‚¤ã‚ºã‚’å¹³å‡åŒ–ã€é–¾å€¤å®‰å®šåŒ–ï¼‰
    const totalSamples = Math.round(duration * fs);

    // ScriptProcessorã§éŒ²éŸ³
    const bufferSize = 4096;
    const recorded = new Float32Array(totalSamples);
    let recordedSamples = 0;
    let resolveRecording;
    const recordingDone = new Promise(r => { resolveRecording = r; });

    const source = ctx.createMediaStreamSource(stream);
    const processor = ctx.createScriptProcessor(bufferSize, 1, 1);

    processor.onaudioprocess = (e) => {
        const input = e.inputBuffer.getChannelData(0);
        for (let i = 0; i < input.length; i++) {
            if (recordedSamples < totalSamples) {
                recorded[recordedSamples++] = input[i];
            }
        }
        if (recordedSamples >= totalSamples) {
            resolveRecording();
        }
    };

    // ScriptProcessorã®æ¥ç¶šï¼ˆChromeä»•æ§˜ã§å¿…è¦ï¼‰
    // MediaStreamDestinationã«æ¥ç¶šã™ã‚‹ã“ã¨ã§ç‰©ç†å‡ºåŠ›ã‚’å›é¿
    const dummyDestination = ctx.createMediaStreamDestination();
    source.connect(processor);
    processor.connect(dummyDestination);  // ä»®æƒ³å‡ºåŠ›ã®ã¿

    await recordingDone;

    source.disconnect();
    processor.disconnect();

    // RawéŒ²éŸ³ãƒ‡ãƒ¼ã‚¿ã‚’è¿”ã™ï¼ˆWorkerã§å¸¯åŸŸåˆ¥è§£æï¼‰
    return recorded;
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ã‚¢ãƒŠã‚¦ãƒ³ã‚¹BeepéŸ³å†ç”Ÿï¼ˆiOSå¯¾å¿œï¼‰
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function playBeep(ctx, speakerId) {
    const cfg = MEASUREMENT_CONFIG.beep;
    
    // BeepéŸ³ç”Ÿæˆ
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    
    osc.type = 'sine';
    osc.frequency.value = cfg.frequency;
    gain.gain.setValueAtTime(cfg.gain, ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + cfg.duration);
    
    osc.connect(gain);
    
    if (isIOS) {
        // iOS: ç›´æ¥æ¥ç¶šï¼ˆã‚·ãƒ³ãƒ—ãƒ«ãƒ»å®‰å®šï¼‰
        gain.connect(ctx.destination);
        
        // AudioContext.resume()ï¼ˆiOSå¿…é ˆï¼‰
        if (ctx.state === 'suspended') {
            await ctx.resume();
        }
        
        osc.start(ctx.currentTime);
        osc.stop(ctx.currentTime + cfg.duration);
        
    } else {
        // PC/Android: MediaStreamDestinationçµŒç”±ï¼ˆã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼é¸æŠå¯èƒ½ï¼‰
        const destination = ctx.createMediaStreamDestination();
        gain.connect(destination);
        
        // HTMLAudioElementã§å†ç”Ÿ
        const audio = new Audio();
        audio.srcObject = destination.stream;
        
        // ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼æŒ‡å®š
        if (speakerId && typeof audio.setSinkId === 'function') {
            try {
                await audio.setSinkId(speakerId);
            } catch (err) {
                console.warn('setSinkIdå¤±æ•—ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼ä½¿ç”¨ï¼‰:', err.message);
            }
        }
        
        osc.start(ctx.currentTime);
        osc.stop(ctx.currentTime + cfg.duration);
        
        await audio.play();
    }
    
    // Beepå†ç”Ÿå®Œäº† + å¾…æ©Ÿæ™‚é–“
    await sleep((cfg.duration + cfg.waitAfter) * 1000);
    
    // ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
    osc.disconnect();
    gain.disconnect();
}
function generateBandSweep(centerHz, sampleRate, durationSec) {
    const margin = MEASUREMENT_CONFIG.analysis.bpfMargin;
    const fLow  = (centerHz / Math.sqrt(2)) * (1 + margin);
    const fHigh = (centerHz * Math.sqrt(2)) * (1 - margin);

    // ã‚¬ãƒ¼ãƒ‰ãƒãƒ³ãƒ‰ï¼ˆå‰150ms + å¾Œ100msï¼‰
    const guardPre  = Math.round(0.15 * sampleRate);  // 150mså‰ã‚¬ãƒ¼ãƒ‰
    const guardPost = Math.round(0.10 * sampleRate);  // 100mså¾Œã‚¬ãƒ¼ãƒ‰
    
    // Sweepæœ¬ä½“
    const sweepSamples = Math.round(durationSec * sampleRate);
    const k = Math.log(fHigh / fLow) / durationSec;

    // å…¨ä½“ã‚µã‚¤ã‚º = å‰ã‚¬ãƒ¼ãƒ‰ + Sweep + å¾Œã‚¬ãƒ¼ãƒ‰
    const totalSamples = guardPre + sweepSamples + guardPost;
    const sweep = new Float32Array(totalSamples);
    
    // å‰ã‚¬ãƒ¼ãƒ‰ãƒãƒ³ãƒ‰: å®Œå…¨ãªç„¡éŸ³
    for (let i = 0; i < guardPre; i++) {
        sweep[i] = 0;
    }

    // Sweepä¿¡å·ç”Ÿæˆ
    for (let i = 0; i < sweepSamples; i++) {
        const t = i / sampleRate;
        const phase = 2 * Math.PI * fLow * (Math.exp(k * t) - 1) / k;
        sweep[guardPre + i] = Math.sin(phase) * MEASUREMENT_CONFIG.sweepGain;
    }
    
    // å¾Œã‚¬ãƒ¼ãƒ‰ãƒãƒ³ãƒ‰: å®Œå…¨ãªç„¡éŸ³
    for (let i = 0; i < guardPost; i++) {
        sweep[guardPre + sweepSamples + i] = 0;
    }

    // ã‚³ã‚µã‚¤ãƒ³çª“ãƒ•ã‚§ãƒ¼ãƒ‰ï¼ˆTukeyçª“ï¼‰
    // ãƒ•ã‚§ãƒ¼ãƒ‰æ™‚é–“50msï¼šã‚¨ãƒãƒ«ã‚®ãƒ¼ä¿æŒ97.5%ã€DCå¯¾ç­–ååˆ†ã€ã‚¼ãƒ­ã‚¯ãƒ­ã‚¹ç¢ºå®Ÿ
    const fadeSamples = Math.round(0.05 * sampleRate);  // 50msï¼ˆæœ€é©å€¤ï¼‰
    
    for (let i = 0; i < fadeSamples; i++) {
        const progress = i / fadeSamples;  // 0 â†’ 1
        
        // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³ï¼ˆã‚³ã‚µã‚¤ãƒ³çª“ï¼‰: 0 â†’ 1
        const fadeIn = 0.5 * (1 - Math.cos(Math.PI * progress));
        sweep[guardPre + i] *= fadeIn;
        
        // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆï¼ˆã‚³ã‚µã‚¤ãƒ³çª“ï¼‰: 1 â†’ 0
        const fadeOut = 0.5 * (1 + Math.cos(Math.PI * progress));
        sweep[guardPre + sweepSamples - fadeSamples + i] *= fadeOut;
    }

    return { sweep, fLow, fHigh };
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ãƒ¬ã‚¤ãƒ†ãƒ³ã‚·ãƒ¼ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
// ã‚·ã‚¹ãƒ†ãƒ å›ºæœ‰ã®é…å»¶ï¼ˆå†ç”Ÿâ†’éŒ²éŸ³ï¼‰ã‚’æ¸¬å®š
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// ãƒãƒ£ãƒ¼ãƒ—ä¿¡å·ç”Ÿæˆï¼ˆã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ç”¨ï¼‰
function generateCalibrationChirp(sampleRate) {
    const duration = 0.1;  // 100ms
    const f1 = 500;        // é–‹å§‹å‘¨æ³¢æ•°
    const f2 = 2000;       // çµ‚äº†å‘¨æ³¢æ•°
    const samples = Math.floor(duration * sampleRate);
    const chirp = new Float32Array(samples);
    
    for (let i = 0; i < samples; i++) {
        const t = i / sampleRate;
        const phase = 2 * Math.PI * (f1 * t + (f2 - f1) * t * t / (2 * duration));
        chirp[i] = Math.sin(phase);
    }
    
    // ãƒãƒ‹ãƒ³ã‚°çª“ã§ãƒ•ã‚§ãƒ¼ãƒ‰
    for (let i = 0; i < samples; i++) {
        const window = 0.5 * (1 - Math.cos(2 * Math.PI * i / samples));
        chirp[i] *= window;
    }
    
    return chirp;
}

// ãƒãƒ£ãƒ¼ãƒ—ä¿¡å·ã®ä½ç½®ã‚’æ¤œå‡ºï¼ˆç›¸äº’ç›¸é–¢ï¼‰
function findChirpOffset(recorded, chirp, sampleRate) {
    // æ¤œç´¢ç¯„å›²: æœ€åˆã®2ç§’é–“
    const searchSamples = Math.min(
        Math.floor(2.0 * sampleRate),
        recorded.length - chirp.length
    );
    
    if (searchSamples <= 0) {
        console.warn('âš ï¸ ãƒ¬ã‚¤ãƒ†ãƒ³ã‚·ãƒ¼æ¤œå‡ºå¤±æ•—: éŒ²éŸ³ãŒçŸ­ã™ãã‚‹');
        return Math.floor(0.5 * sampleRate);
    }
    
    let maxCorr = -Infinity;
    let bestOffset = 0;
    
    // ç²—ã„ã‚¹ã‚­ãƒ£ãƒ³ï¼ˆ100ã‚µãƒ³ãƒ—ãƒ«åˆ»ã¿ï¼‰
    for (let offset = 0; offset < searchSamples; offset += 100) {
        let corr = 0;
        for (let i = 0; i < chirp.length; i++) {
            corr += recorded[offset + i] * chirp[i];
        }
        if (corr > maxCorr) {
            maxCorr = corr;
            bestOffset = offset;
        }
    }
    
    // ç´°ã‹ã„èª¿æ•´ï¼ˆÂ±100ã‚µãƒ³ãƒ—ãƒ«ç¯„å›²ã§1ã‚µãƒ³ãƒ—ãƒ«åˆ»ã¿ï¼‰
    const fineStart = Math.max(0, bestOffset - 100);
    const fineEnd = Math.min(searchSamples, bestOffset + 100);
    maxCorr = -Infinity;
    
    for (let offset = fineStart; offset < fineEnd; offset++) {
        let corr = 0;
        for (let i = 0; i < chirp.length; i++) {
            corr += recorded[offset + i] * chirp[i];
        }
        if (corr > maxCorr) {
            maxCorr = corr;
            bestOffset = offset;
        }
    }
    
    // ä¿¡é ¼åº¦è¨ˆç®—
    let recEnergy = 0;
    let chirpEnergy = 0;
    for (let i = 0; i < chirp.length; i++) {
        recEnergy += recorded[bestOffset + i] * recorded[bestOffset + i];
        chirpEnergy += chirp[i] * chirp[i];
    }
    
    const normalizedCorr = maxCorr / (Math.sqrt(recEnergy * chirpEnergy) + 1e-10);
    
    console.log('ãƒãƒ£ãƒ¼ãƒ—æ¤œå‡º: offset=' + bestOffset + ' (' + (bestOffset/sampleRate).toFixed(3) + 's), ä¿¡é ¼åº¦=' + normalizedCorr.toFixed(3));
    
    if (normalizedCorr < 0.5) {
        console.warn('âš ï¸ ãƒ¬ã‚¤ãƒ†ãƒ³ã‚·ãƒ¼æ¤œå‡ºã®ä¿¡é ¼åº¦ãŒä½ã„ï¼ˆ' + normalizedCorr.toFixed(3) + ' < 0.5ï¼‰');
    }
    
    return bestOffset;
}

// ãƒ¬ã‚¤ãƒ†ãƒ³ã‚·ãƒ¼ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å®Ÿè¡Œ
async function calibrateLatency(audioContext, mediaStream, speakerId) {
    const fs = audioContext.sampleRate;
    const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);
    
    console.log('=== ãƒ¬ã‚¤ãƒ†ãƒ³ã‚·ãƒ¼ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹ ===');
    
    // 1. ãƒ†ã‚¹ãƒˆãƒãƒ£ãƒ¼ãƒ—ç”Ÿæˆ
    const chirp = generateCalibrationChirp(fs);
    console.log('  ãƒãƒ£ãƒ¼ãƒ—ç”Ÿæˆ: ' + chirp.length + 'ã‚µãƒ³ãƒ—ãƒ« (' + (chirp.length/fs*1000).toFixed(0) + 'ms)');
    
    // 2. éŒ²éŸ³æ™‚é–“è¨­å®šï¼ˆå‰ãƒãƒƒãƒ•ã‚¡0.5ç§’ + ãƒãƒ£ãƒ¼ãƒ—0.1ç§’ + æ¤œç´¢ä½™è£•2ç§’ï¼‰
    const recordingDuration = 2.6;
    const totalSamples = Math.round(recordingDuration * fs);
    
    // 3. ScriptProcessorã§éŒ²éŸ³æº–å‚™
    const bufferSize = 4096;
    const recorded = new Float32Array(totalSamples);
    let recordedSamples = 0;
    let resolveRecording;
    const recordingDone = new Promise(r => { resolveRecording = r; });
    
    const source = audioContext.createMediaStreamSource(mediaStream);
    const processor = audioContext.createScriptProcessor(bufferSize, 1, 1);
    
    processor.onaudioprocess = (e) => {
        const input = e.inputBuffer.getChannelData(0);
        for (let i = 0; i < input.length; i++) {
            if (recordedSamples < totalSamples) {
                recorded[recordedSamples++] = input[i];
            }
        }
        if (recordedSamples >= totalSamples) {
            resolveRecording();
        }
    };
    
    const dummyDestination = audioContext.createMediaStreamDestination();
    source.connect(processor);
    processor.connect(dummyDestination);
    
    console.log('  éŒ²éŸ³æº–å‚™å®Œäº†ã€200mså¾…æ©Ÿ...');
    
    // 4. éŒ²éŸ³ãƒãƒƒãƒ•ã‚¡å®‰å®šå¾…æ©Ÿ
    await new Promise(resolve => setTimeout(resolve, 200));
    
    console.log('  ãƒãƒ£ãƒ¼ãƒ—å†ç”Ÿé–‹å§‹');
    
    // 5. ãƒãƒ£ãƒ¼ãƒ—å†ç”Ÿ
    const chirpBuffer = audioContext.createBuffer(1, chirp.length, fs);
    chirpBuffer.copyToChannel(chirp, 0);
    const chirpSource = audioContext.createBufferSource();
    chirpSource.buffer = chirpBuffer;
    
    if (isIOS) {
        chirpSource.connect(audioContext.destination);
        chirpSource.start(audioContext.currentTime);
    } else {
        const destination = audioContext.createMediaStreamDestination();
        chirpSource.connect(destination);
        
        const audio = new Audio();
        audio.srcObject = destination.stream;
        
        if (speakerId && typeof audio.setSinkId === 'function') {
            try {
                await audio.setSinkId(speakerId);
            } catch (err) {
                console.warn('Calibration: setSinkIdå¤±æ•—:', err.message);
            }
        }
        
        await audio.play();
        chirpSource.start(audioContext.currentTime);
    }
    
    // 6. éŒ²éŸ³å®Œäº†ã¾ã§å¾…æ©Ÿ
    await recordingDone;
    
    // 7. ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
    source.disconnect();
    processor.disconnect();
    
    console.log('=== ãƒ¬ã‚¤ãƒ†ãƒ³ã‚·ãƒ¼éŒ²éŸ³å®Œäº†: ' + recordedSamples + 'ã‚µãƒ³ãƒ—ãƒ« ===');
    
    // 8. ç›¸äº’ç›¸é–¢ã§ã‚ªãƒ•ã‚»ãƒƒãƒˆæ¤œå‡º
    const latencyOffset = findChirpOffset(recorded, chirp, fs);
    
    console.log('=== ãƒ¬ã‚¤ãƒ†ãƒ³ã‚·ãƒ¼æ¤œå‡ºå®Œäº†: ' + latencyOffset + 'ã‚µãƒ³ãƒ—ãƒ« (' + (latencyOffset/fs).toFixed(3) + 'ç§’) ===');
    
    return latencyOffset;
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 1ãƒãƒ³ãƒ‰å†ç”Ÿãƒ»éŒ²éŸ³
// Sweepå†ç”Ÿã¨åŒæ™‚ã«éŒ²éŸ³é–‹å§‹ã€recordingç§’å¾Œã«åœæ­¢
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 1ãƒãƒ³ãƒ‰å†ç”Ÿãƒ»éŒ²éŸ³ï¼ˆMediaStreamDestinationæ–¹å¼ãƒ»Bluetoothå¯¾å¿œï¼‰
// Sweepå†ç”Ÿã¨åŒæ™‚ã«éŒ²éŸ³é–‹å§‹ã€recordingç§’å¾Œã«åœæ­¢
// å‰å¾Œã«ä½™è£•ã‚’æŒãŸã›ã€ç›¸äº’ç›¸é–¢ã§æ­£ç¢ºãªä½ç½®ã‚’æ¤œå‡º
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function playAndRecord(ctx, stream, sweepData, centerHz, speakerId) {
    const cfg = MEASUREMENT_CONFIG.timing;
    const fs  = ctx.sampleRate;
    
    // éŒ²éŸ³ãƒãƒƒãƒ•ã‚¡: å‰å¾Œã«ä½™è£•ï¼ˆBluetoothé…å»¶ãƒ»ã‚¸ãƒƒã‚¿ãƒ¼å¯¾å¿œï¼‰
    // å‰ãƒãƒƒãƒ•ã‚¡0.5ç§’ + stimulus + recording + å¾Œãƒãƒƒãƒ•ã‚¡0.5ç§’
    const preBuffer  = Math.round(0.5 * fs);
    const postBuffer = Math.round(0.5 * fs);
    const sweepSamples = sweepData.sweep.length;
    const recordingSamples = Math.round(cfg.recording * fs);
    const totalSamples = preBuffer + sweepSamples + recordingSamples + postBuffer;

    // ScriptProcessorã§éŒ²éŸ³
    const bufferSize = 4096;
    const recorded = new Float32Array(totalSamples);
    let recordedSamples = 0;
    let resolveRecording;
    const recordingDone = new Promise(r => { resolveRecording = r; });

    const source = ctx.createMediaStreamSource(stream);
    const processor = ctx.createScriptProcessor(bufferSize, 1, 1);

    processor.onaudioprocess = (e) => {
        const input = e.inputBuffer.getChannelData(0);
        for (let i = 0; i < input.length; i++) {
            if (recordedSamples < totalSamples) {
                recorded[recordedSamples++] = input[i];
            }
        }
        if (recordedSamples >= totalSamples) {
            resolveRecording();
        }
    };

    // ScriptProcessorã®æ¥ç¶šï¼ˆChromeä»•æ§˜ã§å¿…è¦ï¼‰
    // MediaStreamDestinationã«æ¥ç¶šã™ã‚‹ã“ã¨ã§ç‰©ç†å‡ºåŠ›ã‚’å›é¿
    const dummyDestination = ctx.createMediaStreamDestination();
    source.connect(processor);
    processor.connect(dummyDestination);  // ä»®æƒ³å‡ºåŠ›ã®ã¿

    // â­ éŒ²éŸ³ãƒãƒƒãƒ•ã‚¡ãŒå®‰å®šã™ã‚‹ã¾ã§å¾…æ©Ÿï¼ˆ200msï¼‰
    // OSã®éŒ²éŸ³ç«‹ã¡ä¸ŠãŒã‚Šé…å»¶å¯¾ç­–ï¼šmacOS/iOS 100-200ms, Windows 50-150ms, Android 100-300ms
    // ã“ã®å¾…æ©Ÿã«ã‚ˆã‚Šã€Sweepã®æœ€åˆã‹ã‚‰ç¢ºå®Ÿã«éŒ²éŸ³ã•ã‚Œã€ç›¸äº’ç›¸é–¢ã®æˆåŠŸç‡ãŒåŠ‡çš„ã«å‘ä¸Š
    await new Promise(resolve => setTimeout(resolve, 200));

    // Sweepä¿¡å·ã‚’æº–å‚™
    const sweepBuffer = ctx.createBuffer(1, sweepData.sweep.length, fs);
    sweepBuffer.copyToChannel(sweepData.sweep, 0);
    const sweepSource = ctx.createBufferSource();
    sweepSource.buffer = sweepBuffer;

    // audioå¤‰æ•°ã‚’é–¢æ•°ã‚¹ã‚³ãƒ¼ãƒ—ã§å®£è¨€ï¼ˆiOS/éiOSä¸¡æ–¹ã§ä½¿ãˆã‚‹ã‚ˆã†ã«ï¼‰
    let audio = null;

    if (isIOS) {
        // iOSå°‚ç”¨ãƒ‘ã‚¹ï¼šMediaStreamDestinationå›é¿ï¼ˆã¶ã¤åˆ‡ã‚Œå¯¾ç­–ï¼‰
        // ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼é¸æŠã¯è«¦ã‚ã‚‹ãŒã€éŸ³ã¯å®‰å®š
        sweepSource.connect(ctx.destination);
        
        // AudioContext.resume()ï¼ˆiOSå¿…é ˆï¼‰
        if (ctx.state === 'suspended') {
            await ctx.resume();
        }
        
        sweepSource.start(ctx.currentTime);
        
    } else {
        // PC/Androidï¼šMediaStreamDestinationçµŒç”±ï¼ˆã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼é¸æŠå¯èƒ½ï¼‰
        const destination = ctx.createMediaStreamDestination();
        sweepSource.connect(destination);

        // HTMLAudioElementã§å†ç”Ÿï¼ˆã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼æŒ‡å®šï¼‰
        audio = new Audio();
        audio.srcObject = destination.stream;
        
        if (speakerId && typeof audio.setSinkId === 'function') {
            try {
                await audio.setSinkId(speakerId);
            } catch (err) {
                console.warn(`${centerHz}Hz: setSinkIdå¤±æ•—ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼ä½¿ç”¨ï¼‰:`, err.message);
            }
        }

        // HTMLAudioElementã®å†ç”Ÿã‚’å…ˆã«é–‹å§‹
        await audio.play();
        
        // å†ç”ŸãŒç¢ºå®Ÿã«å§‹ã¾ã‚‹ã¾ã§å¾…æ©Ÿï¼ˆ100msï¼‰
        // ã“ã‚Œã«ã‚ˆã‚ŠAudioContextã¨HTMLAudioElementã®ã‚¿ã‚¤ãƒŸãƒ³ã‚°ãŒã‚ºãƒ¬ãªã„
        await new Promise(resolve => setTimeout(resolve, 100));
        
        // BufferSourceã‚’é–‹å§‹
        sweepSource.start(ctx.currentTime);
    }

    // éŒ²éŸ³å®Œäº†ã¾ã§å¾…æ©Ÿ
    await recordingDone;

    // ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
    source.disconnect();
    processor.disconnect();
    // sweepSource.stop()ã¯ä¸è¦ï¼ˆBufferSourceã¯è‡ªå‹•åœæ­¢ã€æ˜ç¤ºçš„stop()ã¯ãƒãƒƒãƒ—ãƒã‚¤ã‚ºã®åŸå› ï¼‰
    
    if (audio) {
        audio.pause();
        audio.srcObject = null;
    }

    return recorded;
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ã‚ªã‚¯ã‚¿ãƒ¼ãƒ–ãƒãƒ³ãƒ‰å®Œäº†æ™‚ã®æ—©æœŸæ‰“ã¡åˆ‡ã‚Šåˆ¤å®š
// ç¢ºå®šå¼: validOctaves + remainingOctaves < 4 â†’ åœæ­¢
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function checkEarlyTermination(validOctaves, completedOctaves, minValidOctaves) {
    const remaining = 6 - completedOctaves;
    if (validOctaves + remaining < minValidOctaves) {
        const msg =
            `æœ‰åŠ¹ãƒ‡ãƒ¼ã‚¿ãŒ ${validOctaves} ãƒãƒ³ãƒ‰ã®ã¿ã§ã™ã€‚\n` +
            `æ®‹ã‚Š ${remaining} ãƒãƒ³ãƒ‰ã‚’æ¸¬å®šã—ã¦ã‚‚${minValidOctaves}ãƒãƒ³ãƒ‰ã®ç¢ºä¿ãŒä¸å¯èƒ½ãªãŸã‚åœæ­¢ã—ã¾ã—ãŸã€‚\n` +
            `ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼éŸ³é‡ã‚’ä¸Šã’ã‚‹ã‹ã€ç’°å¢ƒãƒã‚¤ã‚ºã‚’ä¸‹ã’ã¦å†æ¸¬å®šã—ã¦ãã ã•ã„ã€‚`;
        return { stop: true, reason: msg };
    }
    return { stop: false };
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ãƒ¡ã‚¤ãƒ³æ¸¬å®šã‚·ãƒ¼ã‚±ãƒ³ã‚¹
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function runMeasurementSequence() {
    const statusEl  = document.getElementById('measureStatus');
    const startBtn  = document.getElementById('startMeasBtn');
    const progressEl = document.getElementById('measureProgress');

    startBtn.disabled = true;
    document.getElementById('remeasureWarning').style.display = 'none';

    // ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«å–å¾—ï¼ˆãƒ«ãƒ¼ãƒ—å…¨ä½“ã§ä½¿ç”¨ï¼‰
    const snrProfile    = SNR_PROFILES[currentSNRProfile];
    const totalBands    = snrProfile.totalBands;
    const initTimeSec   = Math.round(totalBands * MEASUREMENT_CONFIG.timing.totalPerBand) + 3;

    // é€²æ—ãƒãƒ¼åˆæœŸåŒ–
    progressEl.style.display = 'block';
    document.getElementById('progressBar').style.width = '0%';
    document.getElementById('progressCount').textContent = '0 / ' + totalBands;
    document.getElementById('progressTime').textContent = 'æ®‹ã‚Šç´„ ' + initTimeSec + ' ç§’';
    document.getElementById('progressLabel').textContent = 'æº–å‚™ä¸­...';

    // â”€â”€ ã‚¹ãƒ†ãƒ¼ã‚¸0: AudioContext ä½œæˆãƒ»ã‚µãƒ³ãƒ—ãƒ«ãƒ¬ãƒ¼ãƒˆç¢ºèª â”€â”€
    try {
        audioContext = new (window.AudioContext || window.webkitAudioContext)({
            sampleRate: MEASUREMENT_CONFIG.sampleRate
        });

        const actualFs = audioContext.sampleRate;
        if (actualFs !== MEASUREMENT_CONFIG.sampleRate) {
            throw new Error(
                `ã“ã®ãƒ‡ãƒã‚¤ã‚¹ã¯48kHzã‚µãƒ³ãƒ—ãƒ«ãƒ¬ãƒ¼ãƒˆã«å¯¾å¿œã—ã¦ã„ã¾ã›ã‚“ã€‚\n` +
                `ï¼ˆæ¤œå‡ºå€¤: ${actualFs}Hzï¼‰\n` +
                `ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼/ãƒã‚¤ã‚¯ã®è¨­å®šã‚’ç¢ºèªã™ã‚‹ã‹ã€åˆ¥ã®ãƒ‡ãƒã‚¤ã‚¹ã§æ¸¬å®šã—ã¦ãã ã•ã„ã€‚`
            );
        }
    } catch (err) {
        statusEl.textContent = 'âŒ ' + err.message;
        statusEl.className = 'status-msg error';
        startBtn.disabled = false;
        progressEl.style.display = 'none';
        return;
    }

    // â”€â”€ Workerã¸INITé€ä¿¡ï¼ˆsampleRateãƒ»configä¸€æ‹¬é€šçŸ¥ + SNRé–¾å€¤ï¼‰ â”€â”€
    const configWithSNR = {
        ...MEASUREMENT_CONFIG,
        analysis: {
            ...MEASUREMENT_CONFIG.analysis,
            minSnr: snrProfile.threshold
        }
    };
    
    measurementWorker.postMessage({
        type:       'INIT',
        sampleRate: audioContext.sampleRate,
        config:     configWithSNR
    });

    // AudioContext.resume()ï¼ˆãƒ–ãƒ©ã‚¦ã‚¶ã®Autoplay Policyã«å¯¾å¿œï¼‰
    if (audioContext.state === 'suspended') {
        try {
            await audioContext.resume();
            console.info('AudioContext resumed');
        } catch (err) {
            console.warn('AudioContext.resume()å¤±æ•—:', err.message);
        }
    }

    // â”€â”€ ã‚¹ãƒ†ãƒ¼ã‚¸0: ãƒã‚¤ã‚¯ã‚¹ãƒˆãƒªãƒ¼ãƒ å–å¾— â”€â”€
    try {
        const micId = document.getElementById('micSelect').value;
        const constraints = {
            audio: {
                deviceId: micId ? { exact: micId } : undefined,
                echoCancellation: false,
                noiseSuppression: false,
                autoGainControl: false,
                sampleRate: MEASUREMENT_CONFIG.sampleRate
            }
        };
        mediaStream = await navigator.mediaDevices.getUserMedia(constraints);
    } catch (err) {
        statusEl.textContent = 'âŒ ãƒã‚¤ã‚¯ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + err.message;
        statusEl.className = 'status-msg error';
        startBtn.disabled = false;
        progressEl.style.display = 'none';
        return;
    }

    // â”€â”€ ã‚¹ãƒ†ãƒ¼ã‚¸1: ã‚¢ãƒŠã‚¦ãƒ³ã‚¹Beep + æ¸¬å®šé–‹å§‹é€šçŸ¥ â”€â”€
    // ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼ãƒ‡ãƒã‚¤ã‚¹IDã‚’å–å¾—
    const speakerId = document.getElementById('spkSelect').value;
    
    statusEl.textContent = `ğŸ”” æ¸¬å®šã‚’é–‹å§‹ã—ã¾ã™ã€‚é™ã‹ã«ã—ã¦ãã ã•ã„ï¼ˆç´„${initTimeSec}ç§’ï¼‰`;
    statusEl.className = 'status-msg calibrating';
    document.getElementById('recordingAlert').classList.add('active');

    try {
        await playBeep(audioContext, speakerId);
        console.info('âœ… BeepéŸ³å†ç”Ÿå®Œäº†');
    } catch (err) {
        // Beepå¤±æ•—ã¯éè‡´å‘½çš„ â†’ ç¶šè¡Œ
        console.warn('Beepå†ç”Ÿå¤±æ•—ï¼ˆç¶šè¡Œï¼‰:', err.message);
    }

    // â”€â”€ ã‚¹ãƒ†ãƒ¼ã‚¸1.3: ãƒ¬ã‚¤ãƒ†ãƒ³ã‚·ãƒ¼ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ â”€â”€
    statusEl.textContent = 'ğŸ” ã‚·ã‚¹ãƒ†ãƒ é…å»¶ã‚’æ¸¬å®šä¸­...ï¼ˆç´„3ç§’ï¼‰';
    statusEl.className = 'status-msg calibrating';
    document.getElementById('progressLabel').textContent = 'ã‚·ã‚¹ãƒ†ãƒ é…å»¶æ¸¬å®šä¸­...';
    
    try {
        systemLatencyOffset = await calibrateLatency(audioContext, mediaStream, speakerId);
        
        const latencyMs = (systemLatencyOffset / audioContext.sampleRate * 1000).toFixed(0);
        console.info('âœ… ã‚·ã‚¹ãƒ†ãƒ é…å»¶æ¤œå‡º: ' + systemLatencyOffset + 'ã‚µãƒ³ãƒ—ãƒ« (' + latencyMs + 'ms)');
        
        statusEl.textContent = 'âœ… ã‚·ã‚¹ãƒ†ãƒ é…å»¶: ' + latencyMs + 'ms';
        statusEl.className = 'status-msg success';
        await sleep(1000); // 1ç§’é–“è¡¨ç¤º
        
    } catch (err) {
        console.warn('âš ï¸ ãƒ¬ã‚¤ãƒ†ãƒ³ã‚·ãƒ¼æ¸¬å®šå¤±æ•—ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’ä½¿ç”¨:', err.message);
        systemLatencyOffset = Math.floor(0.5 * audioContext.sampleRate);
    }

    // â”€â”€ ã‚¹ãƒ†ãƒ¼ã‚¸1.5: ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆãƒã‚¤ã‚ºãƒ•ãƒ­ã‚¢æ¸¬å®šï¼‰ â”€â”€
    statusEl.textContent = 'ğŸ“Š ç’°å¢ƒãƒã‚¤ã‚ºã‚’æ¸¬å®šä¸­...ï¼ˆ5ç§’ï¼‰';
    statusEl.className = 'status-msg calibrating';
    document.getElementById('progressLabel').textContent = 'ç’°å¢ƒãƒã‚¤ã‚ºæ¸¬å®šä¸­...';
    
    let noiseRecording;
    try {
        noiseRecording = await measureNoiseFloor(audioContext, mediaStream);
        
        // Workerå´ã§ãƒãƒ³ãƒ‰åˆ¥è§£æã‚’å®Ÿè¡Œï¼ˆéåŒæœŸãƒ»ãƒ–ãƒ­ãƒƒã‚¯ã—ãªã„ï¼‰
        measurementWorker.postMessage({
            type: 'CALIBRATION',
            noiseRecording: noiseRecording.buffer
        }, [noiseRecording.buffer]); // Transferable
        
        console.info('âœ… ãƒã‚¤ã‚ºãƒ•ãƒ­ã‚¢éŒ²éŸ³å®Œäº† â†’ Workerã§è§£æä¸­');
    } catch (err) {
        console.warn('âš ï¸ ãƒã‚¤ã‚ºãƒ•ãƒ­ã‚¢æ¸¬å®šå¤±æ•—:', err.message);
    }
    
    console.info('ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å®Œäº†ã€18ãƒãƒ³ãƒ‰æ¸¬å®šã«é€²ã¿ã¾ã™');

    // â”€â”€ ãƒ¬ã‚¤ãƒ†ãƒ³ã‚·ãƒ¼ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’Workerã«é€ä¿¡ â”€â”€
    measurementWorker.postMessage({
        type: 'SET_LATENCY',
        latencyOffset: systemLatencyOffset
    });
    console.info('  ãƒ¬ã‚¤ãƒ†ãƒ³ã‚·ãƒ¼ã‚ªãƒ•ã‚»ãƒƒãƒˆé€ä¿¡: ' + systemLatencyOffset + 'ã‚µãƒ³ãƒ—ãƒ«');

    // â”€â”€ ã‚¹ãƒ†ãƒ¼ã‚¸2: 18ãƒãƒ³ãƒ‰é€æ¬¡æ¸¬å®š â”€â”€
    console.info('=== ' + totalBands + 'ãƒãƒ³ãƒ‰æ¸¬å®šé–‹å§‹ ===');
    const bands       = MEASUREMENT_CONFIG.bands;       // 18æœ¬
    const octaveDefs  = MEASUREMENT_CONFIG.octaveBands; // 6ã‚°ãƒ«ãƒ¼ãƒ—
    const thirdResults = new Array(18).fill(null);       // 1/3octåˆ¥RT60

    let validOctaveCount   = 0;  // æˆåŠŸã—ãŸã‚ªã‚¯ã‚¿ãƒ¼ãƒ–ãƒãƒ³ãƒ‰æ•°
    let completedOctaves   = 0;  // å®Œäº†ã—ãŸã‚ªã‚¯ã‚¿ãƒ¼ãƒ–ãƒãƒ³ãƒ‰æ•°
    let measuredCount      = 0;  // ã‚¹ã‚­ãƒƒãƒ—ã‚’é™¤ãå®Ÿæ¸¬ãƒãƒ³ãƒ‰æ•°ï¼ˆé€²æ—è¡¨ç¤ºç”¨ï¼‰
    let earlyStop          = false;
    let earlyStopReason    = '';

    for (let bi = 0; bi < bands.length; bi++) {
        const centerHz = bands[bi];

        // â”€â”€ ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ã«ã‚ˆã‚‹ãƒãƒ³ãƒ‰ã‚¹ã‚­ãƒƒãƒ— â”€â”€
        if (snrProfile.skipBands.includes(bi)) {
            thirdResults[bi] = null;
            // ã‚ªã‚¯ã‚¿ãƒ¼ãƒ–å¢ƒç•Œãƒã‚§ãƒƒã‚¯ï¼ˆã‚¹ã‚­ãƒƒãƒ—ãƒãƒ³ãƒ‰ã§ã‚‚å¢ƒç•Œã¯å‡¦ç†ã™ã‚‹ï¼‰
            if ((bi + 1) % 3 === 0) {
                completedOctaves++;
                // ã‚¹ã‚­ãƒƒãƒ—ã‚ªã‚¯ã‚¿ãƒ¼ãƒ–ã¯validOctaveCountã‚’å¢—ã‚„ã•ãªã„
                const check = checkEarlyTermination(validOctaveCount, completedOctaves, snrProfile.minValidOctaves);
                if (check.stop) {
                    earlyStop = true;
                    earlyStopReason = check.reason;
                    break;
                }
            }
            continue;
        }

        console.info(`ãƒãƒ³ãƒ‰ ${bi+1}/18 (å®Ÿæ¸¬${measuredCount+1}/${totalBands}): ${centerHz}Hz é–‹å§‹`);

        // é€²æ—UIæ›´æ–°ï¼ˆæ¸¬å®šä¸­ï¼‰
        updateProgress(measuredCount, centerHz, 'measuring', totalBands);
        statusEl.textContent = `ğŸ”Š ${centerHz}Hz æ¸¬å®šä¸­... [${measuredCount + 1}/${totalBands}]`;
        statusEl.className = 'status-msg analyzing';

        // delay: Bluetooth/ãƒ‡ãƒã‚¤ã‚¹å®‰å®šåŒ–å¾…æ©Ÿ
        await sleep(MEASUREMENT_CONFIG.timing.delay * 1000);

        // Sweepç”Ÿæˆ
        let sweepData;
        try {
            sweepData = generateBandSweep(
                centerHz,
                audioContext.sampleRate,
                MEASUREMENT_CONFIG.timing.stimulus
            );
            console.info(`  Sweepç”Ÿæˆå®Œäº†: ${sweepData.fLow.toFixed(1)}-${sweepData.fHigh.toFixed(1)}Hz`);
        } catch (err) {
            console.error(`âŒ ${centerHz}Hz Sweepç”Ÿæˆå¤±æ•—:`, err.message);
            measuredCount++;
            updateProgress(measuredCount, centerHz, 'skip', totalBands);
            thirdResults[bi] = null;
            if ((bi + 1) % 3 === 0) {
                completedOctaves++;
                const octIdx = completedOctaves - 1;
                const g = octaveDefs[octIdx].indices;
                const octValid = g.filter(i => thirdResults[i] !== null).length;
                if (octValid > 0) validOctaveCount++;
                const check = checkEarlyTermination(validOctaveCount, completedOctaves, snrProfile.minValidOctaves);
                if (check.stop) {
                    earlyStop = true;
                    earlyStopReason = check.reason;
                    break;
                }
            }
            continue;
        }

        // å†ç”Ÿãƒ»éŒ²éŸ³
        let recorded;
        try {
            recorded = await playAndRecord(
                audioContext, mediaStream, sweepData, centerHz, speakerId
            );
        } catch (err) {
            console.warn(`${centerHz}Hz éŒ²éŸ³å¤±æ•—:`, err.message);
            measuredCount++;
            updateProgress(measuredCount, centerHz, 'skip', totalBands);
            thirdResults[bi] = null;
            if ((bi + 1) % 3 === 0) {
                completedOctaves++;
                const octIdx = completedOctaves - 1;
                const g = octaveDefs[octIdx].indices;
                const octValid = g.filter(i => thirdResults[i] !== null).length;
                if (octValid > 0) validOctaveCount++;
                const check = checkEarlyTermination(validOctaveCount, completedOctaves, snrProfile.minValidOctaves);
                if (check.stop) {
                    earlyStop = true;
                    earlyStopReason = check.reason;
                    break;
                }
            }
            continue;
        }

        // Workerã«RawéŒ²éŸ³ãƒ‡ãƒ¼ã‚¿ + Sweepæƒ…å ±ã‚’é€ä¿¡ã—ã¦è§£æ
        console.log(`=== ${centerHz}Hz: Workerã¸ãƒ‡ãƒ¼ã‚¿é€ä¿¡ ===`);
        console.log(`  éŒ²éŸ³ãƒ‡ãƒ¼ã‚¿: ${recorded.length}ã‚µãƒ³ãƒ—ãƒ«`);
        console.log(`  Sweepãƒ‡ãƒ¼ã‚¿: ${sweepData.sweep.length}ã‚µãƒ³ãƒ—ãƒ«`);
        
        const workerResult = await new Promise((resolve) => {
            measurementWorker.onmessage = (e) => {
                // ãƒ‡ãƒãƒƒã‚°ï¼šå…¨ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ãƒ­ã‚°
                console.log('=== Worker Message ===', e.data.type);
                
                if (e.data.type === 'debug') {
                    console.log('[Worker] ' + e.data.message);
                    console.info('[Worker-INFO] ' + e.data.message);
                    console.warn('[Worker-DEBUG] ' + e.data.message);
                    return;
                }
                if (e.data.type === 'bandResult') {
                    console.log(`=== ${centerHz}Hz: Workerçµæœå—ä¿¡ ===`, e.data);
                    resolve(e.data);
                }
            };
            
            console.log(`=== ${centerHz}Hz: postMessageå®Ÿè¡Œ ===`);
            measurementWorker.postMessage({
                type:     'ANALYZE_BAND',
                band:     centerHz,
                recorded: recorded.buffer,
                sweep:    sweepData.sweep.buffer
            }, [recorded.buffer, sweepData.sweep.buffer]); // Transferable
            console.log(`=== ${centerHz}Hz: postMessageå®Œäº†ã€çµæœå¾…æ©Ÿä¸­ ===`);
        });

        measuredCount++;
        if (workerResult.type === 'bandResult' && workerResult.rt60 !== null) {
            thirdResults[bi] = workerResult.rt60;
            updateProgress(measuredCount, centerHz, 'ok', totalBands);
        } else {
            thirdResults[bi] = null;
            updateProgress(measuredCount, centerHz, 'skip', totalBands);
            const reason = workerResult.reason || 'SNRä¸è¶³';
            console.info(`${centerHz}Hz ã‚¹ã‚­ãƒƒãƒ—: ${reason}`);
        }

        // â”€â”€ ã‚ªã‚¯ã‚¿ãƒ¼ãƒ–ãƒãƒ³ãƒ‰å¢ƒç•Œãƒã‚§ãƒƒã‚¯ï¼ˆ3ãƒãƒ³ãƒ‰æ¯ï¼‰ â”€â”€
        if ((bi + 1) % 3 === 0) {
            completedOctaves++;
            const octIdx = completedOctaves - 1;
            const g = octaveDefs[octIdx].indices;
            const octValid = g.filter(i => thirdResults[i] !== null).length;
            if (octValid > 0) validOctaveCount++;

            const check = checkEarlyTermination(validOctaveCount, completedOctaves, snrProfile.minValidOctaves);
            if (check.stop) {
                earlyStop = true;
                earlyStopReason = check.reason;
                updateProgress(measuredCount, centerHz, 'stopping', totalBands);
                break;
            }
        }
    }

    // â”€â”€ éŒ²éŸ³åœæ­¢ãƒ»ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ— â”€â”€
    document.getElementById('recordingAlert').classList.remove('active');
    if (mediaStream) {
        mediaStream.getTracks().forEach(t => t.stop());
        mediaStream = null;
    }
    if (audioContext) {
        try { await audioContext.close(); } catch(e) {}
        audioContext = null;
    }

    // â”€â”€ ã‚¹ãƒ†ãƒ¼ã‚¸3: æ—©æœŸåœæ­¢ã®å ´åˆ â”€â”€
    if (earlyStop) {
        statusEl.textContent = 'ğŸ›‘ æ¸¬å®šã‚’æ—©æœŸåœæ­¢ã—ã¾ã—ãŸ';
        statusEl.className = 'status-msg error';
        const warnEl = document.getElementById('remeasureWarning');
        document.getElementById('warningReason').textContent = earlyStopReason;
        warnEl.style.display = 'block';
        startBtn.disabled = false;
        progressEl.style.display = 'none';
        return;
    }

    // â”€â”€ ã‚¹ãƒ†ãƒ¼ã‚¸3: å…¨ãƒãƒ³ãƒ‰å®Œäº† â†’ handleMeasurementResult ã¸ â”€â”€
    handleMeasurementResult({ type: 'result', thirdResults });
}
</script>

<script>
// ========================================
// Google Form é€ä¿¡ãƒ»ã‚°ãƒ©ãƒ•æç”»ï¼ˆæ—¢å­˜ã®ã¾ã¾ï¼‰
// ========================================
function sendToGoogleForm() {
    const formUrl = "https://docs.google.com/forms/d/e/1FAIpQLSedr8Z99dcRJuV3qYRmYddUUzYGrnvrz2aU3zbFvrwVpbTreQ/viewform";
    const appSelect = document.getElementById('appTarget');
    const app = appSelect.options[appSelect.selectedIndex].text;
    const w = document.getElementById('w').value;
    const d = document.getElementById('d').value;
    const h = document.getElementById('h').value;
    const size = `${w}m Ã— ${d}m Ã— ${h}m`;
    const wallSelect = document.getElementById('baseWall');
    const ceilingSelect = document.getElementById('baseCeiling');
    const floorSelect = document.getElementById('baseFloor');
    const base = `å£: ${wallSelect.options[wallSelect.selectedIndex].text}, å¤©äº•: ${ceilingSelect.options[ceilingSelect.selectedIndex].text}, åºŠ: ${floorSelect.options[floorSelect.selectedIndex].text}`;
    let productList = "";
    for (let i = 0; i < 3; i++) {
        const spec = selectedSpecs[i];
        const qty = parseInt(document.getElementById(`qty_${i}`).value) || 0;
        if (spec.category && spec.model && spec.thick && spec.size && qty > 0) {
            productList += `ãƒ»${SOUNDBOX_DB.products[spec.category].models[spec.model].n} / ${spec.thick}mm / ${spec.size} Ã— ${qty}æš\n`;
        }
    }
    if (!productList) productList = "é¸æŠãªã—";
    const rtText = document.getElementById('postRT_Avg').textContent;
    const params = new URLSearchParams();
    params.append("usp", "pp_url");
    params.append("entry.1871431492", app);
    params.append("entry.1902994140", size);
    params.append("entry.779901469", base);
    params.append("entry.364281805", productList);
    params.append("entry.1449240528", rtText);
    window.open(`${formUrl}?${params.toString()}`, '_blank');
}

function updateChart(rt_before, rt_after, targetRT) {
    const ctx = document.getElementById('rtChart').getContext('2d');
    if (chart) chart.destroy();
    chart = new Chart(ctx, {
        type: 'line',
        data: {
            labels: FREQS.map(f => f + 'Hz'),
            datasets: [
                { label: 'ç¾çŠ¶ (Before)', data: rt_before, borderColor: '#8b949e', backgroundColor: 'rgba(139, 148, 158, 0.05)', borderDash: [5, 5], borderWidth: 2, fill: false, tension: 0.3, pointRadius: 4, pointBackgroundColor: '#8b949e' },
                { label: 'å¯¾ç­–å¾Œ (After)', data: rt_after, borderColor: '#39d353', backgroundColor: 'rgba(57, 211, 83, 0.1)', borderWidth: 3, fill: true, tension: 0.3, pointRadius: 5, pointBackgroundColor: '#39d353', pointBorderColor: '#fff', pointBorderWidth: 2 },
                { label: 'ç›®æ¨™å€¤', data: FREQS.map(() => targetRT), borderColor: '#388bfd', backgroundColor: 'rgba(56, 139, 253, 0.05)', borderWidth: 2, borderDash: [10, 5], fill: false, pointRadius: 0 }
            ]
        },
        options: {
            responsive: true, maintainAspectRatio: false,
            interaction: { mode: 'index', intersect: false },
            scales: {
                y: { min: 0, max: 2.5, grid: { color: '#30363d', lineWidth: 1 }, ticks: { color: '#8b949e', font: { size: 11 }, callback: v => v.toFixed(1) + 's' }, title: { display: true, text: 'RT60 (sec)', color: '#8b949e', font: { size: 12, weight: 'bold' } } },
                x: { grid: { color: '#30363d', lineWidth: 1 }, ticks: { color: '#8b949e', font: { size: 11 } } }
            },
            plugins: {
                legend: { display: true, position: 'top', labels: { color: '#e6edf3', font: { size: 11 }, padding: 15, usePointStyle: true } },
                tooltip: { backgroundColor: 'rgba(22, 27, 34, 0.95)', titleColor: '#e6edf3', bodyColor: '#e6edf3', borderColor: '#30363d', borderWidth: 1, padding: 10, callbacks: { label: ctx => ctx.dataset.label + ': ' + ctx.parsed.y.toFixed(2) + 's' } }
            }
        }
    });
}
</script>

</body>
</html>
