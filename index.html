<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
    <link rel="canonical" href="https://soundbox.altwaves.co.jp/">
    <meta name="description" content="Soundbox Engine v6.9 (Rev 18.25): Honest Measurement â€” No Sabine Extrapolation">
    <title>Soundbox Material Calculator v7 | ãƒ—ãƒ­ãƒ•ã‚§ãƒƒã‚·ãƒ§ãƒŠãƒ«èª¿éŸ³è¨­è¨ˆãƒ„ãƒ¼ãƒ«</title>
    
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        :root { 
            --primary: #39d353; 
            --bg: #0d1117; 
            --card: #161b22; 
            --text: #e6edf3; 
            --dim: #8b949e; 
            --border: #30363d; 
            --accent: #388bfd; 
            --danger: #ff7b72; 
            --warning: #d29922; 
            --success: #39d353; 
            --caution: #f0883e;
        }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif; background-color: var(--bg); color: var(--text); padding: 15px; margin: 0; font-size: 13px; line-height: 1.4; }
        .container { max-width: 1000px; min-width: 800px; margin: auto; background: var(--card); padding: 25px; border-radius: 12px; border: 1px solid var(--border); box-shadow: 0 10px 40px rgba(0,0,0,0.5); position: relative; }
        .header { border-bottom: 1px solid var(--border); margin-bottom: 20px; padding-bottom: 12px; position: relative; }
        .header-top { display: flex; justify-content: space-between; align-items: flex-start; }
        h2 { color: var(--primary); margin: 0; font-size: 1.4rem; letter-spacing: 0.5px; }
        .subtitle { font-size: 0.85rem; color: var(--text); margin-top: 5px; font-weight: 500; }
        .logic-note { position: absolute; bottom: 8px; right: 0; font-size: 0.65rem; color: var(--dim); font-style: italic; }
        .btn-group { display: flex; gap: 10px; }
        .btn-base { border: none; padding: 7px 16px; border-radius: 4px; font-size: 0.75rem; cursor: pointer; font-weight: bold; transition: opacity 0.2s; text-decoration: none; }
        .btn-print { background: var(--border); color: var(--text); border: 1px solid var(--border); }
        .btn-estimate { background: var(--accent); color: white; }
        .btn-base:hover { opacity: 0.8; }
        .section-title { font-size: 0.8rem; font-weight: bold; color: var(--accent); margin: 20px 0 10px 0; border-left: 3px solid var(--accent); padding-left: 8px; }
        input, select, .custom-select-trigger { background: var(--bg); border: 1px solid var(--border); color: var(--text); padding: 0 10px; border-radius: 4px; width: 100%; box-sizing: border-box; font-size: 0.75rem; height: 36px; line-height: 34px; display: flex; align-items: center; }
        .grid-3 { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-bottom: 10px; }
        .grid-row { display: grid; grid-template-columns: 2fr 3.5fr 0.8fr 0.8fr 1fr; gap: 8px; margin-bottom: 8px; align-items: end; }
        label { font-size: 0.65rem; color: var(--dim); margin-bottom: 4px; display: block; }
        .custom-select-container { position: relative; width: 100%; }
        .custom-select-trigger { cursor: pointer; overflow: hidden; white-space: nowrap; text-overflow: ellipsis; border: 1px solid var(--border); }
        .sub-panel { display: none; position: absolute; top: 100%; left: 0; width: 540px; background: #1c2128; border: 1px solid var(--accent); border-radius: 8px; z-index: 100; box-shadow: 0 10px 30px rgba(0,0,0,0.8); padding: 15px; margin-top: 5px; }
        .sub-panel.active { display: block; }
        .panel-cols { display: grid; grid-template-columns: 1.4fr 0.8fr 1.2fr; gap: 12px; }
        .col-title { font-size: 0.6rem; color: var(--accent); margin-bottom: 8px; font-weight: bold; border-bottom: 1px solid var(--border); padding-bottom: 4px; }
        .col-item { padding: 6px 10px; border-radius: 4px; cursor: pointer; margin-bottom: 3px; font-size: 0.7rem; color: var(--text); }
        .col-item:hover { background: var(--border); }
        .col-item.selected { background: var(--accent); color: white; font-weight: bold; }
        .res-panel { display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; margin: 20px 0; }
        @media (max-width: 640px) {
            .res-panel { gap: 6px; }
            .res-card { padding: 8px 6px; }
            .res-val { font-size: 1.1rem; }
        }
        .res-card { background: var(--bg); padding: 15px; border-radius: 10px; border: 2px solid var(--border); text-align: center; }
        .res-val { font-size: 1.6rem; font-weight: bold; font-family: "Roboto Mono", monospace; }
        .chart-wrapper { position: relative; height: 320px; margin-top: 10px; border: 1px solid var(--border); border-radius: 8px; padding: 10px; background: rgba(0,0,0,0.2); }
        .footer-note { margin-top: 20px; padding: 18px; background: rgba(56, 139, 253, 0.05); border-radius: 8px; border: 1px solid var(--border); }
        .advice-tag { display: inline-block; padding: 2px 8px; border-radius: 4px; font-weight: bold; margin-bottom: 8px; font-size: 0.7rem; color: #000; }
        #print-only-notice { display: none; margin-top: 30px; padding: 20px; border: 1px solid #ddd; border-radius: 8px; font-size: 0.75rem; line-height: 1.6; color: #333; }
        .mode-switcher { display: flex; background: var(--bg); padding: 4px; border-radius: 8px; border: 1px solid var(--border); margin-bottom: 20px; }
        .mode-btn { flex: 1; padding: 10px; border: none; background: transparent; color: var(--dim); cursor: pointer; border-radius: 6px; font-weight: bold; transition: 0.2s; font-size: 0.75rem; }
        .mode-btn.active { background: var(--accent); color: white; }
        .mode-btn.active.measure { background: var(--warning); color: #000; }
        .calc-badge { display: inline-block; padding: 2px 6px; border-radius: 3px; font-size: 0.6rem; font-weight: bold; margin-left: 5px; background: var(--accent); color: white; }
        .measurement-panel { background: rgba(56, 139, 253, 0.05); border: 1px solid var(--accent); border-radius: 8px; padding: 15px; margin-bottom: 20px; }
        .measure-controls { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; align-items: start; }
        .status-msg { font-size: 0.75rem; margin-top: 10px; font-weight: 500; min-height: 1.2em; padding: 8px; border-radius: 4px; text-align: center; }
        .status-msg.ready { color: var(--dim); }
        .status-msg.calibrating { background: rgba(210, 153, 34, 0.1); color: var(--warning); }
        .status-msg.analyzing { background: rgba(56, 139, 253, 0.1); color: var(--accent); }
        .status-msg.success { background: rgba(57, 211, 83, 0.1); color: var(--success); }
        .status-msg.warning { background: rgba(210, 153, 34, 0.2); color: var(--warning); }
        .status-msg.error { background: rgba(255, 123, 114, 0.1); color: var(--danger); }

        /* ========================================
           æ¸¬å®šé€²æ—ãƒãƒ¼ */
        .measure-progress {
            margin-top: 10px;
            padding: 10px 12px;
            background: rgba(0,0,0,0.2);
            border-radius: 6px;
            border: 1px solid var(--border);
        }
        .measure-progress-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }
        .measure-progress-label {
            font-size: 0.72rem;
            color: var(--text);
            font-weight: 500;
        }
        .measure-progress-count {
            font-size: 0.65rem;
            color: var(--dim);
            font-family: "Roboto Mono", monospace;
        }
        .measure-progress-bar-track {
            width: 100%;
            height: 8px;
            background: var(--border);
            border-radius: 4px;
            overflow: hidden;
        }
        .measure-progress-bar-fill {
            height: 100%;
            width: 0%;
            background: var(--accent);
            border-radius: 4px;
            transition: width 0.4s ease;
        }
        .measure-progress-time {
            font-size: 0.65rem;
            color: var(--dim);
            margin-top: 5px;
            text-align: right;
        }
        /* ======================================== */

        .recording-flash { display: none; background: rgba(255, 123, 114, 0.1); border: 2px solid var(--danger); border-radius: 8px; padding: 15px; margin-top: 10px; text-align: center; }
        .recording-flash.active { display: block; animation: flash-border 1s infinite; }
        .flash-icon { font-size: 2rem; animation: blink 1s infinite; }
        .flash-text { font-size: 0.9rem; font-weight: bold; color: var(--danger); margin-top: 8px; }
        @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }
        @keyframes flash-border { 0%, 100% { border-color: var(--danger); } 50% { border-color: rgba(255, 123, 114, 0.3); } }
        .snr-indicator { margin-top: 10px; padding: 10px; background: rgba(0,0,0,0.2); border-radius: 6px; }
        .snr-bar { position: relative; width: 100%; height: 20px; background: var(--border); border-radius: 10px; overflow: hidden; margin-top: 5px; }
        .snr-value { height: 100%; background: linear-gradient(90deg, var(--danger), var(--warning), var(--success)); transition: width 0.3s; display: flex; align-items: center; justify-content: flex-end; padding-right: 8px; font-size: 0.7rem; font-weight: bold; color: white; }
        .warning-box { background: rgba(255, 123, 114, 0.1); border: 1px solid var(--danger); border-radius: 6px; padding: 12px; margin-top: 10px; font-size: 0.75rem; }
        .warning-box.warning-yellow { background: rgba(210, 153, 34, 0.15); border: 1px solid var(--warning); }
        .warning-box button { margin-top: 8px; padding: 6px 12px; background: var(--danger); color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.7rem; font-weight: bold; }
        .warning-box.warning-yellow button { background: var(--warning); }
        .warning-box button:hover { opacity: 0.8; }
        #warning-reason { margin-top: 5px; font-size: 0.7rem; color: var(--dim); }

        @media print {
            @page { size: A4; margin: 15mm; }
            body { background: white !important; color: black !important; padding: 0; }
            .container { box-shadow: none !important; border: none !important; width: 100% !important; max-width: none !important; min-width: 0 !important; background: white !important; padding: 0 !important; }
            .no-print, .logic-note, .mode-switcher, .measurement-panel { display: none !important; }
            .header { border-bottom: 2pt solid black !important; }
            h2, .section-title, .res-val, .subtitle { color: black !important; }
            input, select, .custom-select-trigger { border: none !important; background: transparent !important; color: black !important; padding: 0 !important; height: auto !important; appearance: none; }
            .grid-row { border-bottom: 0.5pt solid #eee; padding-bottom: 5px; }
            .res-card { border: 1pt solid black !important; background: white !important; }
            .chart-wrapper { border: 1pt solid #ccc !important; background: white !important; height: 300px !important; }
            .footer-note { border: 1pt solid #ccc !important; background: #f9f9f9 !important; color: black !important; }
            #print-only-notice { display: block !important; border: none !important; }
        }
    </style>
</head>
<body>
<div class="container">
    <div class="header">
        <div class="header-top">
            <h2>Soundbox Material Calculator</h2>
            <div class="btn-group no-print">
                <button class="btn-base btn-print" onclick="prepareForPrint()">çµæœã‚’å°åˆ· / PDFä¿å­˜</button>
                <button class="btn-base btn-estimate" onclick="sendToGoogleForm()">ã“ã®å†…å®¹ã§è¦‹ç©ã‚‚ã‚Šä¾é ¼</button>
            </div>
        </div>
        <div class="subtitle">Soundbox Engine v6.9 (Rev 18.25): Honest Measurement â€” No Sabine Extrapolation</div>
        <div class="logic-note">Hybrid Calculation Engine Active</div>
    </div>

    <div class="mode-switcher no-print">
        <button class="mode-btn active" id="btnSim" onclick="setMode('sim')">è¨­è¨ˆã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ (Sabine)</button>
        <button class="mode-btn" id="btnMeasure" onclick="setMode('measure')">å®Ÿæ¸¬å€¤ãƒ™ãƒ¼ã‚¹æ”¹å–„ (Eyring)</button>
    </div>

    <div id="measurementPanel" class="measurement-panel no-print" style="display:none;">
        <div style="font-size:0.8rem; font-weight:bold; color:var(--accent); margin-bottom:12px;">
            ğŸ¤ PRO æ¸¬å®šãƒ¢ãƒ¼ãƒ‰ (Eyring Method / Log-Sweep Analysis)
        </div>
        
        <div class="measure-controls">
            <div>
                <label>å…¥åŠ›ãƒ‡ãƒã‚¤ã‚¹ (ãƒã‚¤ã‚¯)</label>
                <select id="micSelect">
                    <option value="">ãƒ‡ãƒã‚¤ã‚¹ã‚’é¸æŠ...</option>
                </select>
            </div>
            <div>
                <label>å‡ºåŠ›ãƒ‡ãƒã‚¤ã‚¹ (ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼)</label>
                <select id="spkSelect">
                    <option value="">ãƒ‡ãƒã‚¤ã‚¹ã‚’é¸æŠ...</option>
                </select>
            </div>
            
            <!-- SNRãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠ -->
            <div>
                <label>æ¸¬å®šç²¾åº¦ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«</label>
                <select id="snrProfile" onchange="updateSNRProfileInfo()">
                    <option value="low">ä½ï¼ˆå†…è”µãƒ‡ãƒã‚¤ã‚¹å‘ã‘ï¼‰</option>
                    <option value="medium" selected>ä¸­ï¼ˆæ¨å¥¨ãƒ»Bluetoothï¼‰</option>
                    <option value="high">é«˜ï¼ˆISOæº–æ‹ ï¼‰</option>
                </select>
                <small id="snrProfileInfo" style="display:block; margin-top:4px; color:var(--dim); font-size:0.7rem; height:3.9em; line-height:1.3; overflow:hidden;">
                    ä¸€èˆ¬çš„ãªéŸ³éŸ¿æ¸¬å®šã«é©ã—ã¦ã„ã¾ã™
                </small>
            </div>
            
            <button class="btn-base btn-estimate" id="startMeasBtn" onclick="runMeasurementSequence()">
                æ¸¬å®šé–‹å§‹
            </button>
        </div>
        
        <div id="measureStatus" class="status-msg ready">Ready - ãƒ‡ãƒã‚¤ã‚¹ã‚’é¸æŠã—ã¦æ¸¬å®šé–‹å§‹ã—ã¦ãã ã•ã„</div>

        <!-- ========================================
             æ¸¬å®šé€²æ—ãƒãƒ¼
             ======================================== -->
        <div id="measureProgress" class="measure-progress" style="display:none;">
            <div class="measure-progress-header">
                <span id="progressLabel" class="measure-progress-label">æº–å‚™ä¸­...</span>
                <span id="progressCount" class="measure-progress-count">0 / 18</span>
            </div>
            <div class="measure-progress-bar-track">
                <div id="progressBar" class="measure-progress-bar-fill"></div>
            </div>
            <div id="progressTime" class="measure-progress-time">æ®‹ã‚Šç´„ 93 ç§’</div>
        </div>
        <!-- ======================================== -->
        
        <div id="snrIndicator" class="snr-indicator" style="display:none;">
            <label style="font-size:0.7rem; color:var(--dim);">ä¿¡å·å¯¾é›‘éŸ³æ¯” (S/N Ratio)</label>
            <div class="snr-bar">
                <div id="snrValue" class="snr-value" style="width:0%;"></div>
            </div>
        </div>
        
        <div id="recordingAlert" class="recording-flash">
            <div class="flash-icon">ğŸ”´</div>
            <div class="flash-text">ğŸ“¢ æ¸¬å®šä¸­ã§ã™ - é™ã‹ã«ã—ã¦ãã ã•ã„</div>
        </div>
        
        <div id="remeasureWarning" class="warning-box" style="display:none;">
            <strong>âš ï¸ ãƒ‡ãƒ¼ã‚¿å“è³ªãŒä¸è¶³ã—ã¦ã„ã¾ã™</strong>
            <div id="warningReason"></div>
            <button onclick="runMeasurementSequence()">å†æ¸¬å®šã‚’å®Ÿè¡Œ</button>
        </div>
        
        <div id="manualInputPanel" style="display:none; margin-top:15px; padding:12px; background:rgba(0,0,0,0.2); border-radius:6px;">
            <label style="font-size:0.7rem; color:var(--warning); font-weight:bold;">
                æ‰‹å‹•å…¥åŠ›ãƒ¢ãƒ¼ãƒ‰ï¼ˆæ¸¬å®šå€¤ã‚’ç›´æ¥å…¥åŠ›ï¼‰
            </label>
            <div style="display: grid; grid-template-columns: repeat(6, 1fr); gap: 5px; margin-top: 8px;">
                <div><label>125Hz</label><input type="number" id="m125" value="0.80" step="0.01" style="height:28px; font-size:0.7rem; text-align:center;" oninput="calculate()"></div>
                <div><label>250Hz</label><input type="number" id="m250" value="0.70" step="0.01" style="height:28px; font-size:0.7rem; text-align:center;" oninput="calculate()"></div>
                <div><label>500Hz</label><input type="number" id="m500" value="0.60" step="0.01" style="height:28px; font-size:0.7rem; text-align:center;" oninput="calculate()"></div>
                <div><label>1kHz</label><input type="number" id="m1k" value="0.60" step="0.01" style="height:28px; font-size:0.7rem; text-align:center;" oninput="calculate()"></div>
                <div><label>2kHz</label><input type="number" id="m2k" value="0.50" step="0.01" style="height:28px; font-size:0.7rem; text-align:center;" oninput="calculate()"></div>
                <div><label>4kHz</label><input type="number" id="m4k" value="0.50" step="0.01" style="height:28px; font-size:0.7rem; text-align:center;" oninput="calculate()"></div>
            </div>
            <div style="font-size:0.65rem; color:var(--dim); margin-top:8px;">
                â€» è‡ªå‹•æ¸¬å®šãŒåˆ©ç”¨ã§ããªã„å ´åˆã€å¤–éƒ¨æ¸¬å®šå™¨ã§å–å¾—ã—ãŸæ®‹éŸ¿æ™‚é–“ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„
            </div>
        </div>
    </div>

    <div class="section-title">1. åŸºæœ¬ç’°å¢ƒè¨­å®š</div>
    <div class="grid-3">
        <div>
            <label>åˆ©ç”¨ç›®çš„ (ç›®æ¨™å€¤)</label>
            <select id="appTarget"></select>
        </div>
        <div>
            <label>éƒ¨å±‹ã‚µã‚¤ã‚º W / D / H [m]</label>
            <div style="display:flex; gap:4px;">
                <input type="number" id="w" value="4.0" step="0.1">
                <input type="number" id="d" value="6.0" step="0.1">
                <input type="number" id="h" value="2.6" step="0.1">
            </div>
        </div>
        <div>
            <label>å£é¢ä»•ä¸Šã’ (ãƒ™ãƒ¼ã‚¹)</label>
            <select id="baseWall"></select>
        </div>
    </div>
    <div class="grid-3">
        <div><label>å¤©äº•ä»•ä¸Šã’</label><select id="baseCeiling"></select></div>
        <div><label>åºŠä»•ä¸Šã’</label><select id="baseFloor"></select></div>
        <div style="display:flex; align-items:flex-end; padding-bottom:5px;">
            <input type="checkbox" id="showSpecial" style="width:16px; margin-right:8px;">
            <label for="showSpecial" style="margin:0; cursor:pointer; color:var(--accent);">é–‹å£éƒ¨(çª“ç­‰)ã‚’è€ƒæ…®ã™ã‚‹</label>
        </div>
    </div>

    <div id="specialPanel" style="display:none; background: rgba(56, 139, 253, 0.05); padding: 12px; border-radius: 6px; margin-bottom: 10px; border: 1px dashed var(--accent);">
        <div class="grid-3" style="grid-template-columns: 2fr 1fr 1fr;">
            <div><label>è¿½åŠ ç´ æ</label><select id="exMat"></select></div>
            <div><label>é¢ç© [ã¡]</label><input type="number" id="exArea" value="2.0" step="0.1"></div>
        </div>
    </div>

    <div class="section-title">2. è£½å“ã‚»ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³</div>
    <div id="sbInputs"></div>

    <div class="res-panel">
        <div class="res-card">
            <label style="font-size:0.6rem">å¹³å‡æ®‹éŸ¿æ™‚é–“ (500Hz-1kHz)</label>
            <div id="postRT_Avg" class="res-val">-</div>
            <div id="measuredBandInfo" style="font-size:0.58rem; color:var(--dim); margin-top:2px; min-height:0.9em;"></div>
            <div id="targetLabel" style="font-size:0.6rem; color:var(--dim)">ç›®æ¨™: -</div>
            <div id="calcMethod" style="font-size:0.55rem; color:var(--dim); margin-top:3px;">
                <span class="calc-badge" id="methodBadge">SABINE</span>
            </div>
        </div>
        <div class="res-card" id="cardHealth">
            <label style="font-size:0.6rem">å®Ÿç”¨æ€§è©•ä¾¡</label>
            <div id="achievementRate" class="res-val">-</div>
            <div id="healthStatus" style="font-size:0.65rem; font-weight:bold;">-</div>
        </div>
        <div class="res-card">
            <label style="font-size:0.6rem">å°å…¥é¢ç© / æ‹¡æ•£å¯„ä¸åº¦</label>
            <div id="totalPanelArea" class="res-val" style="font-size:1.1rem;">-</div>
            <div id="diffusionBalance" style="font-size:0.65rem; color:var(--primary)">-</div>
        </div>
    </div>

    <div class="chart-wrapper"><canvas id="rtChart"></canvas></div>

    <div class="footer-note">
        <div id="adviceHeader" class="advice-tag"></div>
        <div id="detailedNote" style="font-size:0.75rem;"></div>
    </div>

    <div id="print-only-notice">
        <strong>ã€ã”æ¡ˆå†…ã€‘</strong><br>
        æœ¬ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³çµæœã¯ã€å…¥åŠ›ã•ã‚ŒãŸæ¡ä»¶ä¸‹ã«ãŠã‘ã‚‹ã‚»ãƒ¼ãƒ“ãƒ³å¼ã«åŸºã¥ã„ãŸè¨ˆç®—ç›®å®‰ã§ã‚ã‚Šã€å®Ÿéš›ã®æ–½å·¥ç¾å ´ã®ç’°å¢ƒï¼ˆå®¶å…·ã®é…ç½®ã€ä¸‹åœ°ã®æ§‹é€ ã€æ¸©æ¹¿åº¦ç­‰ï¼‰ã«ã‚ˆã‚Šå¤‰å‹•ã™ã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚<br>
        ã‚ˆã‚Šé«˜åº¦ãªè©³ç´°è§£æã‚„ã€ãƒ‘ãƒãƒ«ã®å…·ä½“çš„ãªé…ç½®è¨ˆç”»ï¼ˆåå°„éŸ³åˆ†å¸ƒã®æœ€é©åŒ–ãªã©ï¼‰ã‚’ã”å¸Œæœ›ã®å ´åˆã¯ã€<strong>AFMG EASE</strong> ã«ã‚ˆã‚‹ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã€ã¾ãŸã¯å¼Šç¤¾å°‚é–€ã‚¹ã‚¿ãƒƒãƒ•ã¾ã§ãŠå•ã„åˆã‚ã›ãã ã•ã„ã€‚
    </div>
</div>

<script>
const SOUNDBOX_DB = {
    apps: [
        { id: "office", name: "ã‚ªãƒ•ã‚£ã‚¹ / ä¸€èˆ¬ä¼šè­°å®¤ (0.6s)", t: 0.6 },
        { id: "web_mtg", name: "Webä¼šè­°å®¤ / ã‚ªãƒ³ãƒ©ã‚¤ãƒ³MTG (0.4s)", t: 0.4 },
        { id: "studio", name: "ãƒ¬ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚¹ã‚¿ã‚¸ã‚ª (0.4s)", t: 0.4 },
        { id: "audio", name: "ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªãƒ«ãƒ¼ãƒ  / ãƒ›ãƒ¼ãƒ ã‚·ã‚¢ã‚¿ãƒ¼ (0.45s)", t: 0.45 },
        { id: "living", name: "ãƒªãƒ“ãƒ³ã‚° / ä¸€èˆ¬ä½å®… (0.5s)", t: 0.5 },
        { id: "broadcast", name: "é…ä¿¡ã‚¹ã‚¿ã‚¸ã‚ª / ãƒãƒƒãƒ‰ã‚­ãƒ£ã‚¹ãƒˆ (0.35s)", t: 0.35 },
        { id: "classroom", name: "æ•™å®¤ / ã‚»ãƒŸãƒŠãƒ¼ãƒ«ãƒ¼ãƒ  (0.7s)", t: 0.7 },
        { id: "hall", name: "å¤šç›®çš„ãƒ›ãƒ¼ãƒ« / ä½“è‚²é¤¨ (1.2s)", t: 1.2 }
    ],
    materials: {
        "plasterboard": { name: "çŸ³è†ãƒœãƒ¼ãƒ‰ + å£ç´™", data: [0.29, 0.10, 0.05, 0.04, 0.07, 0.09] },
        "concrete": { name: "ã‚³ãƒ³ã‚¯ãƒªãƒ¼ãƒˆæ‰“æ”¾ã—", data: [0.01, 0.01, 0.01, 0.02, 0.02, 0.03] },
        "glass": { name: "ã‚¬ãƒ©ã‚¹çª“ / é¡", data: [0.35, 0.25, 0.18, 0.12, 0.07, 0.04] },
        "carpet": { name: "ã‚¿ã‚¤ãƒ«ã‚«ãƒ¼ãƒšãƒƒãƒˆ", data: [0.02, 0.05, 0.10, 0.20, 0.30, 0.40] },
        "wood": { name: "ãƒ•ãƒ­ãƒ¼ãƒªãƒ³ã‚° / æœ¨æ¿", data: [0.15, 0.11, 0.10, 0.07, 0.06, 0.07] },
        "curtain": { name: "ã‚«ãƒ¼ãƒ†ãƒ³ (é‡ç›®/ãƒ—ãƒªãƒ¼ãƒ„æœ‰)", data: [0.07, 0.31, 0.49, 0.75, 0.70, 0.60] },
        "gw_insulation": { name: "ã‚°ãƒ©ã‚¹ã‚¦ãƒ¼ãƒ«æ–­ç†±æ (50mm/32k)", data: [0.25, 0.65, 0.95, 0.98, 0.95, 0.90] }
    },
    products: {
        "STANDARD": {
            name: "1. ã‚¹ã‚¿ãƒ³ãƒ€ãƒ¼ãƒ‰ãƒ‘ãƒãƒ« (EQ Series)",
            models: {
                "STD": { n: "EQ Standard", d: { "30": [0.20, 0.50, 0.95, 1.05, 1.05, 1.00], "60": [0.30, 0.80, 1.10, 1.10, 1.00, 1.00], "120": [0.50, 0.95, 1.10, 1.05, 1.00, 0.95] }, s: { "6x6": 0.36, "6x12": 0.72 } },
                "R": { n: "EQ R (Rococo)", d: { "30": [0.25, 0.55, 0.98, 1.08, 1.07, 1.02], "60": [0.35, 0.85, 1.12, 1.12, 1.02, 1.02], "120": [0.55, 0.98, 1.12, 1.08, 1.02, 0.98] }, s: { "6x6": 0.36, "6x12": 0.72 } },
                "B": { n: "EQ B (Baroque)", d: { "30": [0.22, 0.52, 0.96, 1.06, 1.06, 1.01], "60": [0.32, 0.82, 1.11, 1.11, 1.01, 1.01], "120": [0.52, 0.96, 1.11, 1.06, 1.01, 0.96] }, s: { "6x6": 0.36, "6x12": 0.72 } },
                "F": { n: "EQ Fabric", d: { "30": [0.18, 0.48, 0.93, 1.03, 1.03, 0.98], "60": [0.28, 0.78, 1.08, 1.08, 0.98, 0.98] }, s: { "6x6": 0.36, "6x12": 0.72 } }
            }
        },
        "OFFICE_FABRIC": {
            name: "2. ã‚ªãƒ•ã‚£ã‚¹ç”¨ãƒ•ã‚¡ãƒ–ãƒªãƒƒã‚¯ (Walleasear)",
            models: {
                "EQ30T": { n: "EQ 30T (å¤§é¢ç©æ–½å·¥)", d: { "30": [0.19, 0.49, 0.94, 1.04, 1.04, 0.99] }, s: { "12x6": 0.72, "24x6": 1.44 } },
                "EQ60T": { n: "EQ 60T (å¤§é¢ç©æ–½å·¥)", d: { "60": [0.29, 0.79, 1.09, 1.09, 0.99, 0.99] }, s: { "12x6": 0.72, "24x6": 1.44 } },
                "EQ100T": { n: "EQ 100T (å¤§é¢ç©æ–½å·¥)", d: { "100": [0.45, 0.92, 1.10, 1.07, 1.00, 0.96] }, s: { "12x6": 0.72, "24x6": 1.44 } }
            }
        },
        "ENGINEERING": {
            name: "3. ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ãƒªãƒ³ã‚°è£½å“",
            models: {
                "MT_BAFFLE": { n: "MT Baffle (å¤©äº•åŠä¸‹ã’)", d: { "40": [0.42, 0.78, 0.95, 0.98, 0.98, 0.96] }, s: { "6x4": 0.24, "12x4": 0.48 } },
                "CM": { n: "CM Series (ã‚¯ãƒ©ã‚¦ãƒ‰/å¤©äº•ç”¨)", d: { "30": [0.21, 0.53, 0.88, 0.96, 0.98, 0.94], "60": [0.38, 0.84, 1.05, 1.08, 1.02, 0.98] }, s: { "6x6": 0.36 } },
                "IMAGINE": { n: "Imagine Panel (æ„åŒ ãƒ‘ãƒãƒ«)", d: { "30": [0.17, 0.46, 0.91, 1.02, 1.03, 0.97] }, s: { "6x6": 0.36 } }
            }
        },
        "BROADBAND": {
            name: "4. ãƒ–ãƒ­ãƒ¼ãƒ‰ãƒãƒ³ãƒ‰å¸éŸ³æ",
            models: {
                "F300H": { n: "F300H (é«˜åŸŸç‰¹åŒ–)", d: { "30": [0.10, 0.35, 0.70, 0.95, 1.08, 1.05] }, s: { "3x3": 0.09 } },
                "F300M": { n: "F300M (ä¸­åŸŸç‰¹åŒ–)", d: { "30": [0.15, 0.55, 0.98, 1.05, 0.95, 0.85] }, s: { "3x3": 0.09 } },
                "F300W": { n: "F300W (ä½åŸŸç‰¹åŒ–)", d: { "30": [0.35, 0.75, 0.95, 0.90, 0.80, 0.70] }, s: { "3x3": 0.09 } }
            }
        },
        "BASSTRAP": {
            name: "5. ãƒ™ãƒ¼ã‚¹ãƒˆãƒ©ãƒƒãƒ— (ä½åŸŸåˆ¶å¾¡)",
            models: {
                // C300W: v2å®Ÿæ¸¬å€¤ã«æ›´æ–°ï¼ˆÎ± 125-4kHzï¼‰
                "C300W":      { n: "C300W (ã‚³ãƒ¼ãƒŠãƒ¼ç”¨)",   d: { "300": [0.80,0.95,0.99,0.99,0.98,0.97] }, s: { "ã‚³ãƒ¼ãƒŠãƒ¼è¨­ç½®": null }, sc: [0.05,0.07,0.09,0.10,0.12,0.10], s_est: true },
                // CYLINDER350: v2ã«å¯¾å¿œè£½å“ãªã— â†’ ãƒ•ã‚§ãƒ¼ã‚º3ã§å‰Šé™¤
                "CYLINDER350":{ n: "Cylinder 350 (å††ç­’å‹)", d: { "350": [0.70,0.98,1.08,1.02,0.94,0.88] }, s: { "Ã˜350mm": 0.12 } }
            }
        },
        "DIFFUSION": {
            name: "6. æ‹¡æ•£ãƒ‘ãƒãƒ« (éŸ¿ãã®èª¿æ•´)",
            models: {
                // Cloud-2C: v2_updatedå®Ÿæ¸¬å€¤ã«æ›´æ–°ï¼ˆÎ±ãƒ»dcæ›´æ–°ã€sc=æ¨å®šï¼‰
                "CLOUD2C":  { n: "Cloud-2C (å¤©äº•åŠä¸‹å‹)", d: { "90": [0.33,0.42,0.38,0.35,0.23,0.22] }, s: { "600Ã—600mm": 0.36 }, diffusion: 0.28, sc: [0.15,0.20,0.25,0.28,0.30,0.28], dc: [0.18,0.22,0.28,0.32,0.32,0.30], s_est: true },
                // CLOUD2Dãƒ»PEAK_SQ: v2ã«å¯¾å¿œè£½å“ãªã— â†’ ãƒ•ã‚§ãƒ¼ã‚º3ã§å‰Šé™¤
                "CLOUD2D":  { n: "Cloud 2D (å‡¹å‡¸æ‹¡æ•£)",   d: { "70":  [0.08,0.15,0.22,0.18,0.15,0.12] }, s: { "600Ã—600mm": 0.36 }, diffusion: 0.85 },
                "PEAK_SQ":  { n: "Peak SQ (ã‚¹ã‚«ã‚¤ãƒ©ã‚¤ãƒ³)", d: { "80":  [0.10,0.18,0.25,0.20,0.18,0.15] }, s: { "600Ã—600mm": 0.36 }, diffusion: 0.9  },
                // N29: v2_updatedå®Ÿæ¸¬å€¤ã«æ›´æ–°ï¼ˆÎ±ãƒ»scãƒ»dcå…¨ã¦â—ï¼‰
                "QRD_N29":  { n: "N29 (éå‘¨æœŸQRDå‹)",    d: { "120": [0.08,0.08,0.10,0.12,0.15,0.18] }, s: { "æ¨™æº–": 0.36 },    diffusion: 0.35, sc: [0.00,0.00,0.28,0.52,0.25,1.00], dc: [0.68,0.68,0.98,1.00,0.55,0.65], s_est: false }
            }
        },
        "HYBRID": {
            name: "7. ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰ (å¸éŸ³+æ‹¡æ•£)",
            models: {
                // AQ1000S: v2å®Ÿæ¸¬å€¤ã«æ›´æ–°ï¼ˆÎ±ãƒ»ã‚µã‚¤ã‚ºãƒ»åšã¿ã‚­ãƒ¼ä¿®æ­£ï¼‰
                "AQ1000S": { n: "AQ1000S (æœ¨è£½ã‚¹ãƒ©ãƒƒãƒˆ)", d: { "150": [0.32,0.62,0.80,0.74,0.67,0.62] }, s: { "1600Ã—600mm": 0.96 }, diffusion: 0.53, sc: [0.34,0.44,0.52,0.54,0.54,0.52], s_est: true },
                // WAVE600: v2å®Ÿæ¸¬å€¤ã«æ›´æ–°ï¼ˆÎ±ãƒ»ã‚µã‚¤ã‚ºãƒ»åšã¿ã‚­ãƒ¼ä¿®æ­£ãƒ»dcè¿½åŠ ï¼‰
                "WAVE600": { n: "WAVE600 (ã‚¦ã‚§ãƒ¼ãƒ–å‹)",  d: { "80":  [0.28,0.62,0.88,0.90,0.88,0.85] }, s: { "600Ã—600mm": 0.36, "600Ã—1200mm": 0.72 }, diffusion: 0.35, sc: [0.18,0.25,0.32,0.35,0.38,0.36], dc: [0.22,0.30,0.38,0.40,0.38,0.36], s_est: true },
                // BREEZE: v2ã«å¯¾å¿œè£½å“ãªã— â†’ ãƒ•ã‚§ãƒ¼ã‚º3ã§å‰Šé™¤
                "BREEZE":  { n: "Breeze (æ„åŒ æ€§ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰)", d: { "40": [0.20,0.55,0.88,0.92,0.85,0.78] }, s: { "600Ã—600mm": 0.36 }, diffusion: 0.35 }
            }
        }
    }
};

const FREQS = [125, 250, 500, 1000, 2000, 4000];
let chart;
let selectedSpecs = [{}, {}, {}];
let lastData = {};
let currentMode = 'sim';
let measurementData = null;
let roomSizeBuffer = { w: 4.0, d: 6.0, h: 2.6 }; // éƒ¨å±‹ã‚µã‚¤ã‚ºã®ãƒãƒƒãƒ•ã‚¡
let measurementActive = false; // æ¸¬å®šå€¤ä½¿ç”¨ä¸­ãƒ•ãƒ©ã‚°
const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent); // iOSåˆ¤å®š

// SNRãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«å®šç¾©ï¼ˆ3æ®µéšï¼‰
const SNR_PROFILES = {
    low: {
        label: 'ä½ï¼ˆå†…è”µãƒ‡ãƒã‚¤ã‚¹å‘ã‘ï¼‰',
        threshold: 8,          // SNRé–¾å€¤ [dB]
        description: 'ã‚¹ãƒãƒ›/PCå†…è”µã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼ãƒ»ãƒã‚¤ã‚¯',
        warning: 'ç²¾åº¦ã¯ä½ä¸‹ã—ã¾ã™ãŒã€ç°¡æ˜“æ¸¬å®šãŒå¯èƒ½ã§ã™',
        skipBands: [0, 1, 2],  // 100, 125, 160Hz ã‚’æ¸¬å®šå¯¾è±¡å¤–ï¼ˆå†…è”µSPã®ç‰©ç†é™ç•Œï¼‰
        totalBands: 15,        // 18 - 3 = 15ãƒãƒ³ãƒ‰æ¸¬å®š
        minValidOctaves: 4     // 5ã‚ªã‚¯ã‚¿ãƒ¼ãƒ–ï¼ˆ250Hzã€œ4kHzï¼‰ä¸­4ä»¥ä¸Šã§æœ‰åŠ¹
    },
    medium: {
        label: 'ä¸­ï¼ˆBluetooth/å°å‹ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼ï¼‰',
        threshold: 15,         // dB
        description: 'Bluetoothã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼ã€å°å‹å¤–éƒ¨ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼',
        warning: 'ä¸€èˆ¬çš„ãªéŸ³éŸ¿æ¸¬å®šã«é©ã—ã¦ã„ã¾ã™',
        skipBands: [],         // å…¨18ãƒãƒ³ãƒ‰æ¸¬å®š
        totalBands: 18,
        minValidOctaves: 4     // 6ã‚ªã‚¯ã‚¿ãƒ¼ãƒ–ä¸­4ä»¥ä¸Š
    },
    high: {
        label: 'é«˜ï¼ˆISOæº–æ‹ ãƒ»ãƒ—ãƒ­æ¸¬å®šï¼‰',
        threshold: 25,         // dB
        description: 'å°‚ç”¨æ¸¬å®šæ©Ÿå™¨ã€å¤§å‹ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼ã‚·ã‚¹ãƒ†ãƒ ',
        warning: 'ISO 3382æº–æ‹ ã®é«˜ç²¾åº¦æ¸¬å®š',
        skipBands: [],         // å…¨18ãƒãƒ³ãƒ‰æ¸¬å®š
        totalBands: 18,
        minValidOctaves: 5     // 6ã‚ªã‚¯ã‚¿ãƒ¼ãƒ–ä¸­5ä»¥ä¸Šï¼ˆé«˜ç²¾åº¦è¦ä»¶ï¼‰
    }
};

let currentSNRProfile = 'medium'; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ

function init() {
    const appSelect = document.getElementById('appTarget');
    SOUNDBOX_DB.apps.forEach((app, idx) => {
        const option = document.createElement('option');
        option.value = idx;
        option.textContent = app.name;
        appSelect.appendChild(option);
    });

    const materialSelects = ['baseWall', 'baseCeiling', 'baseFloor', 'exMat'];
    materialSelects.forEach(selectId => {
        const select = document.getElementById(selectId);
        for (let key in SOUNDBOX_DB.materials) {
            const option = document.createElement('option');
            option.value = key;
            option.textContent = SOUNDBOX_DB.materials[key].name;
            select.appendChild(option);
        }
    });

    const sbInputsContainer = document.getElementById('sbInputs');
    sbInputsContainer.innerHTML = '';
    for (let i = 0; i < 3; i++) {
        const row = document.createElement('div');
        row.className = 'grid-row';
        row.innerHTML = `
            <div><label>ã‚«ãƒ†ã‚´ãƒªãƒ¼</label><select id="cat_${i}" onchange="onCategoryChange(${i})"></select></div>
            <div class="custom-select-container">
                <div class="custom-select-trigger" id="trigger_${i}" onclick="togglePanel(${i})">è£½å“ã‚¹ãƒšãƒƒã‚¯ã‚’é¸æŠ...</div>
                <div class="sub-panel" id="panel_${i}">
                    <div class="panel-cols">
                        <div id="col_model_${i}"></div>
                        <div id="col_thick_${i}"></div>
                        <div id="col_size_${i}"></div>
                    </div>
                </div>
            </div>
            <input type="number" id="qty_${i}" value="0" min="0" step="1" oninput="calculate()">
            <div id="unitArea_${i}" style="font-size:0.65rem; color:var(--dim); text-align:center;">-</div>
            <div id="totalArea_${i}" style="font-size:0.7rem; color:var(--primary); text-align:right; font-weight:bold;">-</div>
        `;
        sbInputsContainer.appendChild(row);

        const catSelect = document.getElementById(`cat_${i}`);
        const defaultOption = document.createElement('option');
        defaultOption.value = '';
        defaultOption.textContent = 'é¸æŠã—ã¦ãã ã•ã„...';
        catSelect.appendChild(defaultOption);
        for (let catKey in SOUNDBOX_DB.products) {
            const option = document.createElement('option');
            option.value = catKey;
            option.textContent = SOUNDBOX_DB.products[catKey].name;
            catSelect.appendChild(option);
        }
    }

    document.getElementById('appTarget').addEventListener('change', calculate);
    document.getElementById('w').addEventListener('input', calculate);
    document.getElementById('d').addEventListener('input', calculate);
    document.getElementById('h').addEventListener('input', calculate);
    document.getElementById('baseWall').addEventListener('change', calculate);
    document.getElementById('baseCeiling').addEventListener('change', calculate);
    document.getElementById('baseFloor').addEventListener('change', calculate);
    document.getElementById('exArea').addEventListener('input', calculate);
    document.getElementById('exMat').addEventListener('change', calculate);
    document.getElementById('showSpecial').addEventListener('change', function() {
        document.getElementById('specialPanel').style.display = this.checked ? 'block' : 'none';
        calculate();
    });
    calculate();
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// éƒ¨å±‹ã‚µã‚¤ã‚ºå…¥åŠ›æ¬„ã®åˆ¶å¾¡
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function saveRoomSizeToBuffer() {
    roomSizeBuffer.w = parseFloat(document.getElementById('w').value);
    roomSizeBuffer.d = parseFloat(document.getElementById('d').value);
    roomSizeBuffer.h = parseFloat(document.getElementById('h').value);
}

function restoreRoomSizeFromBuffer() {
    document.getElementById('w').value = roomSizeBuffer.w;
    document.getElementById('d').value = roomSizeBuffer.d;
    document.getElementById('h').value = roomSizeBuffer.h;
}

function disableRoomSizeInputs() {
    document.getElementById('w').disabled = true;
    document.getElementById('d').disabled = true;
    document.getElementById('h').disabled = true;
}

function enableRoomSizeInputs() {
    document.getElementById('w').disabled = false;
    document.getElementById('d').disabled = false;
    document.getElementById('h').disabled = false;
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SNRãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«æƒ…å ±æ›´æ–°
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function updateSNRProfileInfo() {
    const select = document.getElementById('snrProfile');
    const info   = document.getElementById('snrProfileInfo');
    const key    = select.value;
    const profile = SNR_PROFILES[key];

    if (profile) {
        const skipNote = profile.skipBands.length > 0
            ? '100ã€œ160Hz ã¯æ¸¬å®šå¯¾è±¡å¤–ï¼ˆå†…è”µSPç‰©ç†é™ç•Œï¼‰'
            : 'å…¨18ãƒãƒ³ãƒ‰ï¼ˆ100Hzã€œ5kHzï¼‰ã‚’æ¸¬å®š';
        info.innerHTML =
            profile.description + '<br>' +
            'SNRé–¾å€¤: ' + profile.threshold + 'dB &nbsp; ' + skipNote + '<br>' +
            profile.warning;
        currentSNRProfile = key;
    }
}

function setMode(mode) {
    currentMode = mode;
    const btnSim = document.getElementById('btnSim');
    const btnMeasure = document.getElementById('btnMeasure');
    
    if (mode === 'sim') {
        btnSim.classList.add('active');
        btnSim.classList.remove('measure');
        btnMeasure.classList.remove('active', 'measure');
        document.getElementById('measurementPanel').style.display = 'none';
        
        // ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒ¢ãƒ¼ãƒ‰ï¼šéƒ¨å±‹ã‚µã‚¤ã‚ºå…¥åŠ›ã‚’å¾©å…ƒãƒ»ç·¨é›†å¯èƒ½
        enableRoomSizeInputs();
        if (measurementActive) {
            restoreRoomSizeFromBuffer();
        }
        measurementActive = false;
        
    } else {
        btnSim.classList.remove('active');
        btnMeasure.classList.add('active', 'measure');
        document.getElementById('measurementPanel').style.display = 'block';
        enumerateDevices();
        
        // æ¸¬å®šãƒ¢ãƒ¼ãƒ‰ï¼šæ¸¬å®šå€¤ãŒã‚ã‚‹å ´åˆã¯ã‚°ãƒ¬ãƒ¼ã‚¢ã‚¦ãƒˆ
        if (measurementData && measurementData.length > 0) {
            disableRoomSizeInputs();
            measurementActive = true;
        } else {
            enableRoomSizeInputs();
            measurementActive = false;
        }
    }
    
    const methodBadge = document.getElementById('methodBadge');
    if (mode === 'sim') {
        methodBadge.textContent = 'SABINE';
        methodBadge.style.background = 'var(--accent)';
    } else if (window._measurementMethod) {
        methodBadge.textContent = window._measurementMethod;
        const methodColors = { 'T60': 'var(--success)', 'T30': 'var(--warning)', 'T20': 'var(--caution)' };
        methodBadge.style.background = methodColors[window._measurementMethod] || 'var(--warning)';
    } else {
        methodBadge.textContent = 'EYRING';
        methodBadge.style.background = 'var(--warning)';
    }
    calculate();
}

async function enumerateDevices() {
    const statusEl = document.getElementById('measureStatus');
    const micSelect = document.getElementById('micSelect');
    const spkSelect = document.getElementById('spkSelect');
    
    try {
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            throw new Error('ã“ã®ãƒ–ãƒ©ã‚¦ã‚¶ã¯éŸ³å£°å…¥åŠ›ã«å¯¾å¿œã—ã¦ã„ã¾ã›ã‚“ã€‚Chrome/Edge/Firefoxã‚’ã”åˆ©ç”¨ãã ã•ã„ã€‚');
        }
        if (location.protocol !== 'https:' && location.hostname !== 'localhost') {
            throw new Error('ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ä¸Šã®ç†ç”±ã«ã‚ˆã‚Šã€HTTPSãƒšãƒ¼ã‚¸ã§ã®ã¿å‹•ä½œã—ã¾ã™ã€‚');
        }
        
        statusEl.textContent = 'ãƒã‚¤ã‚¯ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹æ¨©é™ã‚’ãƒªã‚¯ã‚¨ã‚¹ãƒˆä¸­...';
        statusEl.className = 'status-msg calibrating';
        
        // æ¨©é™å–å¾—ï¼ˆãƒ‡ãƒã‚¤ã‚¹ãƒ©ãƒ™ãƒ«ã‚’è§£æ”¾ã™ã‚‹ãŸã‚ï¼‰
        let stream;
        try {
            stream = await navigator.mediaDevices.getUserMedia({
                audio: {
                    echoCancellation: false,
                    noiseSuppression: false,
                    autoGainControl: false
                }
            });
        } catch (permError) {
            if (permError.name === 'NotAllowedError') {
                throw new Error('ãƒã‚¤ã‚¯ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ãŒæ‹’å¦ã•ã‚Œã¾ã—ãŸã€‚ãƒ–ãƒ©ã‚¦ã‚¶ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ãƒãƒ¼æ¨ªã®ã‚¢ã‚¤ã‚³ãƒ³ã‹ã‚‰ãƒã‚¤ã‚¯ã‚’è¨±å¯ã—ã¦ãã ã•ã„ã€‚');
            } else if (permError.name === 'NotFoundError') {
                throw new Error('ãƒã‚¤ã‚¯ãƒ‡ãƒã‚¤ã‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚ãƒã‚¤ã‚¯ãŒæ¥ç¶šã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèªã—ã¦ãã ã•ã„ã€‚');
            } else {
                throw new Error('ãƒã‚¤ã‚¯ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + permError.message);
            }
        }
        
        // æ¨©é™å–å¾—ç›´å¾Œã¯300mså¾…æ©Ÿï¼ˆãƒ–ãƒ©ã‚¦ã‚¶ã®ãƒ‡ãƒã‚¤ã‚¹æƒ…å ±æ›´æ–°ã‚’å¾…ã¤ï¼‰
        statusEl.textContent = 'ãƒ‡ãƒã‚¤ã‚¹ã‚’æ¤œç´¢ä¸­...';
        await new Promise(resolve => setTimeout(resolve, 300));
        
        // ãƒ‡ãƒã‚¤ã‚¹ãƒªã‚¹ãƒˆå–å¾—
        const devices = await navigator.mediaDevices.enumerateDevices();
        
        // ã‚¹ãƒˆãƒªãƒ¼ãƒ åœæ­¢
        if (stream) {
            stream.getTracks().forEach(track => track.stop());
        }
        
        // setSinkIdå¯¾å¿œãƒã‚§ãƒƒã‚¯
        const canSetSink = 'setSinkId' in HTMLAudioElement.prototype;
        
        // ãƒªã‚¹ãƒˆåˆæœŸåŒ–
        micSelect.innerHTML = '<option value="">ãƒ‡ãƒã‚¤ã‚¹ã‚’é¸æŠ...</option>';
        spkSelect.innerHTML = '<option value="">(æ—¢å®šã®å‡ºåŠ›)</option>';
        
        let micCount = 0, spkCount = 0;
        
        devices.forEach(device => {
            const option = document.createElement('option');
            option.value = device.deviceId;
            option.textContent = device.label || `${device.kind === 'audioinput' ? 'ãƒã‚¤ã‚¯' : 'ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼'} (${device.deviceId.substr(0, 8)}...)`;
            
            if (device.kind === 'audioinput') {
                micSelect.appendChild(option);
                micCount++;
            } else if (device.kind === 'audiooutput') {
                if (!canSetSink) {
                    option.disabled = true;
                    option.textContent += ' (éå¯¾å¿œ)';
                }
                spkSelect.appendChild(option);
                spkCount++;
            }
        });
        
        // çµæœè¡¨ç¤º
        if (micCount > 0) {
            let message = `âœ… ãƒ‡ãƒã‚¤ã‚¹æ¤œå‡ºå®Œäº†: ãƒã‚¤ã‚¯ ${micCount}å°ã€ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼ ${spkCount}å°`;
            if (!canSetSink) {
                message += '\nâš ï¸ ã“ã®ãƒ–ãƒ©ã‚¦ã‚¶ã¯ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼é¸æŠã«éå¯¾å¿œã§ã™ã€‚ã‚·ã‚¹ãƒ†ãƒ è¨­å®šã®æ—¢å®šãƒ‡ãƒã‚¤ã‚¹ãŒä½¿ç”¨ã•ã‚Œã¾ã™ã€‚';
            }
            statusEl.textContent = message;
            statusEl.className = 'status-msg ready';
            
            // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆé¸æŠ
            if (micSelect.options.length > 1) micSelect.selectedIndex = 1;
            if (spkSelect.options.length > 1 && canSetSink) spkSelect.selectedIndex = 1;
        } else {
            statusEl.textContent = 'âš ï¸ ãƒã‚¤ã‚¯ãƒ‡ãƒã‚¤ã‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚ãƒã‚¤ã‚¯ãŒæ¥ç¶šã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèªã—ã¦ãã ã•ã„ã€‚';
            statusEl.className = 'status-msg error';
        }
        
    } catch (error) {
        statusEl.textContent = 'âŒ ' + (error.message || 'ãƒ‡ãƒã‚¤ã‚¹ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ');
        statusEl.className = 'status-msg error';
        micSelect.innerHTML = '<option value="">ãƒ‡ãƒã‚¤ã‚¹ã‚’é¸æŠ...</option>';
        spkSelect.innerHTML = '<option value="">ãƒ‡ãƒã‚¤ã‚¹ã‚’é¸æŠ...</option>';
    }
}

function onCategoryChange(index) {
    selectedSpecs[index] = {};
    document.getElementById(`trigger_${index}`).textContent = 'è£½å“ã‚¹ãƒšãƒƒã‚¯ã‚’é¸æŠ...';
    document.getElementById(`panel_${index}`).classList.remove('active');
    document.getElementById(`unitArea_${index}`).textContent = '-';
    document.getElementById(`totalArea_${index}`).textContent = '-';
    renderPanel(index);
    calculate();
}

function togglePanel(index) {
    const panel = document.getElementById(`panel_${index}`);
    const isActive = panel.classList.contains('active');
    document.querySelectorAll('.sub-panel').forEach(p => p.classList.remove('active'));
    if (!isActive) { panel.classList.add('active'); renderPanel(index); }
}

function renderPanel(index) {
    const categoryKey = document.getElementById(`cat_${index}`).value;
    if (!categoryKey) {
        document.getElementById(`col_model_${index}`).innerHTML = '<div class="col-title">MODEL</div>';
        document.getElementById(`col_thick_${index}`).innerHTML = '<div class="col-title">THICKNESS</div>';
        document.getElementById(`col_size_${index}`).innerHTML = '<div class="col-title">SIZE</div>';
        return;
    }
    const category = SOUNDBOX_DB.products[categoryKey];
    const spec = selectedSpecs[index];
    const modelCol = document.getElementById(`col_model_${index}`);
    modelCol.innerHTML = '<div class="col-title">MODEL</div>';
    for (let modelKey in category.models) {
        const modelDiv = document.createElement('div');
        modelDiv.className = 'col-item' + (spec.model === modelKey ? ' selected' : '');
        modelDiv.textContent = category.models[modelKey].n;
        modelDiv.onclick = () => selectModel(index, categoryKey, modelKey);
        modelCol.appendChild(modelDiv);
    }
    const thickCol = document.getElementById(`col_thick_${index}`);
    thickCol.innerHTML = '<div class="col-title">THICKNESS</div>';
    if (spec.model) {
        const model = category.models[spec.model];
        for (let thickKey in model.d) {
            const thickDiv = document.createElement('div');
            thickDiv.className = 'col-item' + (spec.thick === thickKey ? ' selected' : '');
            thickDiv.textContent = thickKey + 'mm';
            thickDiv.onclick = () => selectThickness(index, categoryKey, spec.model, thickKey);
            thickCol.appendChild(thickDiv);
        }
    }
    const sizeCol = document.getElementById(`col_size_${index}`);
    sizeCol.innerHTML = '<div class="col-title">SIZE</div>';
    if (spec.model && spec.thick) {
        const model = category.models[spec.model];
        for (let sizeKey in model.s) {
            const sizeDiv = document.createElement('div');
            sizeDiv.className = 'col-item' + (spec.size === sizeKey ? ' selected' : '');
            sizeDiv.textContent = sizeKey;
            sizeDiv.onclick = () => selectSize(index, categoryKey, spec.model, spec.thick, sizeKey);
            sizeCol.appendChild(sizeDiv);
        }
    }
}

function selectModel(index, categoryKey, modelKey) { selectedSpecs[index] = { category: categoryKey, model: modelKey }; renderPanel(index); }
function selectThickness(index, categoryKey, modelKey, thickKey) { selectedSpecs[index].thick = thickKey; renderPanel(index); }
function selectSize(index, categoryKey, modelKey, thickKey, sizeKey) {
    selectedSpecs[index].size = sizeKey;
    const model = SOUNDBOX_DB.products[categoryKey].models[modelKey];
    document.getElementById(`trigger_${index}`).textContent = `${model.n} / ${thickKey}mm / ${sizeKey}`;
    document.getElementById(`unitArea_${index}`).textContent = model.s[sizeKey].toFixed(2) + 'ã¡';
    document.getElementById(`panel_${index}`).classList.remove('active');
    calculate();
}

function prepareForPrint() { window.print(); }

function calculate() {
    const w = parseFloat(document.getElementById('w').value) || 0.1;
    const d = parseFloat(document.getElementById('d').value) || 0.1;
    const h = parseFloat(document.getElementById('h').value) || 0.1;
    const V = w * d * h;
    const S_total = 2 * (w * d + d * h + h * w);
    const S_wall = 2 * (d * h + h * w);
    const S_ceiling = w * d;
    const S_floor = w * d;
    if (V <= 0 || S_total <= 0) return;
    const L_mean = (4 * V) / S_total;
    const diffusionIndicator = (L_mean * 0.12).toFixed(2);
    const appIndex = parseInt(document.getElementById('appTarget').value) || 0;
    const targetObj = SOUNDBOX_DB.apps[appIndex];
    const targetRT = targetObj.t;
    const wallMat = SOUNDBOX_DB.materials[document.getElementById('baseWall').value];
    const ceilingMat = SOUNDBOX_DB.materials[document.getElementById('baseCeiling').value];
    const floorMat = SOUNDBOX_DB.materials[document.getElementById('baseFloor').value];
    let exArea = 0, exMat = null;
    if (document.getElementById('showSpecial').checked) {
        exArea = parseFloat(document.getElementById('exArea').value) || 0;
        exMat = SOUNDBOX_DB.materials[document.getElementById('exMat').value];
    }
    const actualWallArea = Math.max(0, S_wall - exArea);
    const rt_before = [], rt_after = [];
    const m_coeffs = [0, 0, 0, 0, 0.002, 0.007];
    
    for (let i = 0; i < 6; i++) {
        let A_base = actualWallArea * wallMat.data[i] + S_ceiling * ceilingMat.data[i] + S_floor * floorMat.data[i];
        if (exArea > 0 && exMat) A_base += exArea * exMat.data[i];
        const airAbsorption = 4 * m_coeffs[i] * V;
        
        // Beforeå€¤ã®æ±ºå®š
        let rt_b;
        if (currentMode === 'measure' && measurementData) {
            if (measurementData[i] !== null && measurementData[i] !== undefined) {
                // æ¸¬å®šãƒ¢ãƒ¼ãƒ‰ï¼šæ¸¬å®šå€¤ã‚’ä½¿ç”¨
                rt_b = measurementData[i];
            } else {
                // æ¸¬å®šãƒ¢ãƒ¼ãƒ‰ï¼šã“ã®ãƒãƒ³ãƒ‰ã¯æ¬ æ â†’ nullã®ã¾ã¾ï¼ˆSabineè£œå®Œã—ãªã„ï¼‰
                rt_before.push(null);
                rt_after.push(null);
                continue;
            }
        } else {
            // ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒ¢ãƒ¼ãƒ‰ï¼šéƒ¨å±‹ã‚µã‚¤ã‚ºã‹ã‚‰è¨ˆç®—
            rt_b = (0.161 * V) / (A_base + airAbsorption);
        }
        rt_before.push(rt_b);
        
        // ãƒ‘ãƒãƒ«å¸éŸ³åŠ›ã®è¨ˆç®—
        let A_panels = 0;
        for (let panelIdx = 0; panelIdx < 3; panelIdx++) {
            const spec = selectedSpecs[panelIdx];
            const qty = parseInt(document.getElementById(`qty_${panelIdx}`).value) || 0;
            if (spec.category && spec.model && spec.thick && spec.size && qty > 0) {
                const product = SOUNDBOX_DB.products[spec.category].models[spec.model];
                A_panels += product.s[spec.size] * qty * (product.d[spec.thick][i] - wallMat.data[i]);
            }
        }
        
        // Afterå€¤ã®è¨ˆç®—
        let rt_a;
        if (currentMode === 'measure' && measurementData && measurementData[i] !== null && measurementData[i] !== undefined) {
            // æ¸¬å®šãƒ¢ãƒ¼ãƒ‰ï¼šæ¸¬å®šå€¤ã‹ã‚‰ãƒ‘ãƒãƒ«åŠ¹æœã‚’æ¸›ç®—
            // ãƒ‘ãƒãƒ«ãªã—çŠ¶æ…‹ã®RT â†’ ãƒ‘ãƒãƒ«ã‚ã‚ŠçŠ¶æ…‹ã®RTã¸ã®å¤‰åŒ–é‡ã‚’è¨ˆç®—
            const A_total = A_base + A_panels + airAbsorption;
            const avgAlpha = Math.min(A_total / S_total, 0.999);
            const rt_with_panels = (0.161 * V) / (-S_total * Math.log(1 - avgAlpha) + airAbsorption);
            
            // ç¾çŠ¶ã®å¸éŸ³åŠ›ã‚’é€†ç®—
            const A_current = (0.161 * V) / rt_b - airAbsorption;
            // ãƒ‘ãƒãƒ«è¿½åŠ å¾Œã®å¸éŸ³åŠ›
            const A_after = A_current + A_panels;
            const avgAlpha_after = Math.min((A_after + airAbsorption) / S_total, 0.999);
            rt_a = (0.161 * V) / (-S_total * Math.log(1 - avgAlpha_after) + airAbsorption);
            rt_a = Math.max(0.1, rt_a); // æœ€å°0.1ç§’
        } else {
            // ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒ¢ãƒ¼ãƒ‰ï¼šSabineå¼
            const A_total = A_base + A_panels + airAbsorption;
            rt_a = (0.161 * V) / A_total;
        }
        rt_after.push(rt_a);
    }
    // å®Ÿæ¸¬å€¤ã®ã¿ã§å¹³å‡è¨ˆç®—ï¼ˆnull=æœªæ¸¬å®šãƒãƒ³ãƒ‰ã¯é™¤å¤–ãƒ»Sabineè£œå®Œã—ãªã„ï¼‰
    const validAfterVals  = rt_after.filter(v => v !== null);
    const validBeforeVals = rt_before.filter(v => v !== null);
    const avgRT_after  = validAfterVals.length  > 0 ? validAfterVals.reduce((s,v)=>s+v,0)  / validAfterVals.length  : 0;
    const avgRT_before = validBeforeVals.length > 0 ? validBeforeVals.reduce((s,v)=>s+v,0) / validBeforeVals.length : 0;
    // æ¸¬å®šãƒ¢ãƒ¼ãƒ‰æ™‚ã¯æœ‰åŠ¹ãƒãƒ³ãƒ‰æ•°ã‚’è¡¨ç¤ºã«ä½¿ã†
    const measuredBandCount = (currentMode === 'measure' && measurementData)
        ? measurementData.filter(v => v !== null).length : null;
    let totalPanelM2 = 0;
    for (let panelIdx = 0; panelIdx < 3; panelIdx++) {
        const spec = selectedSpecs[panelIdx];
        const qty = parseInt(document.getElementById(`qty_${panelIdx}`).value) || 0;
        if (spec.category && spec.model && spec.size && qty > 0) {
            const unitArea = SOUNDBOX_DB.products[spec.category].models[spec.model].s[spec.size];
            totalPanelM2 += unitArea * qty;
            document.getElementById(`totalArea_${panelIdx}`).textContent = (unitArea * qty).toFixed(2) + 'ã¡';
        } else {
            document.getElementById(`totalArea_${panelIdx}`).textContent = '-';
        }
    }
    const usableSurface = S_wall * 0.8;
    const achievementRate = (targetRT / avgRT_after) * 100;
    updateUI(rt_before, rt_after, avgRT_before, avgRT_after, targetRT, targetObj, achievementRate, totalPanelM2, usableSurface, V, diffusionIndicator, measuredBandCount);
}

function updateUI(rt_before, rt_after, avgBefore, avgAfter, targetRT, targetObj, achievementRate, totalPanelM2, usableSurface, V, diffusionIndicator, measuredBandCount) {
    // æ¸¬å®šãƒ¢ãƒ¼ãƒ‰: 500Hzãƒ»1kHzä¸¡æ–¹æœ‰åŠ¹ãªå ´åˆã®ã¿å¹³å‡å€¤ã‚’è¡¨ç¤º
    // ç‰‡æ–¹ã§ã‚‚æœ‰åŠ¹ã§ã‚ã‚Œã°è¨ˆç®—ã§ãã‚‹ãŒã€ãƒ©ãƒ™ãƒ«ã‚’æ˜ç¤ºã™ã‚‹
    const has500 = measurementData && measurementData[2] !== null;
    const has1k  = measurementData && measurementData[3] !== null;
    const coreAvailable = currentMode !== 'measure' || (has500 || has1k);
    let avgLabel;
    let bandInfoLabel = '';
    if (!coreAvailable) {
        avgLabel = 'N/A';
        bandInfoLabel = '';
    } else if (measuredBandCount !== null) {
        avgLabel = avgAfter.toFixed(2) + 's';
        bandInfoLabel = 'Measured: ' + measuredBandCount + ' / 6';
    } else {
        avgLabel = avgAfter.toFixed(2) + 's';
        bandInfoLabel = '';
    }
    document.getElementById('postRT_Avg').textContent = avgLabel;
    const _bandInfoEl = document.getElementById('measuredBandInfo');
    if (_bandInfoEl) _bandInfoEl.textContent = bandInfoLabel;
    document.getElementById('targetLabel').textContent = `ç›®æ¨™: ${targetRT}s`;
    document.getElementById('achievementRate').textContent = achievementRate.toFixed(0) + '%';
    document.getElementById('totalPanelArea').textContent = `${totalPanelM2.toFixed(1)} / ${usableSurface.toFixed(1)}ã¡`;
    document.getElementById('diffusionBalance').style.display = 'none'; // æ‹¡æ•£å¯„ä¸åº¦ã¯æœªå®Ÿè£…ã®ãŸã‚éè¡¨ç¤º
    const cardHealth = document.getElementById('cardHealth');
    const healthStatus = document.getElementById('healthStatus');
    const adviceHeader = document.getElementById('adviceHeader');
    const detailedNote = document.getElementById('detailedNote');
    let status, statusColor, adviceTagColor, adviceText;
    if (totalPanelM2 > usableSurface) {
        status = 'è¨­ç½®é™ç•Œè¶…é'; statusColor = 'var(--danger)'; adviceTagColor = '#ff7b72';
        adviceHeader.textContent = 'FAIL'; adviceHeader.style.background = adviceTagColor;
        adviceText = 'å£é¢ã®æœ‰åŠ¹é¢ç©ï¼ˆ80%ï¼‰ã‚’è¶…ãˆã‚‹ãƒ‘ãƒãƒ«ãŒé…ç½®ã•ã‚Œã¦ã„ã¾ã™ã€‚ãƒ‘ãƒãƒ«æšæ•°ã‚’æ¸›ã‚‰ã™ã‹ã€ã‚ˆã‚Šåšå‹ã®ãƒ‘ãƒãƒ«ã¸ã®å¤‰æ›´ã‚’æ¤œè¨ã—ã¦ãã ã•ã„ã€‚';
    } else if (achievementRate >= 120) {
        status = 'éŸ¿ããŒå°‘ãªã„'; statusColor = 'var(--caution)'; adviceTagColor = '#f0883e';
        adviceHeader.textContent = 'OVER'; adviceHeader.style.background = adviceTagColor;
        adviceText = 'ç©ºé–“ãŒãƒ‡ãƒƒãƒ‰éãã‚‹å‚¾å‘ã«ã‚ã‚Šã¾ã™ã€‚æ‹¡æ•£ãƒ‘ãƒãƒ«ã‚’æ´»ç”¨ã—ã¦ãã ã•ã„ã€‚';
    } else if (achievementRate >= 100) {
        status = 'ç†æƒ³çš„'; statusColor = 'var(--success)'; adviceTagColor = '#39d353';
        adviceHeader.textContent = 'IDEAL'; adviceHeader.style.background = adviceTagColor;
        adviceText = 'ç†æƒ³çš„ãªæ•°å€¤ã§ã™ã€‚ç›®æ¨™ã®æ®‹éŸ¿æ™‚é–“ã‚’é”æˆã—ã¦ã„ã¾ã™ã€‚';
    } else if (achievementRate >= 80) {
        status = 'å®Ÿç”¨ãƒ¬ãƒ™ãƒ«'; statusColor = 'var(--accent)'; adviceTagColor = '#388bfd';
        adviceHeader.textContent = 'GOOD'; adviceHeader.style.background = adviceTagColor;
        adviceText = 'å®Ÿç”¨ä¸Šååˆ†ãªå°å…¥åŠ¹æœã§ã™ã€‚ä½åŸŸã®åˆ¶å¾¡ã«ã¯åšå‹ã‚’æ¤œè¨ã—ã¦ãã ã•ã„ã€‚';
    } else {
        status = 'å¸éŸ³ä¸è¶³'; statusColor = 'var(--danger)'; adviceTagColor = '#ff7b72';
        adviceHeader.textContent = 'UNDER'; adviceHeader.style.background = adviceTagColor;
        adviceText = 'ç›®æ¨™æ®‹éŸ¿æ™‚é–“ã«é”ã—ã¦ã„ã¾ã›ã‚“ã€‚ãƒ‘ãƒãƒ«å¢—è¨­ã‚’æ¨å¥¨ã—ã¾ã™ã€‚';
    }
    healthStatus.textContent = status;
    healthStatus.style.color = statusColor;
    cardHealth.style.borderColor = statusColor;
    if (V < 30) {
        adviceText += '<br><br><strong style="color:#ffb86c;">âš ï¸ Small Room Analysis</strong><br>æœ¬ç©ºé–“ã¯å®¹ç©ãŒå°ã•ã„ãŸã‚ã€è¨ˆç®—ä¸Šã®æ•°å€¤ã‚ˆã‚Šã‚‚ã€å¹³è¡Œé¢ã§ç™ºç”Ÿã™ã‚‹å®šåœ¨æ³¢ï¼ˆãƒ–ãƒ¼ãƒŸãƒ³ã‚°ï¼‰ã®æŠ‘åˆ¶ãŒé‡è¦ã§ã™ã€‚å£é¢ã®ä¸­å¤®ã ã‘ã§ãªãã€å…¥éš…ï¼ˆã‚³ãƒ¼ãƒŠãƒ¼ï¼‰ã¸ã®å¸éŸ³æé…ç½®ã‚’å„ªå…ˆã™ã‚‹ã“ã¨ã§ã€ä½åŸŸã®ã‚¨ãƒãƒ«ã‚®ãƒ¼ã‚’åŠ¹ç‡çš„ã«å‡¦ç†ã§ãã¾ã™ã€‚';
    }
    if (rt_after[0] > avgAfter * 1.5) {
        adviceText += '<br><br><strong style="color:#ffb86c;">âš ï¸ 125Hz ä½åŸŸæ®‹éŸ¿è­¦å‘Š</strong><br>125Hzã®æ®‹éŸ¿æ™‚é–“ãŒçªå‡ºã—ã¦ã„ã¾ã™ã€‚ä½åŸŸã®åˆ¶å¾¡ã«ã¯120mmåšã®ãƒ‘ãƒãƒ«ã€ã¾ãŸã¯ã‚³ãƒ¼ãƒŠãƒ¼é…ç½®ã®ãƒ™ãƒ¼ã‚¹ãƒˆãƒ©ãƒƒãƒ—ã‚’æ¨å¥¨ã—ã¾ã™ã€‚';
    }
    detailedNote.innerHTML = adviceText;
    updateChart(rt_before, rt_after, targetRT);
    lastData = { rt_after: avgAfter, rt_before: avgBefore, targetRT, achievementRate, totalPanelM2, V, status };
}

window.addEventListener('DOMContentLoaded', init);
</script>

<script>
// ========================================
// Web Worker: ãƒ–ãƒ­ãƒ¼ãƒ‰ãƒãƒ³ãƒ‰è§£æã‚¨ãƒ³ã‚¸ãƒ³ï¼ˆRev 18.25ï¼‰
// å‡¦ç†ãƒ•ãƒ­ãƒ¼: Farina deconv â†’ BPFÃ—18 â†’ SNR â†’ Schroeder â†’ RTè¨ˆç®—
// ========================================
const workerCode = `
'use strict';

// INITå—ä¿¡ã§è¨­å®šã‚’ä¿æŒ
let _fs  = 48000;
let _cfg = null;
let _noiseFloor = null; // ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³çµæœï¼ˆ18ãƒãƒ³ãƒ‰ï¼‰
let _latencyOffset = null; // ãƒ¬ã‚¤ãƒ†ãƒ³ã‚·ãƒ¼ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³çµæœï¼ˆã‚µãƒ³ãƒ—ãƒ«æ•°ï¼‰

self.onmessage = function(e) {
    const msg = e.data;
    if (msg.type === 'INIT') {
        _fs  = msg.sampleRate;
        _cfg = msg.config;
        return;
    }
    if (msg.type === 'SET_LATENCY') {
        _latencyOffset = msg.latencyOffset;
        console.log('### Worker: ãƒ¬ã‚¤ãƒ†ãƒ³ã‚·ãƒ¼ã‚ªãƒ•ã‚»ãƒƒãƒˆå—ä¿¡: ' + _latencyOffset + 'ã‚µãƒ³ãƒ—ãƒ« (' + (_latencyOffset/_fs).toFixed(3) + 's)');
        return;
    }
    if (msg.type === 'CALIBRATION') {
        // éŒ²éŸ³ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰ãƒãƒ³ãƒ‰åˆ¥ãƒã‚¤ã‚ºãƒ•ãƒ­ã‚¢ã‚’è¨ˆç®—
        const noiseRec = new Float32Array(msg.noiseRecording);
        _noiseFloor = calculateNoiseFloorFromRecording(noiseRec);
        self.postMessage({ type: 'calibrationDone' }); // å®Œäº†é€šçŸ¥
        return;
    }
    if (msg.type === 'ANALYZE_ALL') {
        analyzeAll(msg);
    }
};

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   ãƒã‚¤ã‚ºéŒ²éŸ³ã‹ã‚‰18ãƒãƒ³ãƒ‰åˆ¥ãƒã‚¤ã‚ºãƒ•ãƒ­ã‚¢ã‚’è¨ˆç®—
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function calculateNoiseFloorFromRecording(signal) {
    const bands = _cfg.bands;
    const fs    = _fs;
    const noiseFloor = new Array(bands.length);

    for (let bi = 0; bi < bands.length; bi++) {
        const fc = bands[bi];
        
        // å„ãƒãƒ³ãƒ‰ã§BPFé©ç”¨
        const sections = designButterworthBPF(fc, fs, 6, 0.05);
        const filtered = applyBiquadCascade(signal, sections);
        
        // RMSè¨ˆç®—
        let sumSq = 0;
        for (let i = 0; i < filtered.length; i++) {
            sumSq += filtered[i] * filtered[i];
        }
        noiseFloor[bi] = Math.sqrt(sumSq / filtered.length);
    }
    
    return noiseFloor;
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   Cooley-Tukey FFTï¼ˆåŸºæ•°2ãƒ»ã‚¤ãƒ³ãƒ—ãƒ¬ãƒ¼ã‚¹ï¼‰
   å‚è€ƒ: J.W.Cooley & J.W.Tukey (1965)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function nextPow2(n) {
    let p = 1;
    while (p < n) p <<= 1;
    return p;
}

function fft(re, im) {
    const N = re.length;
    // ãƒ“ãƒƒãƒˆé€†é †ä¸¦ã¹æ›¿ãˆ
    for (let i = 1, j = 0; i < N; i++) {
        let bit = N >> 1;
        for (; j & bit; bit >>= 1) j ^= bit;
        j ^= bit;
        if (i < j) {
            let t;
            t = re[i]; re[i] = re[j]; re[j] = t;
            t = im[i]; im[i] = im[j]; im[j] = t;
        }
    }
    // ãƒã‚¿ãƒ•ãƒ©ã‚¤æ¼”ç®—
    for (let len = 2; len <= N; len <<= 1) {
        const ang = -2.0 * Math.PI / len;
        const wRe = Math.cos(ang);
        const wIm = Math.sin(ang);
        for (let i = 0; i < N; i += len) {
            let uRe = 1.0, uIm = 0.0;
            const half = len >> 1;
            for (let k = 0; k < half; k++) {
                const m   = i + k + half;
                const vRe = re[m] * uRe - im[m] * uIm;
                const vIm = re[m] * uIm + im[m] * uRe;
                re[m]   = re[i + k] - vRe;
                im[m]   = im[i + k] - vIm;
                re[i+k] += vRe;
                im[i+k] += vIm;
                const nRe = uRe * wRe - uIm * wIm;
                uIm = uRe * wIm + uIm * wRe;
                uRe = nRe;
            }
        }
    }
}

function ifft(re, im) {
    const N = re.length;
    for (let i = 0; i < N; i++) im[i] = -im[i];
    fft(re, im);
    for (let i = 0; i < N; i++) {
        re[i] /=  N;
        im[i]  = -im[i] / N;
    }
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   ç›¸äº’ç›¸é–¢ã«ã‚ˆã‚‹Sweepé–‹å§‹ä½ç½®æ¤œå‡º
   Bluetoothé…å»¶ãƒ»ã‚¸ãƒƒã‚¿ãƒ¼ã«å¯¾å¿œ
   2æ®µéšã‚¹ã‚­ãƒ£ãƒ³: ç²—ã„ã‚¹ã‚­ãƒ£ãƒ³ â†’ ç´°ã‹ã„èª¿æ•´
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function findSweepStart(recorded, sweep) {
    const fs = _fs;
    
    // ãƒ¬ã‚¤ãƒ†ãƒ³ã‚·ãƒ¼ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³çµæœã‚’ä½¿ç”¨ã—ã¦æ¤œç´¢ç¯„å›²ã‚’çµã‚‹
    let searchStart, searchEnd;
    
    if (_latencyOffset !== null) {
        // ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³æ¸ˆã¿ï¼šÂ±1.0ç§’æ¤œç´¢ï¼ˆ0.5ç§’ã‹ã‚‰æ‹¡å¤§ï¼‰
        const searchMargin = Math.floor(1.0 * fs);
        searchStart = Math.max(0, _latencyOffset - searchMargin);
        searchEnd = Math.min(recorded.length - sweep.length, _latencyOffset + searchMargin);
        
        self.postMessage({ 
            type: 'debug', 
            message: 'Search range (calibrated): ' + (searchStart/fs).toFixed(3) + 's - ' + (searchEnd/fs).toFixed(3) + 's (Â±1.0s around ' + (_latencyOffset/fs).toFixed(3) + 's)'
        });
    } else {
        // ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãªã—ï¼šå¾“æ¥ã®åºƒç¯„å›²æ¤œç´¢
        searchStart = Math.floor(0.2 * fs); // 200msã‚¹ã‚­ãƒƒãƒ—
        searchEnd = Math.min(Math.floor(2.5 * fs), recorded.length - sweep.length);
        
        self.postMessage({ 
            type: 'debug', 
            message: 'Search range (uncalibrated): ' + (searchStart/fs).toFixed(3) + 's - ' + (searchEnd/fs).toFixed(3) + 's'
        });
    }
    
    if (searchEnd <= searchStart) {
        self.postMessage({ 
            type: 'debug', 
            message: 'Warning: Invalid search range, using fallback'
        });
        return Math.floor(0.5 * fs);
    }
    
    // ãƒ–ãƒ­ãƒ¼ãƒ‰ãƒãƒ³ãƒ‰ã‚¹ã‚¤ãƒ¼ãƒ—ï¼ˆduration > 2sï¼‰: 2.5såœ°ç‚¹ï¼ˆç´„630Hzï¼‰ã‹ã‚‰0.3sçª“ã§ç›¸é–¢
    // ç†ç”±: å…ˆé ­20Hzã¯éŒ²éŸ³å´ã®ä½åŸŸãƒ­ãƒ¼ãƒ«ã‚ªãƒ•ã§ã‚¨ãƒãƒ«ã‚®ãƒ¼ãŒä½ãã€ç›¸é–¢ãŒå–ã‚Œãªã„
    // ãƒãƒ³ãƒ‰é™å®šã‚¹ã‚¤ãƒ¼ãƒ—ï¼ˆduration <= 2sï¼‰: å¾“æ¥é€šã‚Šå…ˆé ­0.2s
    const sweepDuration = sweep.length / fs;
    let checkStart, checkLength;
    if (sweepDuration > 2.0) {
        checkStart  = Math.round(0.15 * fs) + Math.round(2.5 * fs); // guardPre + 2.5s
        checkLength = Math.min(Math.round(0.3 * fs), sweep.length - checkStart);
    } else {
        checkStart  = 0;
        checkLength = Math.min(Math.floor(0.2 * fs), sweep.length);
    }

    // Step 1: Coarse scan (100-sample steps)
    let maxCorr = -Infinity;
    let bestOffset = searchStart;
    const searchEndAdj = Math.min(searchEnd, recorded.length - checkStart - checkLength);

    for (let offset = searchStart; offset < searchEndAdj; offset += 100) {
        let corr = 0;
        for (let i = 0; i < checkLength; i++) {
            corr += recorded[offset + checkStart + i] * sweep[checkStart + i];
        }
        if (corr > maxCorr) {
            maxCorr = corr;
            bestOffset = offset;
        }
    }

    // Step 2: Fine adjustment (1-sample steps within Â±100 range)
    const fineStart = Math.max(searchStart, bestOffset - 100);
    const fineEnd   = Math.min(searchEndAdj, bestOffset + 100);
    maxCorr = -Infinity;

    for (let offset = fineStart; offset < fineEnd; offset++) {
        let corr = 0;
        for (let i = 0; i < checkLength; i++) {
            corr += recorded[offset + checkStart + i] * sweep[checkStart + i];
        }
        if (corr > maxCorr) {
            maxCorr = corr;
            bestOffset = offset;
        }
    }

    // Step 3: Calculate correlation confidence (normalized)
    let recEnergy = 0;
    let swpEnergy = 0;
    for (let i = 0; i < checkLength; i++) {
        recEnergy += recorded[bestOffset + checkStart + i] * recorded[bestOffset + checkStart + i];
        swpEnergy += sweep[checkStart + i] * sweep[checkStart + i];
    }

    const normalizedCorr = maxCorr / (Math.sqrt(recEnergy * swpEnergy) + 1e-10);
    
    // Debug log
    self.postMessage({ 
        type: 'debug', 
        message: 'Correlation: offset=' + bestOffset + ' samples (' + (bestOffset/fs).toFixed(3) + 's), confidence=' + normalizedCorr.toFixed(3)
    });
    
    if (normalizedCorr < 0.3) {
        self.postMessage({ 
            type: 'debug', 
            message: 'Warning: Low correlation confidence (' + normalizedCorr.toFixed(3) + ' < 0.3)' 
        });
    }
    
    return bestOffset;
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   é€†ç•³ã¿è¾¼ã¿ã«ã‚ˆã‚‹ã‚¤ãƒ³ãƒ‘ãƒ«ã‚¹å¿œç­”(IR)æŠ½å‡º
   H(f) = Y(f) Â· X*(f) / (|X(f)|Â² + Îµ)
   æ­£è¦åŒ–é€†ãƒ•ã‚£ãƒ«ã‚¿ï¼ˆWienerãƒ•ã‚£ãƒ«ã‚¿å½¢å¼ï¼‰
   ISO 3382-1:2009 Annex Aæº–æ‹ 
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function extractIR(recorded, sweep) {
    const N = nextPow2((recorded.length + sweep.length - 1) * 2);
    const yRe = new Float64Array(N);
    const yIm = new Float64Array(N);
    const xRe = new Float64Array(N);
    const xIm = new Float64Array(N);

    for (let i = 0; i < recorded.length; i++) yRe[i] = recorded[i];
    for (let i = 0; i < sweep.length;    i++) xRe[i] = sweep[i];

    fft(yRe, yIm);
    fft(xRe, xIm);

    // æ­£è¦åŒ–: ã‚¼ãƒ­é™¤ç®—ãƒ»ä½ã‚¨ãƒãƒ«ã‚®ãƒ¼å¸¯åŸŸã®ç™ºæ•£ã‚’é˜²æ­¢
    const eps = 1e-9;
    const hRe = new Float64Array(N);
    const hIm = new Float64Array(N);
    for (let i = 0; i < N; i++) {
        const denom = xRe[i]*xRe[i] + xIm[i]*xIm[i] + eps;
        hRe[i] = (yRe[i]*xRe[i] + yIm[i]*xIm[i]) / denom;
        hIm[i] = (yIm[i]*xRe[i] - yRe[i]*xIm[i]) / denom;
    }

    ifft(hRe, hIm);

    // å®Ÿéƒ¨ã®ã¿ï¼ˆã‚¤ãƒ³ãƒ‘ãƒ«ã‚¹å¿œç­”ï¼‰ã‚’éŒ²éŸ³é•·ã§åˆ‡ã‚Šå–ã£ã¦è¿”å´
    return new Float64Array(hRe.buffer, 0, recorded.length);
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   Farinaæ³• ã‚¤ãƒ³ãƒ‘ãƒ«ã‚¹å¿œç­”æŠ½å‡º
   å‚è€ƒ: Farina (2000) "Simultaneous measurement of impulse response
         and distortion with a swept-sine technique"
   é€†ãƒ•ã‚£ãƒ«ã‚¿ = æ™‚é–“åè»¢ã‚¹ã‚¤ãƒ¼ãƒ— Ã— exp(-nÂ·ln(f2/f1)/N)
   FFTä¹—ç®—ï¼ˆé™¤ç®—ã§ã¯ãªã„ï¼‰ã«ã‚ˆã‚Šå¹³å¦ã‚¹ãƒšã‚¯ãƒˆãƒ«IRã‚’å¾—ã‚‹
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function extractIRFarina(recorded, sweep, fLow, fHigh, durationSec) {
    const fs       = _fs;
    const guardPre = Math.round(0.15 * fs);
    const N_sweep  = Math.round(durationSec * fs);
    const k        = Math.log(fHigh / fLow); // ln(f2/f1)

    // â”€â”€ Farinaé€†ãƒ•ã‚£ãƒ«ã‚¿ç”Ÿæˆ â”€â”€
    // inv[n] = sweep[guardPre + N_sweep - 1 - n] Ã— exp(-nÂ·k/N_sweep)
    // é•·ã•: N_sweepï¼ˆã‚¬ãƒ¼ãƒ‰ãƒãƒ³ãƒ‰ã‚’å«ã¾ãªã„ï¼‰
    const inv = new Float64Array(N_sweep);
    for (let n = 0; n < N_sweep; n++) {
        const srcIdx = guardPre + (N_sweep - 1 - n);
        const val    = srcIdx < sweep.length ? sweep[srcIdx] : 0;
        inv[n]       = val * Math.exp(-n * k / N_sweep);
    }

    // â”€â”€ FFTä¹—ç®—ï¼ˆæ™‚é–“é ˜åŸŸãŸãŸã¿è¾¼ã¿ï¼‰â”€â”€
    // H(Ï‰) = Y(Ï‰) Ã— INV(Ï‰)  â† é™¤ç®—ã§ã¯ãªãä¹—ç®—
    const N = nextPow2(recorded.length + N_sweep);
    const yRe = new Float64Array(N);
    const xRe = new Float64Array(N);
    const yIm = new Float64Array(N);
    const xIm = new Float64Array(N);

    for (let i = 0; i < recorded.length; i++) yRe[i] = recorded[i];
    for (let i = 0; i < N_sweep; i++)         xRe[i] = inv[i];

    fft(yRe, yIm);
    fft(xRe, xIm);

    const hRe = new Float64Array(N);
    const hIm = new Float64Array(N);
    for (let i = 0; i < N; i++) {
        hRe[i] = yRe[i]*xRe[i] - yIm[i]*xIm[i]; // è¤‡ç´ ä¹—ç®—
        hIm[i] = yRe[i]*xIm[i] + yIm[i]*xRe[i];
    }

    ifft(hRe, hIm);

    // â”€â”€ IRåˆ‡ã‚Šå‡ºã— â”€â”€
    // ç›´é”éŸ³ãƒ”ãƒ¼ã‚¯ä½ç½®: guardPre + N_sweep - 1
    // 50mså‰ãƒãƒƒãƒ•ã‚¡ã‚’è¨­ã‘ã¦calcSNRã®ãƒ”ãƒ¼ã‚¯æ¢ç´¢ç¯„å›²ï¼ˆå…ˆé ­0.1sï¼‰å†…ã«åã‚ã‚‹
    const preBuf    = Math.round(0.05 * fs);
    const peakOff   = guardPre + N_sweep - 1;
    const startIdx  = Math.max(0, peakOff - preBuf);
    const irLength  = Math.min(N - startIdx, recorded.length);

    const ir = new Float64Array(irLength);
    for (let i = 0; i < irLength; i++) ir[i] = hRe[startIdx + i];

    self.postMessage({ type: 'debug',
        message: '[Farina] peakOff=' + peakOff + '(' + (peakOff/fs).toFixed(3) + 's)' +
                 ' startIdx=' + startIdx + ' irLength=' + irLength +
                 ' (' + (irLength/fs).toFixed(2) + 's)'
    });

    return ir;
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   6æ¬¡ Butterworth BPFï¼ˆ2æ¬¡Biquad Ã— 3æ®µã‚«ã‚¹ã‚±ãƒ¼ãƒ‰ï¼‰
   ANSI S1.11 / ISO 3382æº–æ‹ 
   ã‚«ã‚¹ã‚±ãƒ¼ãƒ‰è£œæ­£: Q_sec = Q_target / sqrt(2^(1/k) - 1)
   å…¨ã‚»ã‚¯ã‚·ãƒ§ãƒ³åŒä¸€ä¿‚æ•°ï¼ˆcenter fcå…±é€šï¼‰
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function designButterworthBPF(fc, fs, order, margin) {
    const nSec = order / 2; // 6æ¬¡ â†’ 3ã‚»ã‚¯ã‚·ãƒ§ãƒ³

    // 1/3ã‚ªã‚¯ã‚¿ãƒ¼ãƒ–å¸¯åŸŸå¹…ï¼ˆ5%å†…å´ã«çµã‚‹ï¼‰
    const fL = (fc / Math.SQRT2) * (1.0 + margin);
    const fH = (fc * Math.SQRT2) * (1.0 - margin);
    const Q_target = fc / (fH - fL);

    // ã‚«ã‚¹ã‚±ãƒ¼ãƒ‰è£œæ­£: kæ®µã§æ‰€å®šã®-3dBå¸¯åŸŸå¹…ã‚’ä¿è¨¼
    const Q_sec = Q_target / Math.sqrt(Math.pow(2, 1.0 / nSec) - 1.0);

    const w0    = 2.0 * Math.PI * fc / fs;
    const alpha = Math.sin(w0) / (2.0 * Q_sec);
    const cosW0 = Math.cos(w0);
    const a0    = 1.0 + alpha;

    const sec = {
        b0:  alpha / a0,
        b1:  0.0,
        b2: -alpha / a0,
        a1: -2.0 * cosW0 / a0,
        a2: (1.0 - alpha) / a0
    };

    // 3ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã¯åŒä¸€ä¿‚æ•°
    return [{ ...sec }, { ...sec }, { ...sec }];
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   Biquadã‚«ã‚¹ã‚±ãƒ¼ãƒ‰é©ç”¨ï¼ˆæ™‚é–“åŸŸIIRãƒ•ã‚£ãƒ«ã‚¿ï¼‰
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function applyBiquadCascade(signal, sections) {
    let buf = new Float64Array(signal);
    for (const s of sections) {
        const out = new Float64Array(buf.length);
        let x1 = 0.0, x2 = 0.0, y1 = 0.0, y2 = 0.0;
        for (let i = 0; i < buf.length; i++) {
            const x0 = buf[i];
            const y0 = s.b0*x0 + s.b1*x1 + s.b2*x2
                     - s.a1*y1 - s.a2*y2;
            out[i] = y0;
            x2 = x1; x1 = x0;
            y2 = y1; y1 = y0;
        }
        buf = out;
    }
    return buf;
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   SNRè¨ˆç®—
   IRãƒ”ãƒ¼ã‚¯ä»˜è¿‘ã‚¨ãƒãƒ«ã‚®ãƒ¼ vs æœ«å°¾ãƒã‚¤ã‚ºãƒ•ãƒ­ã‚¢ã®
   ã‚¨ãƒãƒ«ã‚®ãƒ¼å¯†åº¦æ¯”ï¼ˆã‚µãƒ³ãƒ—ãƒ«æ•°æ­£è¦åŒ–ï¼‰
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   SNRè¨ˆç®—
   äº‹å‰æ¸¬å®šã—ãŸãƒã‚¤ã‚ºãƒ•ãƒ­ã‚¢ãŒã‚ã‚Œã°ãã‚Œã‚’ä½¿ç”¨
   ãªã‘ã‚Œã°IRæœ«å°¾ã‹ã‚‰æ¨å®šï¼ˆå¾“æ¥æ–¹å¼ï¼‰
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function calcSNR(ir, bandIndex) {
    const N = ir.length;

    // ãƒ”ãƒ¼ã‚¯æ¢ç´¢ã‚’å…ˆé ­0.1sï¼ˆ4800ã‚µãƒ³ãƒ—ãƒ« @48kHzï¼‰ä»¥å†…ã«é™å®š
    // ç†ç”±: ç›´é”éŸ³ã¯IRå…ˆé ­ä»˜è¿‘ã«å¿…ãšå­˜åœ¨ã™ã‚‹ã€‚ã‚°ãƒ­ãƒ¼ãƒãƒ«æœ€å¤§å€¤ã‚’ä½¿ã†ã¨
    //       deconvolutionã‚¢ãƒ¼ãƒ†ã‚£ãƒ•ã‚¡ã‚¯ãƒˆã®å½ãƒ”ãƒ¼ã‚¯ã‚’æ‹¾ã†å ´åˆãŒã‚ã‚‹ã€‚
    const peakSearchEnd = Math.min(N, Math.round(_fs * 0.1));
    let peakIdx = 0, peakVal = 0;
    for (let i = 0; i < peakSearchEnd; i++) {
        const v = Math.abs(ir[i]);
        if (v > peakVal) { peakVal = v; peakIdx = i; }
    }

    // ãƒ”ãƒ¼ã‚¯å¾Œ2%çª“ï¼ˆâ‰’85ms @48kHzï¼‰ã§ä¿¡å·RMSã‚’è¨ˆç®—
    const winSamples = Math.max(10, Math.floor(N * 0.02));
    const irEnd      = Math.min(N, peakIdx + winSamples);
    const irCount    = irEnd - peakIdx;
    if (irCount <= 0) return { snr: 60, peakIdx: 0 };

    let irE = 0;
    for (let i = peakIdx; i < irEnd; i++) irE += ir[i]*ir[i];
    const irRMS = Math.sqrt(irE / irCount);

    // ãƒã‚¤ã‚ºRMS: äº‹å‰ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å€¤ã‚’ä½¿ç”¨ï¼ˆæœ€ã‚‚ä¿¡é ¼ã§ãã‚‹ï¼‰
    // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: IRæœ«å°¾æ¨å®šï¼ˆã‚¢ãƒ¼ãƒ†ã‚£ãƒ•ã‚¡ã‚¯ãƒˆã®å½±éŸ¿ã‚’å—ã‘ã‚‹ãŸã‚å‚è€ƒå€¤ï¼‰
    let noiseRMS;
    if (_noiseFloor && bandIndex >= 0 && bandIndex < _noiseFloor.length) {
        noiseRMS = _noiseFloor[bandIndex];
    } else {
        const nStart = Math.floor(N * 0.75);
        let nE = 0;
        for (let i = nStart; i < N; i++) nE += ir[i]*ir[i];
        noiseRMS = Math.sqrt(nE / (N - nStart));
    }

    if (noiseRMS < 1e-20) return { snr: 60, peakIdx: 0, noiseRMS: 1e-10 };
    const snr = 20.0 * Math.log10(irRMS / noiseRMS);
    return { snr, peakIdx, noiseRMS };
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   ã‚·ãƒ¥ãƒ¬ãƒ¼ãƒ€ãƒ¼ç©åˆ†ï¼ˆå¾Œé€€ç´¯ç© + å‹•çš„æ‰“ã¡åˆ‡ã‚Šï¼‰
   EDC(t) = âˆ«[tâ†’âˆ] hÂ²(Ï„)dÏ„
   æ‰“ã¡åˆ‡ã‚Š: ãƒã‚¤ã‚ºå¯†åº¦ã®3å€ã‚’ä¸‹å›ã£ãŸæ™‚ç‚¹
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function schroederIntegral(ir, snr, peakIdx, envNoiseRMS) {
    // ISO 3382-2 Annex Aæº–æ‹ : Lundebyæ³•ã«ã‚ˆã‚‹ãƒã‚¤ã‚ºäº¤ç‚¹æ¤œå‡º + ãƒã‚¤ã‚ºè£œæ­£å¾Œé€€ç©åˆ†
    // å‚è€ƒ: Lundeby et al. (1995) JASA 98(6), ISO 3382-2:2008 Annex A
    //
    // å‡¦ç†ãƒ•ãƒ­ãƒ¼:
    //   1. IRæœ«å°¾10%ã‹ã‚‰ãƒã‚¤ã‚ºåˆ†æ•£(noisePower)ã‚’æ¨å®š
    //   2. å¾Œé€€ç©åˆ† cum[i] = Î£ ir[k]Â² (k=iâ†’N-1)
    //   3. Lundebyäº¤ç‚¹: cum[i] â‰ˆ noisePowerÃ—(N-i) ã‚’æº€ãŸã™æœ€åˆã®ç‚¹
    //   4. Annex Aè£œæ­£: corrected[i] = cum[i] - noisePowerÃ—(N-i)
    //   5. corrected[i]â‰¤0 ã«ãªã£ãŸç‚¹ã§ç©åˆ†çµ‚äº† â†’ EDCç”Ÿæˆ
    const N  = ir.length;
    const fs = _fs;

    // â”€â”€ Step 1: ç’°å¢ƒãƒã‚¤ã‚ºåˆ†æ•£ã‚’æ¨å®š â”€â”€
    // envNoiseRMSï¼ˆcalcSNRãŒè¿”ã™IRæœ«å°¾75%ãƒ™ãƒ¼ã‚¹ï¼‰ã‚’å„ªå…ˆä½¿ç”¨ã€‚
    // ã“ã‚Œã¯Farina IRæŒ¯å¹…ã‚¹ã‚±ãƒ¼ãƒ«ã¨ä¸€è‡´ã—ã¦ãŠã‚Šã€Farinaæ•°å€¤æ®‹ç•™ãƒã‚¤ã‚ºã‚ˆã‚Š
    // æ•°æ¡å¤§ãã„ç’°å¢ƒãƒã‚¤ã‚ºã®å®Ÿæ…‹ã‚’åæ˜ ã—ã¦ã„ã‚‹ã€‚
    // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: IRæœ«å°¾10%æ¨å®šï¼ˆenvNoiseRMSãŒæœªæä¾›ã®å ´åˆï¼‰
    let noisePower;
    if (envNoiseRMS && envNoiseRMS > 1e-20) {
        noisePower = envNoiseRMS * envNoiseRMS;
    } else {
        const noiseStart = Math.floor(N * 0.90);
        let noiseSum = 0;
        for (let i = noiseStart; i < N; i++) noiseSum += ir[i] * ir[i];
        noisePower = noiseSum / (N - noiseStart);
    }

    if (noisePower < 1e-30) {
        self.postMessage({ type: 'debug',
            message: '[Schroeder] noisePower < 1e-30 â†’ æ¸¬å®šä¸èƒ½'
        });
        return null;
    }

    // â”€â”€ Step 2: å¾Œé€€ç©åˆ† â”€â”€
    const cum = new Float64Array(N);
    cum[N - 1] = ir[N - 1] * ir[N - 1];
    for (let i = N - 2; i >= 0; i--) cum[i] = cum[i + 1] + ir[i] * ir[i];

    // â”€â”€ Step 3: Lundebyäº¤ç‚¹æ¤œå‡º â”€â”€
    // cum[i] <= noisePower * (N - i) ã‚’æº€ãŸã™æœ€åˆã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
    // = ã€Œæ®‹ã‚Šã®ç©åˆ†ãŒã™ã¹ã¦ãƒã‚¤ã‚ºã‚¨ãƒãƒ«ã‚®ãƒ¼ã§èª¬æ˜ã§ãã‚‹ç‚¹ã€
    let lundebyIdx = N - 1;
    for (let i = peakIdx; i < N; i++) {
        if (cum[i] <= noisePower * (N - i)) {
            lundebyIdx = i;
            break;
        }
    }

    // â”€â”€ Step 4: Annex Aè£œæ­£ + EDCç”Ÿæˆ â”€â”€
    // corrected[i] = cum[i] - noisePower * (N - i)
    // corrected[peakIdx] > 0 ãŒå¿…é ˆï¼ˆä¿¡å·ãŒãƒã‚¤ã‚ºã‚ˆã‚Šååˆ†å¤§ãã„ï¼‰
    const corrPeak = cum[peakIdx] - noisePower * (N - peakIdx);
    if (corrPeak <= 0) {
        self.postMessage({ type: 'debug',
            message: '[Schroeder] Annex Aè£œæ­£å¤±æ•—: corrected[peakIdx]=' +
                     corrPeak.toExponential(3) + ' <= 0 â†’ ä¿¡å·ãŒãƒã‚¤ã‚ºã«åŸ‹æ²¡'
        });
        return null;
    }

    const edcDB  = new Float64Array(N).fill(-999);
    let truncIdx = lundebyIdx; // Lundebyäº¤ç‚¹ã‚’åˆæœŸæ‰“ã¡åˆ‡ã‚Šç‚¹ã¨ã™ã‚‹

    for (let i = peakIdx; i <= lundebyIdx; i++) {
        const corrected = cum[i] - noisePower * (N - i);
        if (corrected <= 0) {
            // è£œæ­£å¾Œã«è² ã«ãªã£ãŸ = ãƒã‚¤ã‚ºãŒä¿¡å·ã‚’è¶…ãˆãŸç‚¹
            truncIdx = i;
            break;
        }
        edcDB[i] = 10.0 * Math.log10(corrected / corrPeak);
    }

    // è¨ºæ–­ãƒ­ã‚°
    const noisedB     = 10 * Math.log10(noisePower / corrPeak);
    const peakSec     = (peakIdx    / fs).toFixed(3);
    const lundbySec   = (lundebyIdx / fs).toFixed(3);
    const truncSec    = (truncIdx   / fs).toFixed(3);
    const lastValidDB = edcDB[truncIdx - 1] > -999 ? edcDB[truncIdx - 1].toFixed(1) : 'N/A';
    self.postMessage({ type: 'debug',
        message: '[Schroeder/Lundeby] peakIdx=' + peakIdx + '(' + peakSec + 's)' +
                 ' lundebyIdx=' + lundebyIdx + '(' + lundbySec + 's)' +
                 ' truncIdx=' + truncIdx + '(' + truncSec + 's)' +
                 ' noisePower=' + noisePower.toExponential(3) +
                 ' noiseLevel=' + noisedB.toFixed(1) + 'dB' +
                 ' lastValidDB=' + lastValidDB + 'dB'
    });

    return { edcDB, truncIdx, peakIdx };
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   RTè¨ˆç®—ï¼ˆæœ€å°äºŒä¹—ç·šå½¢å›å¸°ï¼‰
   T60â†’T30â†’T20 ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
   ISO 3382-2:2008 æº–æ‹ 
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function calcRT(edcDB, truncIdx, peakIdx, fs) {
    // ç‰©ç†çš„å¦¥å½“æ€§ã®ä¸Šä¸‹é™
    // ä¸Šé™5.0s: å°ã€œä¸­è¦æ¨¡å®¤å†…ã§ã“ã‚Œã‚’è¶…ãˆã‚‹å€¤ã¯èƒŒæ™¯ãƒã‚¤ã‚ºèª¤èª
    // ä¸‹é™0.05s: 50msæœªæº€ã¯æ¸¬å®šãƒã‚¤ã‚ºç”±æ¥ã®èª¤æ¤œå‡º
    const RT_MAX = 5.0;
    // RT_MIN = 0.03s: BTç©åŸºæº–(BÃ—T>16)ã‚ˆã‚Š1kHzä»¥ä¸Šã§ã¯30msä»¥ä¸ŠãŒæœ‰åŠ¹
    // æ¥µç«¯ã«çŸ­ã„å ´åˆ(30-50ms)ã¯è¡¨ç¤ºã—ã¤ã¤ç²¾åº¦æ³¨æ„ã‚’ä¿ƒã™
    const RT_MIN = 0.03;
    // RÂ²_MIN = 0.80: Lundebyè£œæ­£å¾ŒEDCã¯ç›´ç·šæ€§ãŒå‘ä¸Šã™ã‚‹ãŸã‚0.75â†’0.80ã«å¼•ãä¸Šã’
    const R2_MIN = 0.80;

    function validate(result, method) {
        if (!result) return null;
        const { rt, r2 } = result;
        if (rt < RT_MIN || rt > RT_MAX) {
            self.postMessage({ type: 'debug',
                message: '[calcRT] ' + method + ' rejected: rt=' + rt.toFixed(3) + 's out of range'
            });
            return null;
        }
        if (r2 < R2_MIN) {
            self.postMessage({ type: 'debug',
                message: '[calcRT] ' + method + ' rejected: RÂ²=' + r2.toFixed(3) + ' < ' + R2_MIN
            });
            return null;
        }
        return { rt60: rt, method, r2 };
    }

    // èµ°æŸ»ä¸Šé™: RT_MAXÃ—2.0ç§’
    // Annex Aè£œæ­£å¾Œã®EDCã¯ãƒ•ãƒ©ãƒƒãƒˆæœ«å°¾ãŒã‚†ã£ãã‚Šç›®æ¨™dBã«é”ã™ã‚‹ãŸã‚ã€
    // ã“ã®ä¸Šé™ã§lsqRTã®å›å¸°å¯¾è±¡ã‹ã‚‰é™¤å¤–ã™ã‚‹
    const maxSearchSec = RT_MAX * 2.0;

    // T60: -5dB â†’ -65dB
    const v60 = validate(lsqRT(edcDB, truncIdx, peakIdx, fs, -5, -65, maxSearchSec), 'T60');
    if (v60) return v60;

    // T30: -5dB â†’ -35dB â†’ Ã—2å¤–æŒ¿
    const r30 = lsqRT(edcDB, truncIdx, peakIdx, fs, -5, -35, maxSearchSec);
    if (r30) {
        const v30 = validate({ rt: r30.rt * 2.0, r2: r30.r2 }, 'T30');
        if (v30) return v30;
    }

    // T20: -5dB â†’ -25dB â†’ Ã—3å¤–æŒ¿
    const r20 = lsqRT(edcDB, truncIdx, peakIdx, fs, -5, -25, maxSearchSec);
    if (r20) {
        const v20 = validate({ rt: r20.rt * 3.0, r2: r20.r2 }, 'T20');
        if (v20) return v20;
    }

    return null;
}

function lsqRT(edcDB, truncIdx, peakIdx, fs, startDB, endDB, maxSearchSec) {
    // ãƒ«ãƒ¼ãƒ—ã‚’ peakIdx èµ·ç‚¹ã«ã™ã‚‹
    // peakIdx ä»¥å‰ã® edcDB ã¯ -999ï¼ˆæœªè¨ˆç®—ï¼‰ã®ãŸã‚ã€0ã‹ã‚‰èµ°æŸ»ã™ã‚‹ã¨
    // -999 <= -5 ãŒçœŸã«ãªã‚Š s=0, e=1 ãŒå³ç¢ºå®šã—ã¦ã—ã¾ã„å…¨ãƒãƒ³ãƒ‰å¤±æ•—ã™ã‚‹
    //
    // searchEnd: Annex Aè£œæ­£å¾Œã®EDCã¯æ®‹éŸ¿æ¶ˆæ»…å¾Œã‚‚ã‚†ã£ãã‚Šç›®æ¨™dBã«é”ã™ã‚‹ãŸã‚
    // ç‰©ç†çš„ã«æ„å‘³ã®ã‚ã‚‹æœ€å¤§èµ°æŸ»ç¯„å›²ï¼ˆRT_MAXÃ—2.0ç§’ï¼‰ã§æ‰“ã¡åˆ‡ã‚‹ã€‚
    // ä¾‹: RT_MAX=5s â†’ maxSearchSec=10s â†’ 10sä»¥é™ã®ãƒ•ãƒ©ãƒƒãƒˆåŒºé–“ã‚’å›å¸°å¯¾è±¡å¤–ã«ã™ã‚‹
    const searchEnd = (maxSearchSec != null)
        ? Math.min(truncIdx, peakIdx + Math.floor(maxSearchSec * fs))
        : truncIdx;

    let s = -1, e = -1;
    for (let i = peakIdx; i < searchEnd; i++) {
        if (s < 0 && edcDB[i] <= startDB) { s = i; continue; }
        if (s >= 0 && edcDB[i] <= endDB)  { e = i; break; }
    }
    if (s < 0 || e < 0 || (e - s) < 10) return null;

    let n = 0, sumX = 0, sumY = 0, sumXY = 0, sumXX = 0;
    for (let i = s; i <= e; i++) {
        const t = i / fs;
        sumX  += t;
        sumY  += edcDB[i];
        sumXY += t * edcDB[i];
        sumXX += t * t;
        n++;
    }
    const denom = n * sumXX - sumX * sumX;
    if (Math.abs(denom) < 1e-15) return null;

    const slope     = (n * sumXY - sumX * sumY) / denom;
    const intercept = (sumY - slope * sumX) / n;
    if (slope >= 0) return null; // æ¸›è¡°ã—ã¦ã„ãªã„

    // æ±ºå®šä¿‚æ•° RÂ² ã‚’è¨ˆç®—
    const meanY = sumY / n;
    let ssTot = 0, ssRes = 0;
    for (let i = s; i <= e; i++) {
        const t    = i / fs;
        const pred = slope * t + intercept;
        ssTot += (edcDB[i] - meanY) * (edcDB[i] - meanY);
        ssRes += (edcDB[i] - pred)  * (edcDB[i] - pred);
    }
    const r2 = ssTot > 0 ? 1.0 - ssRes / ssTot : 0;

    return { rt: (endDB - startDB) / slope, r2 };
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   ãƒ¡ã‚¤ãƒ³è§£æé–¢æ•°
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function analyzeAll(msg) {
    // â”€â”€ å˜ä¸€ãƒ–ãƒ­ãƒ¼ãƒ‰ãƒãƒ³ãƒ‰ã‚¹ã‚¤ãƒ¼ãƒ—ã‹ã‚‰ã®å…¨ãƒãƒ³ãƒ‰è§£æ â”€â”€
    // ISO 3382-2æº–æ‹ : Farinaæ³•1å›ã®deconvolution â†’ å…¨ãƒãƒ³ãƒ‰å…±é€šIR â†’ BPFÃ—18
    const { recorded, sweep, fLow, fHigh, durationSec } = msg;
    const fs       = _fs;
    const minSnr   = (_cfg && _cfg.analysis) ? _cfg.analysis.minSnr   : 15.0;
    const bpfOrder = (_cfg && _cfg.analysis) ? _cfg.analysis.bpfOrder :  6;
    const bpfMargin= (_cfg && _cfg.analysis) ? _cfg.analysis.bpfMargin: 0.05;
    const bands    = (_cfg && _cfg.bands)    ? _cfg.bands : [100,125,160,200,250,315,400,500,630,800,1000,1250,1600,2000,2500,3150,4000,5000];

    self.postMessage({ type: 'debug', message: 'analyzeAll: rec=' + recorded.byteLength + 'bytes, sweep=' + sweep.byteLength + 'bytes' });

    try {
        const recF32 = new Float32Array(recorded);
        const swpF32 = new Float32Array(sweep);

        // â‘  ç›¸äº’ç›¸é–¢ã§Sweepé–‹å§‹ä½ç½®ã‚’ä¸€åº¦ã ã‘æ¤œå‡º
        const sweepStart = findSweepStart(recF32, swpF32);
        self.postMessage({ type: 'debug', message: 'findSweepStart: offset=' + sweepStart + ' (' + (sweepStart/fs).toFixed(3) + 's)' });

        // â‘¡ Sweepæœ¬ä½“ï¼‹æ®‹éŸ¿åŒºé–“ã‚’åˆ‡ã‚Šå‡ºã—ï¼ˆå…¨ãƒãƒ³ãƒ‰å…±é€šï¼‰
        const reverbTail   = Math.floor(5.0 * fs);   // æ®‹éŸ¿å–å¾—æ™‚é–“ 5ç§’
        const requiredLen  = swpF32.length + reverbTail;
        const endPos       = Math.min(sweepStart + requiredLen, recF32.length);
        const trimmed      = recF32.slice(sweepStart, endPos);

        // â‘¢ Farinaæ³•deconvolution â†’ å…¨ãƒãƒ³ãƒ‰å…±é€šIR
        // extractIRFarina: æ™‚é–“åè»¢ã‚¹ã‚¤ãƒ¼ãƒ—Ã—expé‡ã¿ä»˜ã‘ã®é€†ãƒ•ã‚£ãƒ«ã‚¿ã‚’FFTä¹—ç®—
        const ir = extractIRFarina(trimmed, swpF32, fLow, fHigh, durationSec);
        self.postMessage({ type: 'debug', message: 'extractIRFarina done: ir.length=' + ir.length });

        // â‘£ å„ãƒãƒ³ãƒ‰ã§BPF â†’ SNR â†’ Schroederï¼ˆISOè£œæ­£ï¼‰â†’ calcRT
        const thirdResults  = new Array(bands.length).fill(null);
        const methodResults = new Array(bands.length).fill(null);
        const r2Results     = new Array(bands.length).fill(null);

        for (let bi = 0; bi < bands.length; bi++) {
            const band = bands[bi];

            // é€²æ—é€šçŸ¥
            self.postMessage({ type: 'bandProgress', band, index: bi, total: bands.length });

            // BPFé©ç”¨
            const sections   = designButterworthBPF(band, fs, bpfOrder, bpfMargin);
            const irFiltered = applyBiquadCascade(ir, sections);

            // SNRè¨ˆç®—ï¼ˆbandIndex=-1 â†’ IRæœ«å°¾75%ã‹ã‚‰ãƒã‚¤ã‚ºæ¨å®šã‚’å¼·åˆ¶ï¼‰
            // _noiseFloorï¼ˆç”Ÿãƒã‚¤ã‚¯RMSï¼‰ã¯Farina IRæŒ¯å¹…ã‚¹ã‚±ãƒ¼ãƒ«ã¨ç•°ãªã‚‹ãŸã‚ä½¿ç”¨ã—ãªã„
            const { snr, peakIdx, noiseRMS } = calcSNR(irFiltered, -1);

            self.postMessage({ type: 'debug',
                message: band + 'Hz: SNR=' + snr.toFixed(1) + 'dB peakIdx=' + peakIdx +
                         '(' + (peakIdx/fs).toFixed(3) + 's) noiseRMS=' + noiseRMS.toExponential(3)
            });

            if (snr < minSnr) {
                self.postMessage({ type: 'debug', message: band + 'Hz: SNRä¸è¶³ â†’ skip' });
                continue;
            }

            // Schroederç©åˆ†: calcSNRã®ç’°å¢ƒãƒã‚¤ã‚ºæ¨å®šå€¤ã‚’Lundebyäº¤ç‚¹æ¤œå‡ºã«ä½¿ç”¨
            const schResult = schroederIntegral(irFiltered, snr, peakIdx, noiseRMS);
            if (!schResult) {
                self.postMessage({ type: 'debug', message: band + 'Hz: Schroederè£œæ­£å¤±æ•— â†’ skip' });
                continue;
            }
            const { edcDB, truncIdx } = schResult;

            // RTè¨ˆç®—
            const rtResult = calcRT(edcDB, truncIdx, peakIdx, fs);
            if (!rtResult) {
                self.postMessage({ type: 'debug', message: band + 'Hz: RTè¨ˆç®—å¤±æ•— â†’ skip' });
                continue;
            }

            thirdResults[bi]  = +rtResult.rt60.toFixed(3);
            methodResults[bi] = rtResult.method;
            r2Results[bi]     = +rtResult.r2.toFixed(3);
            self.postMessage({ type: 'debug',
                message: band + 'Hz: RT60=' + thirdResults[bi] + 's (' + rtResult.method + ', RÂ²=' + rtResult.r2.toFixed(3) + ')'
            });
        }

        // â‘¤ å…¨ãƒãƒ³ãƒ‰å®Œäº† â†’ resulté€ä¿¡
        self.postMessage({ type: 'result', thirdResults, methodResults, r2Results });

    } catch (err) {
        self.postMessage({ type: 'error', message: 'analyzeAllå¤±æ•—: ' + err.message });
    }
}
`;

let measurementWorker = null;

function initWorker() {
    const blob = new Blob([workerCode], { type: 'text/javascript' });
    measurementWorker = new Worker(URL.createObjectURL(blob));
    measurementWorker.onmessage = function(e) {
        // ãƒ‡ãƒãƒƒã‚°ï¼šå…¨ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ãƒ­ã‚°
        console.log('=== Worker Message Received ===', e.data.type);
        
        if (e.data.type === 'debug') {
            // 3ã¤ã®æ–¹æ³•ã§ãƒ­ã‚°å‡ºåŠ›
            console.log('[Worker] ' + e.data.message);
            console.info('[Worker-INFO] ' + e.data.message);
            console.warn('[Worker-DEBUG] ' + e.data.message);
            return;
        }
        if (e.data.type === 'result') handleMeasurementResult(e.data);
        if (e.data.type === 'error') handleMeasurementError(e.data.message);
    };
    measurementWorker.onerror = function(err) { console.error('Worker error:', err); };
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Part 5: æ¸¬å®šçµæœãƒãƒ³ãƒ‰ãƒ©
// 18ãƒãƒ³ãƒ‰ï¼ˆ1/3octï¼‰â†’ 6ãƒãƒ³ãƒ‰ï¼ˆã‚ªã‚¯ã‚¿ãƒ¼ãƒ–ï¼‰é›†ç´„
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function handleMeasurementResult(data) {
    const statusEl   = document.getElementById('measureStatus');
    const startBtn   = document.getElementById('startMeasBtn');
    const progressEl = document.getElementById('measureProgress');
    const warnEl     = document.getElementById('remeasureWarning');

    // UIåˆæœŸåŒ–
    startBtn.disabled = false;
    progressEl.style.display = 'none';
    document.getElementById('recordingAlert').classList.remove('active');
    warnEl.style.display = 'none';

    const thirdResults = data.thirdResults; // 18æœ¬ã®1/3ã‚ªã‚¯ã‚¿ãƒ¼ãƒ–RT60é…åˆ—ï¼ˆnullã‚ã‚Šï¼‰
    const octaveDefs   = MEASUREMENT_CONFIG.octaveBands;
    const octaveResults = new Array(6).fill(null);

    let validOctaveCount  = 0;
    let totalOctaveCount  = 6;
    const missingBands    = [];
    const measuredBands   = [];

    // â”€â”€ 18ãƒãƒ³ãƒ‰ â†’ 6ã‚ªã‚¯ã‚¿ãƒ¼ãƒ–ãƒãƒ³ãƒ‰ã«é›†ç´„ï¼ˆnull=æ¬ æã®ã¾ã¾ï¼‰â”€â”€
    // Sabineè£œå®Œã¯è¡Œã‚ãªã„ã€‚æ¸¬å®šã§ããªã‹ã£ãŸãƒãƒ³ãƒ‰ã¯nullã¨ã—ã¦æ‰±ã†ã€‚
    for (let i = 0; i < octaveDefs.length; i++) {
        const group  = octaveDefs[i];
        const values = group.indices
            .map(idx => thirdResults[idx])
            .filter(v => v !== null && v > 0);

        if (values.length > 0) {
            // æœ‰åŠ¹ãª1/3octãƒãƒ³ãƒ‰ã®ç®—è¡“å¹³å‡ã‚’ã‚ªã‚¯ã‚¿ãƒ¼ãƒ–ãƒãƒ³ãƒ‰å€¤ã¨ã™ã‚‹
            octaveResults[i] = values.reduce((s, v) => s + v, 0) / values.length;
            validOctaveCount++;
            measuredBands.push(group.label);
        } else {
            // nullã®ã¾ã¾ä¿æŒï¼ˆè£œå®Œã—ãªã„ï¼‰
            octaveResults[i] = null;
            missingBands.push(group.label);
        }
    }

    // â”€â”€ methodResults ã‚’å—ã‘å–ã‚‹ â”€â”€
    const methodResults = data.methodResults || new Array(18).fill(null);
    window._r2Results = data.r2Results || new Array(18).fill(null);
    window._methodResultsAll = data.methodResults || new Array(18).fill(null);

    // â”€â”€ 500Hz(index2) + 1kHz(index3) ä¸¡æ–¹æ¬ æ â†’ éŸ³éŸ¿è©•ä¾¡ã¨ã—ã¦å¤±æ•— â”€â”€
    const miss500  = octaveResults[2] === null;
    const miss1k   = octaveResults[3] === null;
    if (miss500 && miss1k) {
        statusEl.textContent = 'âŒ æ¸¬å®šå¤±æ•—: 500Hzãƒ»1kHz ãŒå–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸ';
        statusEl.className = 'status-msg error';
        document.getElementById('warningReason').textContent =
            'éŸ³éŸ¿è©•ä¾¡ã®ä¸­æ ¸å¸¯åŸŸï¼ˆ500Hzãƒ»1kHzï¼‰ãŒä¸¡æ–¹å–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚\n' +
            'ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼éŸ³é‡ã‚’ä¸Šã’ã‚‹ã‹ã€å¤–éƒ¨ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼ã§å†æ¸¬å®šã—ã¦ãã ã•ã„ã€‚';
        warnEl.className = 'warning-box';
        warnEl.style.display = 'block';
        startBtn.disabled = false;
        return;
    }

    // â”€â”€ 0ãƒãƒ³ãƒ‰ â†’ ã‚¨ãƒ©ãƒ¼ â”€â”€
    if (validOctaveCount === 0) {
        statusEl.textContent = 'âŒ æ¸¬å®šå¤±æ•—: æœ‰åŠ¹ãƒ‡ãƒ¼ã‚¿ãŒ0ãƒãƒ³ãƒ‰ã§ã™';
        statusEl.className = 'status-msg error';
        document.getElementById('warningReason').textContent =
            'ã™ã¹ã¦ã®ãƒãƒ³ãƒ‰ã§SNRä¸è¶³ã®ãŸã‚æ¸¬å®šã§ãã¾ã›ã‚“ã§ã—ãŸã€‚\n' +
            'ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼éŸ³é‡ã‚’ä¸Šã’ã‚‹ã‹ã€ç’°å¢ƒãƒã‚¤ã‚ºã‚’ä¸‹ã’ã¦å†æ¸¬å®šã—ã¦ãã ã•ã„ã€‚';
        warnEl.className = 'warning-box';
        warnEl.style.display = 'block';
        startBtn.disabled = false;
        return;
    }

    // â”€â”€ æ¸¬å®šå®Œäº†: æœ‰åŠ¹ãƒãƒ³ãƒ‰ã®ã¿measurementDataã«æ ¼ç´ â”€â”€
    measurementData = octaveResults; // nullã‚’å«ã‚€6è¦ç´ é…åˆ—

    // ã‚ªã‚¯ã‚¿ãƒ¼ãƒ–ãƒãƒ³ãƒ‰ã«å¯¾å¿œã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ã‚’é›†ç´„ï¼ˆæœ€ä½å“è³ªãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä»£è¡¨å€¤ï¼‰
    const METHOD_RANK = { 'T20': 0, 'T30': 1, 'T60': 2 };
    const octaveDefs2 = MEASUREMENT_CONFIG.octaveBands;
    let lowestMethod = 'T60';
    for (let i = 0; i < octaveDefs2.length; i++) {
        if (octaveResults[i] === null) continue;
        for (const bi of octaveDefs2[i].indices) {
            const m = methodResults[bi];
            if (m && METHOD_RANK[m] < METHOD_RANK[lowestMethod]) lowestMethod = m;
        }
    }
    window._measurementMethod = lowestMethod;

    // ãƒãƒƒã‚¸å³æ™‚æ›´æ–°ï¼ˆswitchMode()ã‚’å¾…ãŸãšã«resultå—ä¿¡æ™‚ç‚¹ã§åæ˜ ï¼‰
    const _badge = document.getElementById('methodBadge');
    if (_badge) {
        const _methodColors = { 'T60': 'var(--success)', 'T30': 'var(--warning)', 'T20': 'var(--caution)' };
        _badge.textContent = lowestMethod;
        _badge.style.background = _methodColors[lowestMethod] || 'var(--warning)';
    }

    saveRoomSizeToBuffer();
    disableRoomSizeInputs();
    measurementActive = true;

    const bandSummary = 'Measured: ' + validOctaveCount + ' / ' + totalOctaveCount + ' bands';

    // â”€â”€ è­¦å‘Šãƒ¬ãƒ™ãƒ«åˆ¤å®š â”€â”€
    if (validOctaveCount >= 5) {
        statusEl.textContent = 'âœ… æ¸¬å®šå®Œäº†ï¼ˆ' + bandSummary + 'ï¼‰';
        statusEl.className = 'status-msg success';
    } else if (validOctaveCount >= 3) {
        statusEl.textContent = 'âš ï¸ æ¸¬å®šå®Œäº†ï¼ˆ' + bandSummary + 'ï¼‰â€” ç²¾åº¦æ³¨æ„';
        statusEl.className = 'status-msg warning';
        const warnText =
            'æ¬ æãƒãƒ³ãƒ‰: ' + missingBands.join(', ') + '\n' +
            'SNRä¸è¶³ã¾ãŸã¯EDCå“è³ªä¸è‰¯ã®ãŸã‚ä¸€éƒ¨ãƒãƒ³ãƒ‰ãŒå–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚\n' +
            'æ¬ æãƒãƒ³ãƒ‰ã¯N/Aã¨ã—ã¦è¡¨ç¤ºã€‚å¤–éƒ¨ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼ã§ã®å†æ¸¬å®šã‚’æ¨å¥¨ã—ã¾ã™ã€‚';
        document.getElementById('warningReason').textContent = warnText;
        warnEl.className = 'warning-box warning-yellow';
        warnEl.style.display = 'block';
    } else {
        statusEl.textContent = 'ğŸ”´ æ¸¬å®šå®Œäº†ï¼ˆ' + bandSummary + 'ï¼‰â€” ç²¾åº¦ä¸è¶³ãƒ»å†æ¸¬å®šæ¨å¥¨';
        statusEl.className = 'status-msg error';
        const warnText =
            'æ¬ æãƒãƒ³ãƒ‰: ' + missingBands.join(', ') + '\n' +
            'å–å¾—ã§ããŸãƒãƒ³ãƒ‰ãŒå°‘ãªãã€éŸ³éŸ¿è©•ä¾¡ã®ä¿¡é ¼æ€§ãŒä½ã„çŠ¶æ…‹ã§ã™ã€‚\n' +
            'ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼éŸ³é‡ã‚’ä¸Šã’ã‚‹ã‹ã€å¤–éƒ¨ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼ãƒ»ãƒã‚¤ã‚¯ã§å†æ¸¬å®šã—ã¦ãã ã•ã„ã€‚';
        document.getElementById('warningReason').textContent = warnText;
        warnEl.className = 'warning-box';
        warnEl.style.display = 'block';
    }

    calculate();
}


function handleMeasurementError(message) {
    const statusEl = document.getElementById('measureStatus');
    document.getElementById('startMeasBtn').disabled = false;
    document.getElementById('measureProgress').style.display = 'none';
    document.getElementById('recordingAlert').classList.remove('active');
    statusEl.textContent = 'âŒ ' + message;
    statusEl.className = 'status-msg error';
}

window.addEventListener('DOMContentLoaded', function() { initWorker(); });
</script>

<script>
// ========================================
// æ¸¬å®šè¨­å®šï¼ˆRev 18.25 Broadband Sweepä»•æ§˜ï¼‰
// ========================================
const MEASUREMENT_CONFIG = {

    // ã‚µãƒ³ãƒ—ãƒ«ãƒ¬ãƒ¼ãƒˆè¦æ±‚å€¤ï¼ˆ48kHzå›ºå®šï¼‰
    // AudioContextä½œæˆå¾Œã«å®Ÿæ¸¬å€¤ã¨ç…§åˆã—ã€ä¸ä¸€è‡´ã®å ´åˆã¯ã‚¨ãƒ©ãƒ¼
    sampleRate: 48000,

    // æ¸¬å®šãƒãƒ³ãƒ‰: 1/3ã‚ªã‚¯ã‚¿ãƒ¼ãƒ– 18ãƒãƒ³ãƒ‰ï¼ˆISO 266:2003æº–æ‹ ï¼‰
    // 3ãƒãƒ³ãƒ‰ãšã¤ã‚°ãƒ«ãƒ¼ãƒ—åŒ–ã—ã¦6ã‚ªã‚¯ã‚¿ãƒ¼ãƒ–ãƒãƒ³ãƒ‰ã«é›†ç´„ã™ã‚‹
    bands: [
        100, 125, 160,   // â†’ 125Hz ã‚ªã‚¯ã‚¿ãƒ¼ãƒ–ãƒãƒ³ãƒ‰
        200, 250, 315,   // â†’ 250Hz
        400, 500, 630,   // â†’ 500Hz
        800, 1000, 1250, // â†’ 1kHz
        1600, 2000, 2500,// â†’ 2kHz
        3150, 4000, 5000 // â†’ 4kHz
    ],

    // ã‚ªã‚¯ã‚¿ãƒ¼ãƒ–ãƒãƒ³ãƒ‰é›†ç´„ã‚°ãƒ«ãƒ¼ãƒ—
    // indices ã¯ä¸Šè¨˜ bands é…åˆ—ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã«å¯¾å¿œ
    octaveBands: [
        { label: '125Hz', indices: [0, 1, 2]   },
        { label: '250Hz', indices: [3, 4, 5]   },
        { label: '500Hz', indices: [6, 7, 8]   },
        { label: '1kHz',  indices: [9, 10, 11] },
        { label: '2kHz',  indices: [12, 13, 14]},
        { label: '4kHz',  indices: [15, 16, 17]}
    ],

    // ã‚¿ã‚¤ãƒŸãƒ³ã‚°è¨­å®šï¼ˆ1ãƒãƒ³ãƒ‰ã‚ãŸã‚Š / å˜ä½: ç§’ï¼‰
    // Bluetoothé…å»¶ãƒ»ç›¸äº’ç›¸é–¢ã«å¯¾å¿œã—ãŸä½™è£•ã‚’æŒã£ãŸè¨­å®š
    timing: {
        delay:         1.0,  // Bluetoothå®‰å®šåŒ–å¾…æ©Ÿï¼ˆ0.5â†’1.0ç§’ï¼‰
        stimulus:      5.0,  // ãƒ–ãƒ­ãƒ¼ãƒ‰ãƒãƒ³ãƒ‰ Log-Sweep å†ç”Ÿï¼ˆ20Hzã€œ20kHzï¼‰
        recording:     5.0,  // æ®‹éŸ¿æ¸›è¡°éŒ²éŸ³ï¼ˆæ®‹éŸ¿æ™‚é–“5ç§’ã‚’ç¢ºä¿ï¼‰
        totalPerBand:  5.0   // å‚ç…§å€¤ï¼ˆå˜ä¸€éŒ²éŸ³ã®ãŸã‚å®Ÿè³ªä¸ä½¿ç”¨ï¼‰
    },

    // è§£æãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
    analysis: {
        bpfOrder:  6,     // Butterworth BPF æ¬¡æ•°ï¼ˆ36dB/octï¼‰
        bpfMargin: 0.05,  // ã‚«ãƒƒãƒˆã‚ªãƒ•ã‚’è¦æ ¼ã‚ˆã‚Š5%å†…å´ã«è¨­å®šï¼ˆéš£æ¥å¸¯åŸŸæ¼ã‚Œé˜²æ­¢ï¼‰
        minSnr:    15.0   // æ¡ç”¨æœ€ä½SNR [dB]ã€‚æœªæº€ã¯nullï¼ˆBæ¡ˆ: æ¬ ææ‰±ã„ï¼‰
    },

    // æ¸¬å®šé–‹å§‹ã‚¢ãƒŠã‚¦ãƒ³ã‚¹BeepéŸ³
    beep: {
        frequency:  1000, // Hz
        duration:   0.2,  // ç§’
        gain:       0.3,  // éŸ³é‡
        waitAfter:  1.0   // Beepå¾Œã®æº–å‚™å¾…æ©Ÿï¼ˆç§’ï¼‰
    },

    // sweepGain: Sweepä¿¡å·ã®å‡ºåŠ›ã‚²ã‚¤ãƒ³
    sweepGain: 0.7
};

let audioContext = null;
let mediaStream = null;
let systemLatencyOffset = null;  // ãƒ¬ã‚¤ãƒ†ãƒ³ã‚·ãƒ¼ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³çµæœï¼ˆã‚µãƒ³ãƒ—ãƒ«æ•°ï¼‰

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£: æŒ‡å®šãƒŸãƒªç§’å¾…æ©Ÿ
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// é€²æ—UIæ›´æ–°
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// updateProgress, checkEarlyTermination: ãƒ–ãƒ­ãƒ¼ãƒ‰ãƒãƒ³ãƒ‰æ–¹å¼ç§»è¡Œã«ã‚ˆã‚Šå»ƒæ­¢ (Rev 18.20)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³: ãƒã‚¤ã‚ºãƒ•ãƒ­ã‚¢æ¸¬å®šï¼ˆ2ç§’ç„¡éŸ³éŒ²éŸ³ï¼‰
// éŒ²éŸ³ãƒ‡ãƒ¼ã‚¿ã‚’ãã®ã¾ã¾Workerã«é€ã‚Šã€Workerå´ã§ãƒãƒ³ãƒ‰åˆ¥è§£æ
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function measureNoiseFloor(ctx, stream) {
    const fs = ctx.sampleRate;
    const duration = 5.0; // ç§’ï¼ˆ2ç§’â†’5ç§’ã«å»¶é•·ï¼šçªç™ºãƒã‚¤ã‚ºã‚’å¹³å‡åŒ–ã€é–¾å€¤å®‰å®šåŒ–ï¼‰
    const totalSamples = Math.round(duration * fs);

    // ScriptProcessorã§éŒ²éŸ³
    const bufferSize = 4096;
    const recorded = new Float32Array(totalSamples);
    let recordedSamples = 0;
    let resolveRecording;
    const recordingDone = new Promise(r => { resolveRecording = r; });

    const source = ctx.createMediaStreamSource(stream);
    const processor = ctx.createScriptProcessor(bufferSize, 1, 1);

    processor.onaudioprocess = (e) => {
        const input = e.inputBuffer.getChannelData(0);
        for (let i = 0; i < input.length; i++) {
            if (recordedSamples < totalSamples) {
                recorded[recordedSamples++] = input[i];
            }
        }
        if (recordedSamples >= totalSamples) {
            resolveRecording();
        }
    };

    // ScriptProcessorã®æ¥ç¶šï¼ˆChromeä»•æ§˜ã§å¿…è¦ï¼‰
    // MediaStreamDestinationã«æ¥ç¶šã™ã‚‹ã“ã¨ã§ç‰©ç†å‡ºåŠ›ã‚’å›é¿
    const dummyDestination = ctx.createMediaStreamDestination();
    source.connect(processor);
    processor.connect(dummyDestination);  // ä»®æƒ³å‡ºåŠ›ã®ã¿

    await recordingDone;

    source.disconnect();
    processor.disconnect();

    // RawéŒ²éŸ³ãƒ‡ãƒ¼ã‚¿ã‚’è¿”ã™ï¼ˆWorkerã§å¸¯åŸŸåˆ¥è§£æï¼‰
    return recorded;
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ã‚¢ãƒŠã‚¦ãƒ³ã‚¹BeepéŸ³å†ç”Ÿï¼ˆiOSå¯¾å¿œï¼‰
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function playBeep(ctx, speakerId) {
    const cfg = MEASUREMENT_CONFIG.beep;
    
    // BeepéŸ³ç”Ÿæˆ
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    
    osc.type = 'sine';
    osc.frequency.value = cfg.frequency;
    gain.gain.setValueAtTime(cfg.gain, ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + cfg.duration);
    
    osc.connect(gain);
    
    if (isIOS) {
        // iOS: ç›´æ¥æ¥ç¶šï¼ˆã‚·ãƒ³ãƒ—ãƒ«ãƒ»å®‰å®šï¼‰
        gain.connect(ctx.destination);
        
        // AudioContext.resume()ï¼ˆiOSå¿…é ˆï¼‰
        if (ctx.state === 'suspended') {
            await ctx.resume();
        }
        
        osc.start(ctx.currentTime);
        osc.stop(ctx.currentTime + cfg.duration);
        
    } else {
        // PC/Android: MediaStreamDestinationçµŒç”±ï¼ˆã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼é¸æŠå¯èƒ½ï¼‰
        const destination = ctx.createMediaStreamDestination();
        gain.connect(destination);
        
        // HTMLAudioElementã§å†ç”Ÿ
        const audio = new Audio();
        audio.srcObject = destination.stream;
        
        // ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼æŒ‡å®š
        if (speakerId && typeof audio.setSinkId === 'function') {
            try {
                await audio.setSinkId(speakerId);
            } catch (err) {
                console.warn('setSinkIdå¤±æ•—ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼ä½¿ç”¨ï¼‰:', err.message);
            }
        }
        
        osc.start(ctx.currentTime);
        osc.stop(ctx.currentTime + cfg.duration);
        
        await audio.play();
    }
    
    // Beepå†ç”Ÿå®Œäº† + å¾…æ©Ÿæ™‚é–“
    await sleep((cfg.duration + cfg.waitAfter) * 1000);
    
    // ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
    osc.disconnect();
    gain.disconnect();
}
function generateBroadbandSweep(sampleRate, durationSec) {
    // ISO 3382-2æº–æ‹ : 20Hzã€œ20kHzã®ãƒ•ãƒ«ãƒ¬ãƒ³ã‚¸å¯¾æ•°ã‚¹ã‚¤ãƒ¼ãƒ—
    // å˜ä¸€ã‚¹ã‚¤ãƒ¼ãƒ—ã§å…¨ãƒãƒ³ãƒ‰ã‚’ã‚«ãƒãƒ¼ã—ã€deconvolutionã¯1å›ã®ã¿
    const fLow  = 20;
    const fHigh = 20000;

    const guardPre  = Math.round(0.15 * sampleRate);  // 150mså‰ã‚¬ãƒ¼ãƒ‰
    const guardPost = Math.round(0.10 * sampleRate);  // 100mså¾Œã‚¬ãƒ¼ãƒ‰

    const sweepSamples = Math.round(durationSec * sampleRate);
    const k = Math.log(fHigh / fLow) / durationSec;

    const totalSamples = guardPre + sweepSamples + guardPost;
    const sweep = new Float32Array(totalSamples);

    for (let i = 0; i < sweepSamples; i++) {
        const t = i / sampleRate;
        const phase = 2 * Math.PI * fLow * (Math.exp(k * t) - 1) / k;
        sweep[guardPre + i] = Math.sin(phase) * MEASUREMENT_CONFIG.sweepGain;
    }

    // Tukeyçª“ãƒ•ã‚§ãƒ¼ãƒ‰ï¼ˆ50msï¼‰
    const fadeSamples = Math.round(0.05 * sampleRate);
    for (let i = 0; i < fadeSamples; i++) {
        const progress = i / fadeSamples;
        sweep[guardPre + i] *= 0.5 * (1 - Math.cos(Math.PI * progress));
        sweep[guardPre + sweepSamples - fadeSamples + i] *= 0.5 * (1 + Math.cos(Math.PI * progress));
    }

    return { sweep, fLow, fHigh, durationSec: durationSec };
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ãƒ¬ã‚¤ãƒ†ãƒ³ã‚·ãƒ¼ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
// ã‚·ã‚¹ãƒ†ãƒ å›ºæœ‰ã®é…å»¶ï¼ˆå†ç”Ÿâ†’éŒ²éŸ³ï¼‰ã‚’æ¸¬å®š
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// ãƒãƒ£ãƒ¼ãƒ—ä¿¡å·ç”Ÿæˆï¼ˆã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ç”¨ï¼‰
function generateCalibrationChirp(sampleRate) {
    const duration = 0.1;  // 100ms
    const f1 = 500;        // é–‹å§‹å‘¨æ³¢æ•°
    const f2 = 2000;       // çµ‚äº†å‘¨æ³¢æ•°
    const samples = Math.floor(duration * sampleRate);
    const chirp = new Float32Array(samples);
    
    for (let i = 0; i < samples; i++) {
        const t = i / sampleRate;
        const phase = 2 * Math.PI * (f1 * t + (f2 - f1) * t * t / (2 * duration));
        chirp[i] = Math.sin(phase);
    }
    
    // ãƒãƒ‹ãƒ³ã‚°çª“ã§ãƒ•ã‚§ãƒ¼ãƒ‰
    for (let i = 0; i < samples; i++) {
        const window = 0.5 * (1 - Math.cos(2 * Math.PI * i / samples));
        chirp[i] *= window;
    }
    
    return chirp;
}

// ãƒãƒ£ãƒ¼ãƒ—ä¿¡å·ã®ä½ç½®ã‚’æ¤œå‡ºï¼ˆç›¸äº’ç›¸é–¢ï¼‰
function findChirpOffset(recorded, chirp, sampleRate) {
    // æ¤œç´¢ç¯„å›²: æœ€åˆã®2ç§’é–“
    const searchSamples = Math.min(
        Math.floor(2.0 * sampleRate),
        recorded.length - chirp.length
    );
    
    if (searchSamples <= 0) {
        console.warn('âš ï¸ ãƒ¬ã‚¤ãƒ†ãƒ³ã‚·ãƒ¼æ¤œå‡ºå¤±æ•—: éŒ²éŸ³ãŒçŸ­ã™ãã‚‹');
        return Math.floor(0.5 * sampleRate);
    }
    
    let maxCorr = -Infinity;
    let bestOffset = 0;
    
    // ç²—ã„ã‚¹ã‚­ãƒ£ãƒ³ï¼ˆ100ã‚µãƒ³ãƒ—ãƒ«åˆ»ã¿ï¼‰
    for (let offset = 0; offset < searchSamples; offset += 100) {
        let corr = 0;
        for (let i = 0; i < chirp.length; i++) {
            corr += recorded[offset + i] * chirp[i];
        }
        if (corr > maxCorr) {
            maxCorr = corr;
            bestOffset = offset;
        }
    }
    
    // ç´°ã‹ã„èª¿æ•´ï¼ˆÂ±100ã‚µãƒ³ãƒ—ãƒ«ç¯„å›²ã§1ã‚µãƒ³ãƒ—ãƒ«åˆ»ã¿ï¼‰
    const fineStart = Math.max(0, bestOffset - 100);
    const fineEnd = Math.min(searchSamples, bestOffset + 100);
    maxCorr = -Infinity;
    
    for (let offset = fineStart; offset < fineEnd; offset++) {
        let corr = 0;
        for (let i = 0; i < chirp.length; i++) {
            corr += recorded[offset + i] * chirp[i];
        }
        if (corr > maxCorr) {
            maxCorr = corr;
            bestOffset = offset;
        }
    }
    
    // ä¿¡é ¼åº¦è¨ˆç®—
    let recEnergy = 0;
    let chirpEnergy = 0;
    for (let i = 0; i < chirp.length; i++) {
        recEnergy += recorded[bestOffset + i] * recorded[bestOffset + i];
        chirpEnergy += chirp[i] * chirp[i];
    }
    
    const normalizedCorr = maxCorr / (Math.sqrt(recEnergy * chirpEnergy) + 1e-10);
    
    console.log('ãƒãƒ£ãƒ¼ãƒ—æ¤œå‡º: offset=' + bestOffset + ' (' + (bestOffset/sampleRate).toFixed(3) + 's), ä¿¡é ¼åº¦=' + normalizedCorr.toFixed(3));
    
    if (normalizedCorr < 0.5) {
        console.warn('âš ï¸ ãƒ¬ã‚¤ãƒ†ãƒ³ã‚·ãƒ¼æ¤œå‡ºã®ä¿¡é ¼åº¦ãŒä½ã„ï¼ˆ' + normalizedCorr.toFixed(3) + ' < 0.5ï¼‰');
    }
    
    return bestOffset;
}

// ãƒ¬ã‚¤ãƒ†ãƒ³ã‚·ãƒ¼ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å®Ÿè¡Œ
async function calibrateLatency(audioContext, mediaStream, speakerId) {
    const fs = audioContext.sampleRate;
    const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);
    
    console.log('=== ãƒ¬ã‚¤ãƒ†ãƒ³ã‚·ãƒ¼ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹ ===');
    
    // 1. ãƒ†ã‚¹ãƒˆãƒãƒ£ãƒ¼ãƒ—ç”Ÿæˆ
    const chirp = generateCalibrationChirp(fs);
    console.log('  ãƒãƒ£ãƒ¼ãƒ—ç”Ÿæˆ: ' + chirp.length + 'ã‚µãƒ³ãƒ—ãƒ« (' + (chirp.length/fs*1000).toFixed(0) + 'ms)');
    
    // 2. éŒ²éŸ³æ™‚é–“è¨­å®šï¼ˆå‰ãƒãƒƒãƒ•ã‚¡0.5ç§’ + ãƒãƒ£ãƒ¼ãƒ—0.1ç§’ + æ¤œç´¢ä½™è£•2ç§’ï¼‰
    const recordingDuration = 2.6;
    const totalSamples = Math.round(recordingDuration * fs);
    
    // 3. ScriptProcessorã§éŒ²éŸ³æº–å‚™
    const bufferSize = 4096;
    const recorded = new Float32Array(totalSamples);
    let recordedSamples = 0;
    let resolveRecording;
    const recordingDone = new Promise(r => { resolveRecording = r; });
    
    const source = audioContext.createMediaStreamSource(mediaStream);
    const processor = audioContext.createScriptProcessor(bufferSize, 1, 1);
    
    processor.onaudioprocess = (e) => {
        const input = e.inputBuffer.getChannelData(0);
        for (let i = 0; i < input.length; i++) {
            if (recordedSamples < totalSamples) {
                recorded[recordedSamples++] = input[i];
            }
        }
        if (recordedSamples >= totalSamples) {
            resolveRecording();
        }
    };
    
    const dummyDestination = audioContext.createMediaStreamDestination();
    source.connect(processor);
    processor.connect(dummyDestination);
    
    console.log('  éŒ²éŸ³æº–å‚™å®Œäº†ã€200mså¾…æ©Ÿ...');
    
    // 4. éŒ²éŸ³ãƒãƒƒãƒ•ã‚¡å®‰å®šå¾…æ©Ÿ
    await new Promise(resolve => setTimeout(resolve, 200));
    
    console.log('  ãƒãƒ£ãƒ¼ãƒ—å†ç”Ÿé–‹å§‹');
    
    // 5. ãƒãƒ£ãƒ¼ãƒ—å†ç”Ÿ
    const chirpBuffer = audioContext.createBuffer(1, chirp.length, fs);
    chirpBuffer.copyToChannel(chirp, 0);
    const chirpSource = audioContext.createBufferSource();
    chirpSource.buffer = chirpBuffer;
    
    if (isIOS) {
        chirpSource.connect(audioContext.destination);
        chirpSource.start(audioContext.currentTime);
    } else {
        const destination = audioContext.createMediaStreamDestination();
        chirpSource.connect(destination);
        
        const audio = new Audio();
        audio.srcObject = destination.stream;
        
        if (speakerId && typeof audio.setSinkId === 'function') {
            try {
                await audio.setSinkId(speakerId);
            } catch (err) {
                console.warn('Calibration: setSinkIdå¤±æ•—:', err.message);
            }
        }
        
        await audio.play();
        chirpSource.start(audioContext.currentTime);
    }
    
    // 6. éŒ²éŸ³å®Œäº†ã¾ã§å¾…æ©Ÿ
    await recordingDone;
    
    // 7. ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
    source.disconnect();
    processor.disconnect();
    
    console.log('=== ãƒ¬ã‚¤ãƒ†ãƒ³ã‚·ãƒ¼éŒ²éŸ³å®Œäº†: ' + recordedSamples + 'ã‚µãƒ³ãƒ—ãƒ« ===');
    
    // 8. ç›¸äº’ç›¸é–¢ã§ã‚ªãƒ•ã‚»ãƒƒãƒˆæ¤œå‡º
    const latencyOffset = findChirpOffset(recorded, chirp, fs);
    
    console.log('=== ãƒ¬ã‚¤ãƒ†ãƒ³ã‚·ãƒ¼æ¤œå‡ºå®Œäº†: ' + latencyOffset + 'ã‚µãƒ³ãƒ—ãƒ« (' + (latencyOffset/fs).toFixed(3) + 'ç§’) ===');
    
    return latencyOffset;
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 1ãƒãƒ³ãƒ‰å†ç”Ÿãƒ»éŒ²éŸ³
// Sweepå†ç”Ÿã¨åŒæ™‚ã«éŒ²éŸ³é–‹å§‹ã€recordingç§’å¾Œã«åœæ­¢
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 1ãƒãƒ³ãƒ‰å†ç”Ÿãƒ»éŒ²éŸ³ï¼ˆMediaStreamDestinationæ–¹å¼ãƒ»Bluetoothå¯¾å¿œï¼‰
// Sweepå†ç”Ÿã¨åŒæ™‚ã«éŒ²éŸ³é–‹å§‹ã€recordingç§’å¾Œã«åœæ­¢
// å‰å¾Œã«ä½™è£•ã‚’æŒãŸã›ã€ç›¸äº’ç›¸é–¢ã§æ­£ç¢ºãªä½ç½®ã‚’æ¤œå‡º
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function playAndRecord(ctx, stream, sweepData, centerHz, speakerId) {
    const cfg = MEASUREMENT_CONFIG.timing;
    const fs  = ctx.sampleRate;
    
    // éŒ²éŸ³ãƒãƒƒãƒ•ã‚¡: å‰å¾Œã«ä½™è£•ï¼ˆBluetoothé…å»¶ãƒ»ã‚¸ãƒƒã‚¿ãƒ¼å¯¾å¿œï¼‰
    // å‰ãƒãƒƒãƒ•ã‚¡0.5ç§’ + stimulus + recording + å¾Œãƒãƒƒãƒ•ã‚¡0.5ç§’
    const preBuffer  = Math.round(0.5 * fs);
    const postBuffer = Math.round(0.5 * fs);
    const sweepSamples = sweepData.sweep.length;
    const recordingSamples = Math.round(cfg.recording * fs);
    const totalSamples = preBuffer + sweepSamples + recordingSamples + postBuffer;

    // ScriptProcessorã§éŒ²éŸ³
    const bufferSize = 4096;
    const recorded = new Float32Array(totalSamples);
    let recordedSamples = 0;
    let resolveRecording;
    const recordingDone = new Promise(r => { resolveRecording = r; });

    const source = ctx.createMediaStreamSource(stream);
    const processor = ctx.createScriptProcessor(bufferSize, 1, 1);

    processor.onaudioprocess = (e) => {
        const input = e.inputBuffer.getChannelData(0);
        for (let i = 0; i < input.length; i++) {
            if (recordedSamples < totalSamples) {
                recorded[recordedSamples++] = input[i];
            }
        }
        if (recordedSamples >= totalSamples) {
            resolveRecording();
        }
    };

    // ScriptProcessorã®æ¥ç¶šï¼ˆChromeä»•æ§˜ã§å¿…è¦ï¼‰
    // MediaStreamDestinationã«æ¥ç¶šã™ã‚‹ã“ã¨ã§ç‰©ç†å‡ºåŠ›ã‚’å›é¿
    const dummyDestination = ctx.createMediaStreamDestination();
    source.connect(processor);
    processor.connect(dummyDestination);  // ä»®æƒ³å‡ºåŠ›ã®ã¿

    // â­ éŒ²éŸ³ãƒãƒƒãƒ•ã‚¡ãŒå®‰å®šã™ã‚‹ã¾ã§å¾…æ©Ÿï¼ˆ200msï¼‰
    // OSã®éŒ²éŸ³ç«‹ã¡ä¸ŠãŒã‚Šé…å»¶å¯¾ç­–ï¼šmacOS/iOS 100-200ms, Windows 50-150ms, Android 100-300ms
    // ã“ã®å¾…æ©Ÿã«ã‚ˆã‚Šã€Sweepã®æœ€åˆã‹ã‚‰ç¢ºå®Ÿã«éŒ²éŸ³ã•ã‚Œã€ç›¸äº’ç›¸é–¢ã®æˆåŠŸç‡ãŒåŠ‡çš„ã«å‘ä¸Š
    await new Promise(resolve => setTimeout(resolve, 200));

    // Sweepä¿¡å·ã‚’æº–å‚™
    const sweepBuffer = ctx.createBuffer(1, sweepData.sweep.length, fs);
    sweepBuffer.copyToChannel(sweepData.sweep, 0);
    const sweepSource = ctx.createBufferSource();
    sweepSource.buffer = sweepBuffer;

    // audioå¤‰æ•°ã‚’é–¢æ•°ã‚¹ã‚³ãƒ¼ãƒ—ã§å®£è¨€ï¼ˆiOS/éiOSä¸¡æ–¹ã§ä½¿ãˆã‚‹ã‚ˆã†ã«ï¼‰
    let audio = null;

    if (isIOS) {
        // iOSå°‚ç”¨ãƒ‘ã‚¹ï¼šMediaStreamDestinationå›é¿ï¼ˆã¶ã¤åˆ‡ã‚Œå¯¾ç­–ï¼‰
        // ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼é¸æŠã¯è«¦ã‚ã‚‹ãŒã€éŸ³ã¯å®‰å®š
        sweepSource.connect(ctx.destination);
        
        // AudioContext.resume()ï¼ˆiOSå¿…é ˆï¼‰
        if (ctx.state === 'suspended') {
            await ctx.resume();
        }
        
        sweepSource.start(ctx.currentTime);
        
    } else {
        // PC/Androidï¼šMediaStreamDestinationçµŒç”±ï¼ˆã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼é¸æŠå¯èƒ½ï¼‰
        const destination = ctx.createMediaStreamDestination();
        sweepSource.connect(destination);

        // HTMLAudioElementã§å†ç”Ÿï¼ˆã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼æŒ‡å®šï¼‰
        audio = new Audio();
        audio.srcObject = destination.stream;
        
        if (speakerId && typeof audio.setSinkId === 'function') {
            try {
                await audio.setSinkId(speakerId);
            } catch (err) {
                console.warn(`${centerHz}Hz: setSinkIdå¤±æ•—ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼ä½¿ç”¨ï¼‰:`, err.message);
            }
        }

        // HTMLAudioElementã®å†ç”Ÿã‚’å…ˆã«é–‹å§‹
        await audio.play();
        
        // å†ç”ŸãŒç¢ºå®Ÿã«å§‹ã¾ã‚‹ã¾ã§å¾…æ©Ÿï¼ˆ100msï¼‰
        // ã“ã‚Œã«ã‚ˆã‚ŠAudioContextã¨HTMLAudioElementã®ã‚¿ã‚¤ãƒŸãƒ³ã‚°ãŒã‚ºãƒ¬ãªã„
        await new Promise(resolve => setTimeout(resolve, 100));
        
        // BufferSourceã‚’é–‹å§‹
        sweepSource.start(ctx.currentTime);
    }

    // éŒ²éŸ³å®Œäº†ã¾ã§å¾…æ©Ÿ
    await recordingDone;

    // ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
    source.disconnect();
    processor.disconnect();
    // sweepSource.stop()ã¯ä¸è¦ï¼ˆBufferSourceã¯è‡ªå‹•åœæ­¢ã€æ˜ç¤ºçš„stop()ã¯ãƒãƒƒãƒ—ãƒã‚¤ã‚ºã®åŸå› ï¼‰
    
    if (audio) {
        audio.pause();
        audio.srcObject = null;
    }

    return recorded;
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ã‚ªã‚¯ã‚¿ãƒ¼ãƒ–ãƒãƒ³ãƒ‰å®Œäº†æ™‚ã®æ—©æœŸæ‰“ã¡åˆ‡ã‚Šåˆ¤å®š
// ç¢ºå®šå¼: validOctaves + remainingOctaves < 4 â†’ åœæ­¢
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// checkEarlyTermination: ãƒ–ãƒ­ãƒ¼ãƒ‰ãƒãƒ³ãƒ‰æ–¹å¼ç§»è¡Œã«ã‚ˆã‚Šå»ƒæ­¢ (Rev 18.20)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ãƒ¡ã‚¤ãƒ³æ¸¬å®šã‚·ãƒ¼ã‚±ãƒ³ã‚¹
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function runMeasurementSequence() {
    const statusEl  = document.getElementById('measureStatus');
    const startBtn  = document.getElementById('startMeasBtn');
    const progressEl = document.getElementById('measureProgress');

    startBtn.disabled = true;
    document.getElementById('remeasureWarning').style.display = 'none';

    // ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«å–å¾—ï¼ˆãƒ«ãƒ¼ãƒ—å…¨ä½“ã§ä½¿ç”¨ï¼‰
    const snrProfile    = SNR_PROFILES[currentSNRProfile];
    const totalBands    = snrProfile.totalBands;
    const initTimeSec   = 20; // sweep(5s) + recording(5s) + analysis(~3s) + overhead

    // é€²æ—ãƒãƒ¼åˆæœŸåŒ–
    progressEl.style.display = 'block';
    document.getElementById('progressBar').style.width = '0%';
    document.getElementById('progressCount').textContent = 'æº–å‚™ä¸­...';
    document.getElementById('progressTime').textContent = 'æ®‹ã‚Šç´„ ' + initTimeSec + ' ç§’';
    document.getElementById('progressLabel').textContent = 'ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ä¸­...';

    // â”€â”€ ã‚¹ãƒ†ãƒ¼ã‚¸0: AudioContext ä½œæˆãƒ»ã‚µãƒ³ãƒ—ãƒ«ãƒ¬ãƒ¼ãƒˆç¢ºèª â”€â”€
    try {
        audioContext = new (window.AudioContext || window.webkitAudioContext)({
            sampleRate: MEASUREMENT_CONFIG.sampleRate
        });

        const actualFs = audioContext.sampleRate;
        if (actualFs !== MEASUREMENT_CONFIG.sampleRate) {
            throw new Error(
                `ã“ã®ãƒ‡ãƒã‚¤ã‚¹ã¯48kHzã‚µãƒ³ãƒ—ãƒ«ãƒ¬ãƒ¼ãƒˆã«å¯¾å¿œã—ã¦ã„ã¾ã›ã‚“ã€‚\n` +
                `ï¼ˆæ¤œå‡ºå€¤: ${actualFs}Hzï¼‰\n` +
                `ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼/ãƒã‚¤ã‚¯ã®è¨­å®šã‚’ç¢ºèªã™ã‚‹ã‹ã€åˆ¥ã®ãƒ‡ãƒã‚¤ã‚¹ã§æ¸¬å®šã—ã¦ãã ã•ã„ã€‚`
            );
        }
    } catch (err) {
        statusEl.textContent = 'âŒ ' + err.message;
        statusEl.className = 'status-msg error';
        startBtn.disabled = false;
        progressEl.style.display = 'none';
        return;
    }

    // â”€â”€ Workerã¸INITé€ä¿¡ï¼ˆsampleRateãƒ»configä¸€æ‹¬é€šçŸ¥ + SNRé–¾å€¤ï¼‰ â”€â”€
    const configWithSNR = {
        ...MEASUREMENT_CONFIG,
        analysis: {
            ...MEASUREMENT_CONFIG.analysis,
            minSnr: snrProfile.threshold
        }
    };
    
    measurementWorker.postMessage({
        type:       'INIT',
        sampleRate: audioContext.sampleRate,
        config:     configWithSNR
    });

    // AudioContext.resume()ï¼ˆãƒ–ãƒ©ã‚¦ã‚¶ã®Autoplay Policyã«å¯¾å¿œï¼‰
    if (audioContext.state === 'suspended') {
        try {
            await audioContext.resume();
            console.info('AudioContext resumed');
        } catch (err) {
            console.warn('AudioContext.resume()å¤±æ•—:', err.message);
        }
    }

    // â”€â”€ ã‚¹ãƒ†ãƒ¼ã‚¸0: ãƒã‚¤ã‚¯ã‚¹ãƒˆãƒªãƒ¼ãƒ å–å¾— â”€â”€
    try {
        const micId = document.getElementById('micSelect').value;
        const constraints = {
            audio: {
                deviceId: micId ? { exact: micId } : undefined,
                echoCancellation: false,
                noiseSuppression: false,
                autoGainControl: false,
                sampleRate: MEASUREMENT_CONFIG.sampleRate
            }
        };
        mediaStream = await navigator.mediaDevices.getUserMedia(constraints);
    } catch (err) {
        statusEl.textContent = 'âŒ ãƒã‚¤ã‚¯ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + err.message;
        statusEl.className = 'status-msg error';
        startBtn.disabled = false;
        progressEl.style.display = 'none';
        return;
    }

    // â”€â”€ ã‚¹ãƒ†ãƒ¼ã‚¸1: ã‚¢ãƒŠã‚¦ãƒ³ã‚¹Beep + æ¸¬å®šé–‹å§‹é€šçŸ¥ â”€â”€
    // ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼ãƒ‡ãƒã‚¤ã‚¹IDã‚’å–å¾—
    const speakerId = document.getElementById('spkSelect').value;
    
    statusEl.textContent = `ğŸ”” æ¸¬å®šã‚’é–‹å§‹ã—ã¾ã™ã€‚é™ã‹ã«ã—ã¦ãã ã•ã„ï¼ˆç´„${initTimeSec}ç§’ï¼‰`;
    statusEl.className = 'status-msg calibrating';
    document.getElementById('recordingAlert').classList.add('active');

    try {
        await playBeep(audioContext, speakerId);
        console.info('âœ… BeepéŸ³å†ç”Ÿå®Œäº†');
    } catch (err) {
        // Beepå¤±æ•—ã¯éè‡´å‘½çš„ â†’ ç¶šè¡Œ
        console.warn('Beepå†ç”Ÿå¤±æ•—ï¼ˆç¶šè¡Œï¼‰:', err.message);
    }

    // â”€â”€ ã‚¹ãƒ†ãƒ¼ã‚¸1.3: ãƒ¬ã‚¤ãƒ†ãƒ³ã‚·ãƒ¼ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ â”€â”€
    statusEl.textContent = 'ğŸ” ã‚·ã‚¹ãƒ†ãƒ é…å»¶ã‚’æ¸¬å®šä¸­...ï¼ˆç´„3ç§’ï¼‰';
    statusEl.className = 'status-msg calibrating';
    document.getElementById('progressLabel').textContent = 'ã‚·ã‚¹ãƒ†ãƒ é…å»¶æ¸¬å®šä¸­...';
    
    try {
        systemLatencyOffset = await calibrateLatency(audioContext, mediaStream, speakerId);
        
        const latencyMs = (systemLatencyOffset / audioContext.sampleRate * 1000).toFixed(0);
        console.info('âœ… ã‚·ã‚¹ãƒ†ãƒ é…å»¶æ¤œå‡º: ' + systemLatencyOffset + 'ã‚µãƒ³ãƒ—ãƒ« (' + latencyMs + 'ms)');
        
        statusEl.textContent = 'âœ… ã‚·ã‚¹ãƒ†ãƒ é…å»¶: ' + latencyMs + 'ms';
        statusEl.className = 'status-msg success';
        await sleep(1000); // 1ç§’é–“è¡¨ç¤º
        
    } catch (err) {
        console.warn('âš ï¸ ãƒ¬ã‚¤ãƒ†ãƒ³ã‚·ãƒ¼æ¸¬å®šå¤±æ•—ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’ä½¿ç”¨:', err.message);
        systemLatencyOffset = Math.floor(0.5 * audioContext.sampleRate);
    }

    // â”€â”€ ã‚¹ãƒ†ãƒ¼ã‚¸1.5: ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆãƒã‚¤ã‚ºãƒ•ãƒ­ã‚¢æ¸¬å®šï¼‰ â”€â”€
    statusEl.textContent = 'ğŸ“Š ç’°å¢ƒãƒã‚¤ã‚ºã‚’æ¸¬å®šä¸­...ï¼ˆ5ç§’ï¼‰';
    statusEl.className = 'status-msg calibrating';
    document.getElementById('progressLabel').textContent = 'ç’°å¢ƒãƒã‚¤ã‚ºæ¸¬å®šä¸­...';
    
    let noiseRecording;
    try {
        noiseRecording = await measureNoiseFloor(audioContext, mediaStream);
        
        // Workerå´ã§ãƒãƒ³ãƒ‰åˆ¥è§£æã‚’å®Ÿè¡Œï¼ˆéåŒæœŸãƒ»ãƒ–ãƒ­ãƒƒã‚¯ã—ãªã„ï¼‰
        measurementWorker.postMessage({
            type: 'CALIBRATION',
            noiseRecording: noiseRecording.buffer
        }, [noiseRecording.buffer]); // Transferable
        
        console.info('âœ… ãƒã‚¤ã‚ºãƒ•ãƒ­ã‚¢éŒ²éŸ³å®Œäº† â†’ Workerã§è§£æä¸­');
    } catch (err) {
        console.warn('âš ï¸ ãƒã‚¤ã‚ºãƒ•ãƒ­ã‚¢æ¸¬å®šå¤±æ•—:', err.message);
    }
    
    console.info('ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å®Œäº†ã€18ãƒãƒ³ãƒ‰æ¸¬å®šã«é€²ã¿ã¾ã™');

    // â”€â”€ ãƒ¬ã‚¤ãƒ†ãƒ³ã‚·ãƒ¼ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’Workerã«é€ä¿¡ â”€â”€
    measurementWorker.postMessage({
        type: 'SET_LATENCY',
        latencyOffset: systemLatencyOffset
    });
    console.info('  ãƒ¬ã‚¤ãƒ†ãƒ³ã‚·ãƒ¼ã‚ªãƒ•ã‚»ãƒƒãƒˆé€ä¿¡: ' + systemLatencyOffset + 'ã‚µãƒ³ãƒ—ãƒ«');

    // â”€â”€ ã‚¹ãƒ†ãƒ¼ã‚¸2: ãƒ–ãƒ­ãƒ¼ãƒ‰ãƒãƒ³ãƒ‰å˜ä¸€ã‚¹ã‚¤ãƒ¼ãƒ—æ¸¬å®š â”€â”€
    // ISO 3382-2æº–æ‹ : 1å›éŒ²éŸ³ â†’ 1å›deconvolution â†’ Workerå†…ã§18ãƒãƒ³ãƒ‰å‡¦ç†
    console.info('=== ãƒ–ãƒ­ãƒ¼ãƒ‰ãƒãƒ³ãƒ‰ã‚¹ã‚¤ãƒ¼ãƒ—æ¸¬å®šé–‹å§‹ ===');

    statusEl.textContent = 'ğŸ”Š ã‚¹ã‚¤ãƒ¼ãƒ—å†ç”Ÿãƒ»éŒ²éŸ³ä¸­...ï¼ˆç´„12ç§’ï¼‰';
    statusEl.className = 'status-msg analyzing';
    document.getElementById('progressLabel').textContent = 'ã‚¹ã‚¤ãƒ¼ãƒ—å†ç”Ÿä¸­...';

    // Bluetooth/ãƒ‡ãƒã‚¤ã‚¹å®‰å®šåŒ–å¾…æ©Ÿ
    await sleep(MEASUREMENT_CONFIG.timing.delay * 1000);

    // ãƒ–ãƒ­ãƒ¼ãƒ‰ãƒãƒ³ãƒ‰ã‚¹ã‚¤ãƒ¼ãƒ—ç”Ÿæˆï¼ˆ20Hzã€œ20kHzã€5ç§’ï¼‰
    const sweepResult = generateBroadbandSweep(
        audioContext.sampleRate,
        MEASUREMENT_CONFIG.timing.stimulus
    );
    const { sweep: sweepSignal, fLow: sweepFLow, fHigh: sweepFHigh, durationSec: sweepDuration } = sweepResult;
    console.info('Sweepç”Ÿæˆå®Œäº†: ' + sweepFLow + 'Hz-' + sweepFHigh + 'Hz, ' + sweepSignal.length + 'ã‚µãƒ³ãƒ—ãƒ«');

    // å˜ä¸€éŒ²éŸ³ï¼ˆã‚¹ã‚¤ãƒ¼ãƒ—ï¼‹æ®‹éŸ¿å°¾5ç§’ï¼‰
    const sweepDataObj = { sweep: sweepSignal };

    // ãƒ•ã‚§ãƒ¼ã‚º1: éŒ²éŸ³ä¸­ã®æ™‚é–“ãƒ™ãƒ¼ã‚¹é€²æ—ï¼ˆ0â†’50%ï¼‰
    const recordingTotalMs = (MEASUREMENT_CONFIG.timing.stimulus + MEASUREMENT_CONFIG.timing.recording + 1.5) * 1000;
    const recStart = Date.now();
    document.getElementById('progressBar').style.width = '0%';
    document.getElementById('progressCount').textContent = 'éŒ²éŸ³ä¸­...';
    document.getElementById('progressLabel').textContent = 'ğŸ”Š ã‚¹ã‚¤ãƒ¼ãƒ—å†ç”Ÿãƒ»æ®‹éŸ¿éŒ²éŸ³ä¸­';

    const recProgressTimer = setInterval(() => {
        const elapsed = Date.now() - recStart;
        const pct = Math.min(Math.round(elapsed / recordingTotalMs * 50), 49);
        const remaining = Math.max(0, Math.ceil((recordingTotalMs - elapsed) / 1000));
        document.getElementById('progressBar').style.width = pct + '%';
        document.getElementById('progressTime').textContent = 'æ®‹ã‚Šç´„ ' + remaining + ' ç§’';
    }, 300);

    let recorded;
    try {
        recorded = await playAndRecord(
            audioContext, mediaStream, sweepDataObj, 0, speakerId
        );
    } catch (err) {
        clearInterval(recProgressTimer);
        statusEl.textContent = 'âŒ éŒ²éŸ³å¤±æ•—: ' + err.message;
        statusEl.className = 'status-msg error';
        startBtn.disabled = false;
        progressEl.style.display = 'none';
        return;
    }
    clearInterval(recProgressTimer);
    document.getElementById('progressBar').style.width = '50%';
    document.getElementById('progressCount').textContent = 'éŒ²éŸ³å®Œäº†';
    console.info('éŒ²éŸ³å®Œäº†: ' + recorded.length + 'ã‚µãƒ³ãƒ—ãƒ« (' + (recorded.length/audioContext.sampleRate).toFixed(1) + 's)');

    statusEl.textContent = 'ğŸ”„ Farinaæ³•ãƒ‡ã‚³ãƒ³ãƒœãƒªãƒ¥ãƒ¼ã‚·ãƒ§ãƒ³ãƒ»è§£æä¸­...';
    statusEl.className = 'status-msg analyzing';

    // Worker ã«å…¨ãƒãƒ³ãƒ‰è§£æã‚’ä¾é ¼ï¼ˆbandProgress ã§é€²æ—å—ä¿¡ï¼‰
    const analysisResult = await new Promise((resolve) => {
        let completedCount = 0;
        const bands = MEASUREMENT_CONFIG.bands;

        measurementWorker.onmessage = (e) => {
            if (e.data.type === 'debug') {
                console.log('[Worker] ' + e.data.message);
                console.info('[Worker-INFO] ' + e.data.message);
                return;
            }
            if (e.data.type === 'bandProgress') {
                completedCount++;
                const { band, index, total } = e.data;
                // ãƒ•ã‚§ãƒ¼ã‚º2: è§£æé€²æ—ï¼ˆ50%â†’100%ï¼‰
                const analysisPct = Math.round((completedCount / total) * 50);
                document.getElementById('progressBar').style.width = (50 + analysisPct) + '%';
                document.getElementById('progressCount').textContent = 'è§£æ: ' + completedCount + ' / ' + total + ' ãƒãƒ³ãƒ‰';
                document.getElementById('progressTime').textContent = '';
                document.getElementById('progressLabel').textContent = 'ğŸ”„ ' + band + 'Hz è§£æä¸­...';
                statusEl.textContent = 'ğŸ”„ Farinaæ³•è§£æä¸­... ' + band + 'Hz [' + completedCount + '/' + total + ']';
                return;
            }
            if (e.data.type === 'result') {
                console.info('Workerå…¨ãƒãƒ³ãƒ‰è§£æå®Œäº†');
                resolve(e.data);
            }
            if (e.data.type === 'error') {
                console.error('Workerè§£æã‚¨ãƒ©ãƒ¼:', e.data.message);
                resolve({ type: 'error', thirdResults: new Array(18).fill(null) });
            }
        };

        measurementWorker.postMessage({
            type:        'ANALYZE_ALL',
            recorded:    recorded.buffer,
            sweep:       sweepSignal.buffer,
            fLow:        sweepFLow,
            fHigh:       sweepFHigh,
            durationSec: sweepDuration
        }, [recorded.buffer, sweepSignal.buffer]);

        console.info('ANALYZE_ALL é€ä¿¡å®Œäº†ã€è§£æå¾…æ©Ÿä¸­...');
    });

    const thirdResults = analysisResult.thirdResults;

    // â”€â”€ éŒ²éŸ³åœæ­¢ãƒ»ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ— â”€â”€
    document.getElementById('recordingAlert').classList.remove('active');
    if (mediaStream) {
        mediaStream.getTracks().forEach(t => t.stop());
        mediaStream = null;
    }
    if (audioContext) {
        try { await audioContext.close(); } catch(e) {}
        audioContext = null;
    }

    // â”€â”€ ã‚¹ãƒ†ãƒ¼ã‚¸3: å…¨ãƒãƒ³ãƒ‰å®Œäº† â†’ handleMeasurementResult ã¸ â”€â”€
    handleMeasurementResult({ type: 'result', thirdResults });
}
</script>

<script>
// ========================================
// Google Form é€ä¿¡ãƒ»ã‚°ãƒ©ãƒ•æç”»ï¼ˆæ—¢å­˜ã®ã¾ã¾ï¼‰
// ========================================
function sendToGoogleForm() {
    const formUrl = "https://docs.google.com/forms/d/e/1FAIpQLSedr8Z99dcRJuV3qYRmYddUUzYGrnvrz2aU3zbFvrwVpbTreQ/viewform";
    const appSelect = document.getElementById('appTarget');
    const app = appSelect.options[appSelect.selectedIndex].text;
    const w = document.getElementById('w').value;
    const d = document.getElementById('d').value;
    const h = document.getElementById('h').value;
    const size = `${w}m Ã— ${d}m Ã— ${h}m`;
    const wallSelect = document.getElementById('baseWall');
    const ceilingSelect = document.getElementById('baseCeiling');
    const floorSelect = document.getElementById('baseFloor');
    const base = `å£: ${wallSelect.options[wallSelect.selectedIndex].text}, å¤©äº•: ${ceilingSelect.options[ceilingSelect.selectedIndex].text}, åºŠ: ${floorSelect.options[floorSelect.selectedIndex].text}`;
    let productList = "";
    for (let i = 0; i < 3; i++) {
        const spec = selectedSpecs[i];
        const qty = parseInt(document.getElementById(`qty_${i}`).value) || 0;
        if (spec.category && spec.model && spec.thick && spec.size && qty > 0) {
            productList += `ãƒ»${SOUNDBOX_DB.products[spec.category].models[spec.model].n} / ${spec.thick}mm / ${spec.size} Ã— ${qty}æš\n`;
        }
    }
    if (!productList) productList = "é¸æŠãªã—";
    const rtText = document.getElementById('postRT_Avg').textContent;
    const params = new URLSearchParams();
    params.append("usp", "pp_url");
    params.append("entry.1871431492", app);
    params.append("entry.1902994140", size);
    params.append("entry.779901469", base);
    params.append("entry.364281805", productList);
    params.append("entry.1449240528", rtText);
    window.open(`${formUrl}?${params.toString()}`, '_blank');
}

function updateChart(rt_before, rt_after, targetRT) {
    const ctx = document.getElementById('rtChart').getContext('2d');
    if (chart) chart.destroy();

    // nullç‚¹ã‚’ãƒ—ãƒ­ãƒƒãƒˆå¯èƒ½ãªå½¢ã«å¤‰æ›ï¼ˆChart.js spanGapsç”¨ï¼‰
    // nullã®ã¾ã¾ã ã¨ãƒ©ã‚¤ãƒ³ãŒé€”åˆ‡ã‚Œã‚‹ã ã‘ã§N/AãŒåˆ¤åˆ¥ã§ããªã„ãŸã‚
    // å„ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆã«nullã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’è¨˜éŒ²ã—ã€ãƒã‚¤ãƒ³ãƒˆã‚¹ã‚¿ã‚¤ãƒ«ã§Ã—è¡¨ç¤º
    function makePointStyles(data, normalStyle, normalRadius) {
        return data.map(v => v === null ? 'crossRot' : normalStyle);
    }
    function makePointRadii(data, normalRadius) {
        return data.map(v => v === null ? 7 : normalRadius);
    }
    function makePointColors(data, normalColor) {
        return data.map(v => v === null ? '#ff7b72' : normalColor);
    }
    // nullå€¤ã‚’ç›´å‰ã®æœ‰åŠ¹å€¤ã§åŸ‹ã‚ã¦ãƒ©ã‚¤ãƒ³ã‚’ç¹‹ãï¼ˆÃ—ãƒãƒ¼ã‚¯ä½ç½®ã«ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼ï¼‰
    function fillNullForPlot(data) {
        return data.map((v, i) => {
            if (v !== null) return v;
            // å‰å¾Œã®æœ‰åŠ¹å€¤ã®å¹³å‡ã‚’ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼ã¨ã—ã¦ä½¿ç”¨ï¼ˆè¡¨ç¤ºç”¨ã®ã¿ï¼‰
            const prev = data.slice(0, i).reverse().find(x => x !== null);
            const next = data.slice(i+1).find(x => x !== null);
            if (prev !== null && next !== null) return (prev + next) / 2;
            return prev !== null ? prev : (next !== null ? next : 0);
        });
    }

    const beforePlot = fillNullForPlot(rt_before);
    const afterPlot  = fillNullForPlot(rt_after);

    chart = new Chart(ctx, {
        type: 'line',
        data: {
            labels: FREQS.map(f => f + 'Hz'),
            datasets: [
                {
                    label: 'ç¾çŠ¶ (Before)', data: beforePlot, spanGaps: true,
                    borderColor: '#8b949e', backgroundColor: 'rgba(139, 148, 158, 0.05)',
                    borderDash: [5, 5], borderWidth: 2, fill: false, tension: 0.3,
                    pointStyle: makePointStyles(rt_before, 'circle', 4),
                    pointRadius: makePointRadii(rt_before, 4),
                    pointBackgroundColor: makePointColors(rt_before, '#8b949e'),
                    pointBorderColor: makePointColors(rt_before, '#8b949e')
                },
                {
                    label: 'å¯¾ç­–å¾Œ (After)', data: afterPlot, spanGaps: true,
                    borderColor: '#39d353', backgroundColor: 'rgba(57, 211, 83, 0.1)',
                    borderWidth: 3, fill: true, tension: 0.3,
                    pointStyle: makePointStyles(rt_after, 'circle', 5),
                    pointRadius: makePointRadii(rt_after, 5),
                    pointBackgroundColor: makePointColors(rt_after, '#39d353'),
                    pointBorderColor: makePointColors(rt_after, '#fff'),
                    pointBorderWidth: 2
                },
                {
                    label: 'ç›®æ¨™å€¤', data: FREQS.map(() => targetRT),
                    borderColor: '#388bfd', backgroundColor: 'rgba(56, 139, 253, 0.05)',
                    borderWidth: 2, borderDash: [10, 5], fill: false, pointRadius: 0
                }
            ]
        },
        options: {
            responsive: true, maintainAspectRatio: false,
            spanGaps: true,
            interaction: { mode: 'index', intersect: false },
            scales: {
                y: { min: 0, max: 2.5, grid: { color: '#30363d', lineWidth: 1 }, ticks: { color: '#8b949e', font: { size: 11 }, callback: v => v.toFixed(1) + 's' }, title: { display: true, text: 'RT60 (sec)', color: '#8b949e', font: { size: 12, weight: 'bold' } } },
                x: { grid: { color: '#30363d', lineWidth: 1 }, ticks: { color: '#8b949e', font: { size: 11 } } }
            },
            plugins: {
                legend: {
                    display: true, position: 'top',
                    labels: {
                        color: '#e6edf3', font: { size: 11 }, padding: 15,
                        usePointStyle: true,
                        generateLabels: function(chart) {
                            // å‡¡ä¾‹ã‚¢ã‚¤ã‚³ãƒ³ã¯å¸¸ã«â—å›ºå®šï¼ˆãƒ‡ãƒ¼ã‚¿ç‚¹ã®Ã—ã¨ã¯ç‹¬ç«‹ï¼‰
                            const orig = Chart.defaults.plugins.legend.labels.generateLabels(chart);
                            orig.forEach(item => { item.pointStyle = 'circle'; });
                            return orig;
                        }
                    },
                    // N/Aæ³¨è¨˜ã‚’ã‚°ãƒ©ãƒ•ä¸‹ã«è¿½åŠ ã™ã‚‹ãŸã‚ã®afterFitã¯ä¸è¦ï¼ˆãƒ„ãƒ¼ãƒ«ãƒãƒƒãƒ—ã§è£œå®Œï¼‰
                },
                tooltip: {
                    backgroundColor: 'rgba(22, 27, 34, 0.95)', titleColor: '#e6edf3',
                    bodyColor: '#e6edf3', borderColor: '#30363d', borderWidth: 1, padding: 10,
                    callbacks: {
                        label: function(ctx) {
                            if (ctx.datasetIndex === 2) return ctx.dataset.label + ': ' + ctx.parsed.y.toFixed(2) + 's';
                            const raw = ctx.datasetIndex === 0 ? rt_before[ctx.dataIndex] : rt_after[ctx.dataIndex];
                            if (raw === null) return ctx.dataset.label + ': N/Aï¼ˆæ¸¬å®šä¸å¯ï¼‰';
                            // ãƒãƒ³ãƒ‰ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã¯FREQSé…åˆ—ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã¨å¯¾å¿œ
                            const bi = ctx.dataIndex;
                            const method = window._measurementMethod && window._r2Results ? '' : '';
                            const r2 = (window._r2Results && window._r2Results[bi] != null)
                                ? window._r2Results[bi] : null;
                            const meth = (window._methodResultsAll && window._methodResultsAll[bi])
                                ? window._methodResultsAll[bi] : null;
                            let suffix = '';
                            if (meth && r2 != null) suffix = ' (' + meth + ', RÂ²=' + r2.toFixed(2) + ')';
                            else if (meth) suffix = ' (' + meth + ')';
                            return ctx.dataset.label + ': ' + raw.toFixed(2) + 's' + suffix;
                        }
                    }
                }
            }
        }
    });
}
</script>

</body>
</html>
